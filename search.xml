<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>常用的下载方法</title>
      <link href="/2023/08/31/downLoad/index/"/>
      <url>/2023/08/31/downLoad/index/</url>
      
        <content type="html"><![CDATA[<h3 id="通用下载，后端给文件的链接通过浏览器下载"><a href="#通用下载，后端给文件的链接通过浏览器下载" class="headerlink" title="通用下载，后端给文件的链接通过浏览器下载"></a>通用下载，后端给文件的链接通过浏览器下载</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">String</span>&#125; url 文件在服务器的路径</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">String</span>&#125; fileName 文件命名</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">urlDownload</span> = (<span class="params">url, fileName = <span class="string">&#x27;下载文件&#x27;</span></span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 创建隐藏的可下载链接</span></span><br><span class="line">  <span class="keyword">let</span> eleLink = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">  eleLink.<span class="property">download</span> = fileName</span><br><span class="line">  eleLink.<span class="property">style</span>.<span class="property">display</span> = <span class="string">&#x27;none&#x27;</span></span><br><span class="line">  eleLink.<span class="property">href</span> = url</span><br><span class="line">  <span class="comment">// 触发点击</span></span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(eleLink)</span><br><span class="line">  eleLink.<span class="title function_">click</span>()</span><br><span class="line">  <span class="comment">// 然后移除</span></span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">removeChild</span>(eleLink)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="下载多个文件"><a href="#下载多个文件" class="headerlink" title="下载多个文件"></a>下载多个文件</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Array</span>&#125; urls 文件路径列表</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">dowanLoadUrls</span>(<span class="params">urls: <span class="built_in">Array</span>&lt;string&gt;</span>) &#123;</span><br><span class="line">  urls.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (item) &#123;</span><br><span class="line">      <span class="keyword">const</span> iframe = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;iframe&#x27;</span>)</span><br><span class="line"></span><br><span class="line">      iframe.<span class="property">style</span>.<span class="property">display</span> = <span class="string">&#x27;none&#x27;</span></span><br><span class="line">      iframe.<span class="property">src</span> = baseURL + item</span><br><span class="line">      <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(iframe)</span><br><span class="line">      <span class="comment">// elink.click()</span></span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        iframe.<span class="title function_">remove</span>()</span><br><span class="line">      &#125;, <span class="number">50</span> * <span class="number">1000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="返回的是二进制文件流下载"><a href="#返回的是二进制文件流下载" class="headerlink" title="返回的是二进制文件流下载"></a>返回的是二进制文件流下载</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; url 文件路径</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Object</span>&#125; params 请求携带的参数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; filename 请求携带的参数</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">download</span>(<span class="params">url, params, filename, config</span>) &#123;</span><br><span class="line">  downloadLoadingInstance = <span class="title class_">ElLoading</span>.<span class="title function_">service</span>(&#123;</span><br><span class="line">    <span class="attr">text</span>: <span class="string">&#x27;正在下载数据，请稍候&#x27;</span>,</span><br><span class="line">    <span class="attr">background</span>: <span class="string">&#x27;rgba(0, 0, 0, 0.7)&#x27;</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> service</span><br><span class="line">    .<span class="title function_">post</span>(baseURL + url, params, &#123;</span><br><span class="line">      <span class="attr">transformRequest</span>: [</span><br><span class="line">        <span class="function">(<span class="params">params</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="title function_">tansParams</span>(params)</span><br><span class="line">        &#125;,</span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">headers</span>: &#123; <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/x-www-form-urlencoded&#x27;</span> &#125;,</span><br><span class="line">      <span class="attr">responseType</span>: <span class="string">&#x27;blob&#x27;</span>,</span><br><span class="line">      ...config,</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="keyword">async</span> (data) =&gt; &#123;</span><br><span class="line">      <span class="keyword">const</span> isLogin = <span class="keyword">await</span> <span class="title function_">blobValidate</span>(data)</span><br><span class="line">      <span class="keyword">if</span> (isLogin) &#123;</span><br><span class="line">        <span class="keyword">const</span> blob = <span class="keyword">new</span> <span class="title class_">Blob</span>([data])</span><br><span class="line">        <span class="title function_">saveAs</span>(blob, filename)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> resText = <span class="keyword">await</span> data.<span class="title function_">text</span>()</span><br><span class="line">        <span class="keyword">const</span> rspObj = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(resText)</span><br><span class="line">        <span class="keyword">const</span> errMsg = errorCode[rspObj.<span class="property">code</span>] || rspObj.<span class="property">msg</span> || errorCode[<span class="string">&#x27;default&#x27;</span>]</span><br><span class="line">        <span class="title class_">ElMessage</span>.<span class="title function_">error</span>(errMsg)</span><br><span class="line">      &#125;</span><br><span class="line">      downloadLoadingInstance.<span class="title function_">close</span>()</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="title function_">catch</span>(<span class="function">(<span class="params">r</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">error</span>(r)</span><br><span class="line">      <span class="title class_">ElMessage</span>.<span class="title function_">error</span>(<span class="string">&#x27;下载文件出现错误，请联系管理员！&#x27;</span>)</span><br><span class="line">      downloadLoadingInstance.<span class="title function_">close</span>()</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 参数处理</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> &#123;<span class="type">*</span>&#125; params  参数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">tansParams</span>(<span class="params">params</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="string">&#x27;&#x27;</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> propName <span class="keyword">of</span> <span class="title class_">Object</span>.<span class="title function_">keys</span>(params)) &#123;</span><br><span class="line">    <span class="keyword">const</span> value = params[propName];</span><br><span class="line">    <span class="keyword">var</span> part = <span class="built_in">encodeURIComponent</span>(propName) + <span class="string">&quot;=&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (value !== <span class="literal">null</span> &amp;&amp; value !== <span class="string">&quot;&quot;</span> &amp;&amp; <span class="keyword">typeof</span> (value) !== <span class="string">&quot;undefined&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> value === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">of</span> <span class="title class_">Object</span>.<span class="title function_">keys</span>(value)) &#123;</span><br><span class="line">          <span class="keyword">if</span> (value[key] !== <span class="literal">null</span> &amp;&amp; value[key] !== <span class="string">&quot;&quot;</span> &amp;&amp; <span class="keyword">typeof</span> (value[key]) !== <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">let</span> params = propName + <span class="string">&#x27;[&#x27;</span> + key + <span class="string">&#x27;]&#x27;</span>;</span><br><span class="line">            <span class="keyword">var</span> subPart = <span class="built_in">encodeURIComponent</span>(params) + <span class="string">&quot;=&quot;</span>;</span><br><span class="line">            result += subPart + <span class="built_in">encodeURIComponent</span>(value[key]) + <span class="string">&quot;&amp;&quot;</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result += part + <span class="built_in">encodeURIComponent</span>(value) + <span class="string">&quot;&amp;&quot;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line">  <span class="title function_">download</span>(<span class="string">&#x27;/template/downloadTemplateFile&#x27;</span>, &#123; <span class="attr">schemaKey</span>: row.<span class="property">schemaKeyName</span> &#125;, name, <span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="下载xml-txt-下载后是在浏览器打开的情况"><a href="#下载xml-txt-下载后是在浏览器打开的情况" class="headerlink" title="下载xml,txt 下载后是在浏览器打开的情况"></a>下载xml,txt 下载后是在浏览器打开的情况</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">String</span>&#125; url 文件在服务器的路径</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">downLoadXM</span>(<span class="params">url: string</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> name = url.<span class="title function_">replace</span>(<span class="regexp">/\/\w&#123;1,&#125;\/|\w&#123;1,&#125;\//g</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">  <span class="keyword">const</span> createUrl = baseURL + url</span><br><span class="line">  axios</span><br><span class="line">    .<span class="title function_">get</span>(createUrl, &#123;</span><br><span class="line">      <span class="attr">responseType</span>: <span class="string">&#x27;blob&#x27;</span>,</span><br><span class="line">      <span class="attr">headers</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;Content-Disposition&#x27;</span>: <span class="string">&#x27;attachment&#x27;</span>,  <span class="comment">// 解决 下载后是在浏览器打开的问题</span></span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// const blob = new Blob([res.data])</span></span><br><span class="line">      <span class="keyword">const</span> blobUrl = <span class="variable language_">window</span>.<span class="property">URL</span>.<span class="title function_">createObjectURL</span>(res.<span class="property">data</span>)</span><br><span class="line">      <span class="comment">// download(blobUrl, name)</span></span><br><span class="line">      <span class="keyword">let</span> eleLink = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">      eleLink.<span class="property">download</span> = name</span><br><span class="line">      eleLink.<span class="property">style</span>.<span class="property">display</span> = <span class="string">&#x27;none&#x27;</span></span><br><span class="line">      eleLink.<span class="property">href</span> = blobUrl</span><br><span class="line">      <span class="comment">// 触发点击</span></span><br><span class="line">      <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(eleLink)</span><br><span class="line">      eleLink.<span class="title function_">click</span>()</span><br><span class="line">      <span class="comment">// 然后移除</span></span><br><span class="line">      <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">removeChild</span>(eleLink)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="下载-zip-文件"><a href="#下载-zip-文件" class="headerlink" title="下载 zip 文件"></a>下载 zip 文件</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mimeMap = &#123;</span><br><span class="line">  <span class="attr">xlsx</span>: <span class="string">&#x27;application/vnd.openxmlformats-officedocument.spreadsheetml.sheet&#x27;</span>,</span><br><span class="line">  <span class="attr">zip</span>: <span class="string">&#x27;application/zip&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> baseUrl =   process.<span class="property">env</span>.<span class="property">VUE_APP_SERVER_ID</span> == <span class="number">1</span></span><br><span class="line">? <span class="variable language_">window</span>.<span class="property">$BaseUrl</span>.<span class="property">BASE_API</span></span><br><span class="line">: process.<span class="property">env</span>.<span class="property">VUE_APP_BASE_API</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">downLoadZip</span>(<span class="params">str, filename</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> url = baseUrl + str</span><br><span class="line">  <span class="title function_">axios</span>(&#123;</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;get&#x27;</span>,</span><br><span class="line">    <span class="attr">url</span>: url,</span><br><span class="line">    <span class="attr">responseType</span>: <span class="string">&#x27;blob&#x27;</span>,</span><br><span class="line">    <span class="attr">headers</span>: &#123; <span class="string">&#x27;Authorization&#x27;</span>: <span class="string">&#x27;Bearer &#x27;</span> + <span class="title function_">getToken</span>() &#125;</span><br><span class="line">  &#125;).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolveBlob</span>(res, mimeMap.<span class="property">zip</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解析blob响应内容并下载</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">*</span>&#125; res blob响应内容</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">String</span>&#125; mimeType MIME类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">resolveBlob</span>(<span class="params">res, mimeType</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> aLink = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">  <span class="keyword">var</span> blob = <span class="keyword">new</span> <span class="title class_">Blob</span>([res.<span class="property">data</span>], &#123; <span class="attr">type</span>: mimeType &#125;)</span><br><span class="line">  <span class="comment">// //从response的headers中获取filename, 后端response.setHeader(&quot;Content-disposition&quot;, &quot;attachment; filename=xxxx.docx&quot;) 设置的文件名;</span></span><br><span class="line">  <span class="keyword">var</span> patt = <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">&#x27;filename=([^;]+\\.[^\\.;]+);*&#x27;</span>)</span><br><span class="line">  <span class="keyword">var</span> contentDisposition = <span class="built_in">decodeURI</span>(res.<span class="property">headers</span>[<span class="string">&#x27;content-disposition&#x27;</span>])</span><br><span class="line">  <span class="keyword">var</span> result = patt.<span class="title function_">exec</span>(contentDisposition)</span><br><span class="line">  <span class="keyword">var</span> fileName = result[<span class="number">1</span>]</span><br><span class="line">  fileName = fileName.<span class="title function_">replace</span>(<span class="regexp">/\&quot;/g</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">  aLink.<span class="property">href</span> = <span class="variable constant_">URL</span>.<span class="title function_">createObjectURL</span>(blob)</span><br><span class="line">  aLink.<span class="title function_">setAttribute</span>(<span class="string">&#x27;download&#x27;</span>, fileName) <span class="comment">// 设置下载文件名称</span></span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(aLink)</span><br><span class="line">  aLink.<span class="title function_">click</span>()</span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(aLink)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用-file-saver-保存"><a href="#使用-file-saver-保存" class="headerlink" title="使用 file-saver 保存"></a>使用 file-saver 保存</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">npm install file-saver --save</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; param 要保存的字符串</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; name  文件名称</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> &#123; saveAs &#125; <span class="keyword">from</span> <span class="string">&#x27;file-saver&#x27;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> blob = <span class="keyword">new</span> <span class="title class_">Blob</span>([param], &#123; <span class="attr">type</span>: <span class="string">&#x27;application/json;charset=utf-8&#x27;</span> &#125;)</span><br><span class="line">  <span class="title function_">saveAs</span>(blob, name)</span><br></pre></td></tr></table></figure><h3 id="读取本地文件"><a href="#读取本地文件" class="headerlink" title="读取本地文件"></a>读取本地文件</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">el-upload</span></span></span><br><span class="line"><span class="tag">          <span class="attr">action</span>=<span class="string">&quot;#&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">:on-change</span>=<span class="string">&quot;handleChange&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">:show-file-list</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">:auto-upload</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">accept</span>=<span class="string">&quot;json&quot;</span></span></span><br><span class="line"><span class="tag">        &gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">template</span> #<span class="attr">trigger</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">type</span>=<span class="string">&quot;success&quot;</span> <span class="attr">plain</span>&gt;</span>读取JSON文件<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">el-upload</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> javaScript <span class="keyword">const</span> <span class="title function_">handleChange</span> = (<span class="params">uploadFile, uploadFiles</span>) =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;uploadFile&#x27;</span>, uploadFile)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> fileExtension = <span class="string">&#x27;&#x27;</span></span><br><span class="line">  <span class="keyword">if</span> (uploadFile.<span class="property">name</span>.<span class="title function_">lastIndexOf</span>(<span class="string">&#x27;.&#x27;</span>) &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">    fileExtension = uploadFile.<span class="property">name</span>.<span class="title function_">slice</span>(uploadFile.<span class="property">name</span>.<span class="title function_">lastIndexOf</span>(<span class="string">&#x27;.&#x27;</span>) + <span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> isTypeOk = fileExtension === <span class="string">&#x27;json&#x27;</span> ? <span class="literal">true</span> : <span class="literal">false</span></span><br><span class="line">  <span class="keyword">if</span> (!isTypeOk) &#123;</span><br><span class="line">    proxy.<span class="property">$modal</span>.<span class="title function_">msgError</span>(<span class="string">`文件格式不正确, 请上传JSON格式文件!`</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> file = uploadFile</span><br><span class="line">  <span class="keyword">const</span> raw = file?.<span class="property">raw</span></span><br><span class="line">  <span class="keyword">const</span> reader = <span class="keyword">new</span> <span class="title class_">FileReader</span>()</span><br><span class="line">  reader.<span class="title function_">readAsText</span>(raw, <span class="string">&#x27;UTF-8&#x27;</span>)</span><br><span class="line">  reader.<span class="property">onload</span> = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (event.<span class="property">target</span>?.<span class="property">result</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> fileData = event.<span class="property">target</span>.<span class="property">result</span></span><br><span class="line">      codeEditRef.<span class="property">value</span>.<span class="title function_">setCode</span>(fileData)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>下载方法</title>
      <link href="/2023/07/07/%E4%B8%8B%E8%BD%BD%E6%96%B9%E6%B3%95/"/>
      <url>/2023/07/07/%E4%B8%8B%E8%BD%BD%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="一-返回文件流下载"><a href="#一-返回文件流下载" class="headerlink" title="一 返回文件流下载"></a>一 返回文件流下载</h3> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="comment">// 通用下载方法</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">download</span>(<span class="params">url, params, filename, config</span>) &#123;</span><br><span class="line">  downloadLoadingInstance = <span class="title class_">ElLoading</span>.<span class="title function_">service</span>(&#123;</span><br><span class="line">    <span class="attr">text</span>: <span class="string">&#x27;正在下载数据，请稍候&#x27;</span>,</span><br><span class="line">    <span class="attr">background</span>: <span class="string">&#x27;rgba(0, 0, 0, 0.7)&#x27;</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> service</span><br><span class="line">    .<span class="title function_">post</span>(baseURL + url, params, &#123;</span><br><span class="line">      <span class="attr">transformRequest</span>: [</span><br><span class="line">        <span class="function">(<span class="params">params</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="title function_">tansParams</span>(params)</span><br><span class="line">        &#125;,</span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">headers</span>: &#123; <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/x-www-form-urlencoded&#x27;</span> &#125;,</span><br><span class="line">      <span class="attr">responseType</span>: <span class="string">&#x27;blob&#x27;</span>,</span><br><span class="line">      ...config,</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="keyword">async</span> (data) =&gt; &#123;</span><br><span class="line">      <span class="keyword">const</span> isLogin = <span class="keyword">await</span> <span class="title function_">blobValidate</span>(data)</span><br><span class="line">      <span class="keyword">if</span> (isLogin) &#123;</span><br><span class="line">        <span class="keyword">const</span> blob = <span class="keyword">new</span> <span class="title class_">Blob</span>([data])</span><br><span class="line">        <span class="title function_">saveAs</span>(blob, filename)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> resText = <span class="keyword">await</span> data.<span class="title function_">text</span>()</span><br><span class="line">        <span class="keyword">const</span> rspObj = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(resText)</span><br><span class="line">        <span class="keyword">const</span> errMsg = errorCode[rspObj.<span class="property">code</span>] || rspObj.<span class="property">msg</span> || errorCode[<span class="string">&#x27;default&#x27;</span>]</span><br><span class="line">        <span class="title class_">ElMessage</span>.<span class="title function_">error</span>(errMsg)</span><br><span class="line">      &#125;</span><br><span class="line">      downloadLoadingInstance.<span class="title function_">close</span>()</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="title function_">catch</span>(<span class="function">(<span class="params">r</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">error</span>(r)</span><br><span class="line">      <span class="title class_">ElMessage</span>.<span class="title function_">error</span>(<span class="string">&#x27;下载文件出现错误，请联系管理员！&#x27;</span>)</span><br><span class="line">      downloadLoadingInstance.<span class="title function_">close</span>()</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二-链接下载"><a href="#二-链接下载" class="headerlink" title="二 链接下载"></a>二 链接下载</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> baseURL =</span><br><span class="line">  <span class="keyword">import</span>.<span class="property">meta</span>.<span class="property">env</span>.<span class="property">VITE_APP_SERVER_ID</span> == <span class="number">1</span></span><br><span class="line">    ? <span class="variable language_">window</span>.<span class="property">$BaseUrl</span>.<span class="property">BASE_API</span></span><br><span class="line">    : <span class="keyword">import</span>.<span class="property">meta</span>.<span class="property">env</span>.<span class="property">VITE_APP_BASE_API</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">dowanLoadUrls</span>(<span class="params">urls: <span class="built_in">Array</span>&lt;string&gt;</span>) &#123;</span><br><span class="line">  urls.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (item) &#123;</span><br><span class="line">      <span class="keyword">const</span> iframe = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;iframe&#x27;</span>)</span><br><span class="line"></span><br><span class="line">      iframe.<span class="property">style</span>.<span class="property">display</span> = <span class="string">&#x27;none&#x27;</span></span><br><span class="line">      iframe.<span class="property">src</span> = baseURL + item</span><br><span class="line">      <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(iframe)</span><br><span class="line">      <span class="comment">// elink.click()</span></span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        iframe.<span class="title function_">remove</span>()</span><br><span class="line">      &#125;, <span class="number">50</span> * <span class="number">1000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  xml 或者txt 的下载用上面的方法下载在浏览器里是预览</span></span><br><span class="line"><span class="comment">// 需要增加 增加头部信息</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">downLoadXM</span>(<span class="params">url</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> name = url.<span class="title function_">split</span>(<span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">  <span class="keyword">const</span> createUrl = baseURL + url</span><br><span class="line">  <span class="title function_">fetch</span>(createUrl, &#123;</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;GET&#x27;</span>,</span><br><span class="line">    <span class="attr">headers</span>: <span class="keyword">new</span> <span class="title class_">Headers</span>(&#123;</span><br><span class="line">      <span class="string">&#x27;Content-Disposition&#x27;</span>: <span class="string">&#x27;attachment&#x27;</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">  &#125;)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> res.<span class="title function_">blob</span>())</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> blobUrl = <span class="variable language_">window</span>.<span class="property">URL</span>.<span class="title function_">createObjectURL</span>(data)</span><br><span class="line">      <span class="title function_">download</span>(blobUrl, name[name.<span class="property">length</span> - <span class="number">1</span>])</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">download</span>(<span class="params">blobUrl, name</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> a = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">  a.<span class="property">download</span> = name</span><br><span class="line">  a.<span class="property">href</span> = blobUrl</span><br><span class="line">  a.<span class="title function_">click</span>()</span><br><span class="line">   <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    documet.<span class="property">body</span>.<span class="title function_">removeChild</span>(a);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>echarts 总结</title>
      <link href="/2023/03/29/echart%E4%BD%BF%E7%94%A8/01/"/>
      <url>/2023/03/29/echart%E4%BD%BF%E7%94%A8/01/</url>
      
        <content type="html"><![CDATA[<h3 id="echarts-属性说明"><a href="#echarts-属性说明" class="headerlink" title="echarts 属性说明"></a>echarts 属性说明</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">       <span class="attr">&quot;backgroundColor&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#f6f6f6&quot;</span><span class="punctuation">,</span>  <span class="comment">// 图形的背景色</span></span><br><span class="line">       <span class="attr">&quot;tooltip&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span>                   <span class="comment">// 鼠标移上显示详细信息</span></span><br><span class="line">         <span class="attr">&quot;trigger&quot;</span><span class="punctuation">:</span> <span class="string">&quot;axis&quot;</span><span class="punctuation">,</span> </span><br><span class="line">         <span class="attr">&quot;axisPointer&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">           <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;line&quot;</span><span class="punctuation">,</span></span><br><span class="line">           <span class="attr">&quot;lineStyle&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">             <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;dashed&quot;</span><span class="punctuation">,</span></span><br><span class="line">             <span class="attr">&quot;color&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#28BBAB&quot;</span><span class="punctuation">,</span></span><br><span class="line">           <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">         <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">       <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">       <span class="attr">&quot;grid&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span>                   <span class="comment">// 图形的页面布局</span></span><br><span class="line">         <span class="attr">&quot;width&quot;</span><span class="punctuation">:</span> <span class="string">&quot;90%&quot;</span><span class="punctuation">,</span></span><br><span class="line">         <span class="attr">&quot;height&quot;</span><span class="punctuation">:</span> <span class="string">&quot;82%&quot;</span><span class="punctuation">,</span></span><br><span class="line">         <span class="attr">&quot;left&quot;</span><span class="punctuation">:</span> <span class="string">&quot;5%&quot;</span><span class="punctuation">,</span></span><br><span class="line">         <span class="attr">&quot;right&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1%&quot;</span><span class="punctuation">,</span></span><br><span class="line">         <span class="attr">&quot;bottom&quot;</span><span class="punctuation">:</span> <span class="string">&quot;12%&quot;</span><span class="punctuation">,</span></span><br><span class="line">         <span class="comment">// containLabel: true</span></span><br><span class="line">       <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">       <span class="attr">&quot;toolbox&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span>            <span class="comment">// 右侧工具条</span></span><br><span class="line">         <span class="attr">&quot;feature&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">           <span class="attr">&quot;dataZoom&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">             <span class="attr">&quot;yAxisIndex&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">           <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">           <span class="attr">&quot;brush&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">             <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">           <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">         <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">       <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">       <span class="attr">&quot;brush&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">         <span class="comment">// xAxisIndex: &quot;All&quot;,</span></span><br><span class="line">         <span class="comment">// yAxisIndex: &quot;ALL&quot;,</span></span><br><span class="line">         <span class="attr">&quot;outOfBrush&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">           <span class="attr">&quot;colorAlpha&quot;</span><span class="punctuation">:</span> <span class="number">0.5</span><span class="punctuation">,</span></span><br><span class="line">         <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">       <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">       <span class="attr">&quot;xAxis&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span>              <span class="comment">// x 轴样式设置</span></span><br><span class="line">         <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;category&quot;</span><span class="punctuation">,</span></span><br><span class="line">         <span class="attr">&quot;splitLine&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">           <span class="comment">// x 轴分割线样式</span></span><br><span class="line">           <span class="attr">&quot;show&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">           <span class="attr">&quot;lineStyle&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">             <span class="attr">&quot;color&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#ebeef5&quot;</span><span class="punctuation">,</span></span><br><span class="line">             <span class="attr">&quot;width&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">           <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">         <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">         <span class="attr">&quot;axisLabel&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">           <span class="attr">&quot;margin&quot;</span><span class="punctuation">:</span> <span class="number">5</span><span class="punctuation">,</span></span><br><span class="line">           <span class="attr">&quot;textStyle&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">             <span class="attr">&quot;color&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#233551&quot;</span><span class="punctuation">,</span></span><br><span class="line">             <span class="attr">&quot;fontSize&quot;</span><span class="punctuation">:</span> <span class="number">12</span><span class="punctuation">,</span></span><br><span class="line">             <span class="attr">&quot;fontWeight&quot;</span><span class="punctuation">:</span> <span class="string">&quot;bold&quot;</span><span class="punctuation">,</span></span><br><span class="line">           <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">         <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">         <span class="attr">&quot;axisTick&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">           <span class="attr">&quot;show&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">           <span class="attr">&quot;lineStyle&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">             <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">             <span class="attr">&quot;color&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#383E56&quot;</span><span class="punctuation">,</span></span><br><span class="line">           <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">         <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">         <span class="attr">&quot;axisLine&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">           <span class="attr">&quot;show&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">           <span class="attr">&quot;lineStyle&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">             <span class="attr">&quot;width&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">           <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">         <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">         <span class="attr">&quot;boundaryGap&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span>     <span class="comment">// 是否从坐标原点起始</span></span><br><span class="line">         <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">       <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">       <span class="attr">&quot;yAxis&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span>                  <span class="comment">// y 轴样式设置</span></span><br><span class="line">         <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;value&quot;</span><span class="punctuation">,</span></span><br><span class="line">         <span class="comment">// onZreo: true,</span></span><br><span class="line">         <span class="attr">&quot;axisTick&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">           <span class="attr">&quot;show&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">           <span class="attr">&quot;lineStyle&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">             <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">           <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">         <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">         <span class="attr">&quot;splitLine&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">           <span class="comment">// y 轴分割线样式</span></span><br><span class="line">           <span class="attr">&quot;show&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">           <span class="attr">&quot;lineStyle&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">             <span class="attr">&quot;color&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#ebeef5&quot;</span><span class="punctuation">,</span></span><br><span class="line">             <span class="attr">&quot;width&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">           <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">         <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">         <span class="attr">&quot;axisLabel&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">           <span class="attr">&quot;margin&quot;</span><span class="punctuation">:</span> <span class="number">10</span><span class="punctuation">,</span></span><br><span class="line">           <span class="attr">&quot;textStyle&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">             <span class="attr">&quot;color&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#233551&quot;</span><span class="punctuation">,</span></span><br><span class="line">             <span class="attr">&quot;fontSize&quot;</span><span class="punctuation">:</span> <span class="number">12</span><span class="punctuation">,</span></span><br><span class="line">             <span class="attr">&quot;fontWeight&quot;</span><span class="punctuation">:</span> <span class="string">&quot;bold&quot;</span><span class="punctuation">,</span></span><br><span class="line">           <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">         <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">         <span class="attr">&quot;axisLine&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">           <span class="attr">&quot;show&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">           <span class="attr">&quot;lineStyle&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">             <span class="attr">&quot;width&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">           <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">         <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">       <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">       <span class="attr">&quot;series&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span>     <span class="comment">// 绘制线条设置</span></span><br><span class="line">         <span class="punctuation">&#123;</span> </span><br><span class="line">           <span class="comment">// sampling: &quot;average&quot;,  //数据过多时，考虑这个属性</span></span><br><span class="line">           <span class="attr">&quot;showSymbol&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span>      <span class="comment">// 折线链接点是否显示原点</span></span><br><span class="line">           <span class="attr">&quot;hoverAnimation&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span>  <span class="comment">// 鼠标移上动画 </span></span><br><span class="line">           <span class="attr">&quot;animation&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span>       <span class="comment">// 动画</span></span><br><span class="line">           <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span>              <span class="comment">// 线条名称</span></span><br><span class="line">           <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">           <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span>                <span class="comment">// 设置线条id </span></span><br><span class="line">           <span class="attr">&quot;step&quot;</span><span class="punctuation">:</span> <span class="string">&quot;start&quot;</span><span class="punctuation">,</span></span><br><span class="line">           <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;line&quot;</span><span class="punctuation">,</span>          <span class="comment">// 设置图形的样式 折线 </span></span><br><span class="line">           <span class="attr">&quot;itemStyle&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">             <span class="attr">&quot;normal&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">               <span class="attr">&quot;color&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">             <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">           <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">         <span class="punctuation">&#125;</span></span><br><span class="line">       <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">       <span class="attr">&quot;dataZoom&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span>            <span class="comment">// 缩放工具条</span></span><br><span class="line">         <span class="punctuation">&#123;</span></span><br><span class="line">           <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;slider&quot;</span><span class="punctuation">,</span></span><br><span class="line">           <span class="comment">// id: &quot;sliderX&quot;,</span></span><br><span class="line">           <span class="attr">&quot;show&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">           <span class="attr">&quot;height&quot;</span><span class="punctuation">:</span> <span class="number">26</span><span class="punctuation">,</span></span><br><span class="line">           <span class="attr">&quot;xAxisIndex&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">           <span class="attr">&quot;start&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">           <span class="attr">&quot;end&quot;</span><span class="punctuation">:</span> <span class="number">100</span><span class="punctuation">,</span></span><br><span class="line">           <span class="attr">&quot;startValue&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span> <span class="comment">//数据窗口范围的起始数值</span></span><br><span class="line">           <span class="attr">&quot;endValue&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span> <span class="comment">//数据窗口范围的结束数值。</span></span><br><span class="line">           <span class="attr">&quot;bottom&quot;</span><span class="punctuation">:</span> <span class="number">15</span><span class="punctuation">,</span></span><br><span class="line">           <span class="attr">&quot;brushSelect&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">           <span class="attr">&quot;realtime&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">           <span class="comment">// filterMode: &quot;empty&quot;,</span></span><br><span class="line"></span><br><span class="line">           <span class="comment">// filterMode: &quot;none&quot;,</span></span><br><span class="line">         <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">         <span class="punctuation">&#123;</span></span><br><span class="line">           <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;inside&quot;</span><span class="punctuation">,</span></span><br><span class="line">           <span class="attr">&quot;xAxisIndex&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="number">0</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">         <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">       <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">     <span class="punctuation">&#125;</span>;</span><br></pre></td></tr></table></figure><h3 id="setOption的使用"><a href="#setOption的使用" class="headerlink" title="setOption的使用"></a>setOption的使用</h3><p>   echrts.setOption(option)<br>   <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> setOptions的参数</span><br><span class="line">(<span class="attr">option</span>: <span class="title class_">Object</span>, notMerge?: <span class="built_in">boolean</span>, lazyUpdate?: <span class="built_in">boolean</span>)</span><br><span class="line"> or</span><br><span class="line"> (<span class="attr">option</span>: <span class="title class_">Object</span>, opts?: &#123;</span><br><span class="line">     notMerge?: <span class="built_in">boolean</span>;</span><br><span class="line">     replaceMerge?: <span class="built_in">string</span> | <span class="built_in">string</span>[];</span><br><span class="line">     lazyUpdate?: <span class="built_in">boolean</span>;</span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure><br>   1、直接使用替换掉原来的option<br>     存在的问题：1、数据添加没有问题，当删除某一条线时，echarts 图没有去掉对应的线<br>                2、全部替换相当于图形重置，之前的缩放状态重置<br>     解决 1问题的 方法，启用setOption 的第二个参数 notMerge<br>      echrts.setOption(option,true) notMerge为true 表示旧的组件会被完全移除，新的组件会根据option创建。</p><ul><li>如果设置opts.notMerge为false，或者没有设置 opts.notMerge：<ul><li>如果在opts.replaceMerge里指定组件类型，这类组件会进行替换合并。</li><li>否则，会进行普通合并。<ul><li>普通合并</li></ul></li></ul></li><li>对于一种类型的组件（如：xAxis, series），新来的 option 中的每个“组件描述”（如：{type: ‘xAxis’, id: ‘xx’, name: ‘kk’, …}）会被尽量合并到已存在的组件中。剩余的情况，会在组件列表尾部创建新的组件。整体规则细节如下：<ul><li>先依次对 option 中每个有声明 id 或者 name 的“组件描述”，寻找能匹配其 id 或者 name 的已有的组件，找到的话则合并。</li><li>再依次对 option 中剩余的“组件描述”，寻找还未执行过前一条的已有组件，找到的话则合并。</li><li>其他 option 中剩余的“组件描述”，用于在组件列表尾部创建新组件。<br>特点：</li><li>永远不会删除已存在的组件。也就是说，只支持增加，或者更新组件。</li><li>组件的索引（componentIndex）永远不会改变。</li><li>如果 id 和 name 没有在 option 中被指定（这是经常出现的情况），组件会按照它在 option 中的顺序一一合并到已有组件中。这种设定比较符合直觉。</li></ul><ul><li>替换合并<br>对于一种类型的组件（如：xAxis, series），只有 option 中指定了 id 并且已有组件中有此 id 时，已有组件会和 option 相应组件描述进行合并。否则，已有组件都会删除，新组件会被根据 option 创建。细节规则如下：<ul><li>先依次对 option 中每个有声明 id 的“组件描述”，寻找能匹配其 id 或者 name 的已有的组件，找到的话则合并。</li><li>删除其他没匹配到的已有组件。</li><li>依次对 option 中剩余的“组件描述”，创建新组件，填入刚因删除而空出来的位置上，或者增加到末尾。<br>特点：</li><li>与 普通合并 相比，支持了组件删除。</li><li>已有组件的索引永远不会变。这是为了保证，option 或者 API 中的 index 引用（例如：xAxisIndex: 2）仍能正常一致得使用。</li><li>整个处理过程结束后，可能存在一些“洞”，也就是说，在组件列表中的某些 index 上，并没有组件存在（被删除了）。但是这是可以被开发者预期和控制的。</li></ul></li></ul></li></ul><ul><li><p>删除组件<br>有两种方法能删除组件：</p><ul><li>删除所有：使用 notMerge: true，则所有组件都被删除。</li><li>删除部分：使用 replaceMerge: […]，被指定的组件类型，会根据 replaceMerge 的规则：如果 id 匹配就合并（ merge ），否则* 旧组件被删除，新组件被创建。“部分删除” 有助于，在删除该删除的组件时，保留其他组件的状态（如高亮、动画、选中状态）。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用例子</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">myecharts</span>.<span class="title function_">setOption</span>(</span><br><span class="line">     &#123;</span><br><span class="line">       <span class="attr">series</span>: <span class="variable language_">this</span>.<span class="property">optionS</span>.<span class="property">series</span>,</span><br><span class="line">       <span class="attr">xAxis</span>: <span class="variable language_">this</span>.<span class="property">optionS</span>.<span class="property">xAxis</span>,</span><br><span class="line">     &#125;,</span><br><span class="line">     &#123;</span><br><span class="line">       <span class="attr">replaceMerge</span>: [<span class="string">&quot;xAxis&quot;</span>, <span class="string">&quot;series&quot;</span>],</span><br><span class="line">     &#125;</span><br><span class="line">   );</span><br><span class="line">   <span class="comment">// 注意点，需要对替换的内容设置唯一id</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> echarts使用 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>elementUI奇怪问题解决办法</title>
      <link href="/2023/03/01/%E9%A1%B9%E7%9B%AE%E9%81%87%E5%88%B0%E7%9A%84%E5%A5%87%E6%80%AA%E9%97%AE%E9%A2%98/elementUI%E5%A5%87%E6%80%AA%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
      <url>/2023/03/01/%E9%A1%B9%E7%9B%AE%E9%81%87%E5%88%B0%E7%9A%84%E5%A5%87%E6%80%AA%E9%97%AE%E9%A2%98/elementUI%E5%A5%87%E6%80%AA%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="el-tabs-切换窗口或者重新编译会有蓝色阴影"><a href="#el-tabs-切换窗口或者重新编译会有蓝色阴影" class="headerlink" title="el-tabs 切换窗口或者重新编译会有蓝色阴影"></a>el-tabs 切换窗口或者重新编译会有蓝色阴影</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 需要在全局添加以下样式</span><br><span class="line">.el-tabs__item:focus.is-active.is-focus:not(:active) &#123;</span><br><span class="line">    -webkit-box-shadow: none !important;</span><br><span class="line">    box-shadow: none !important;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> elementUI奇怪问题解决办法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>项目中常用的js操作,</title>
      <link href="/2023/03/01/%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%94%A8%E5%88%B0%E7%9A%84js%E6%96%B9%E6%B3%95/"/>
      <url>/2023/03/01/%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%94%A8%E5%88%B0%E7%9A%84js%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="创建tag标签"><a href="#创建tag标签" class="headerlink" title="创建tag标签"></a>创建tag标签</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 创建 script 标签 绑定id 创建新的script 时对比删除之前的。</span><br><span class="line">  function  createScipt(str, id) &#123;</span><br><span class="line">      let getId = document.getElementById(id);</span><br><span class="line">      getId ? getId.parentNode.removeChild(getId) : &quot;&quot;;</span><br><span class="line">      let head = document.getElementsByTagName(&quot;head&quot;)[0];</span><br><span class="line">      var script = document.createElement(&quot;script&quot;);</span><br><span class="line">      script.type = &quot;text/javascript&quot;;</span><br><span class="line">      script.text = str;</span><br><span class="line">      script.id = id;</span><br><span class="line">      head.appendChild(script);</span><br><span class="line">      // document.getElementsByTagName(&quot;head&quot;)[0].appendChild(script);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 项目中常用的js操作 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/03/01/%E9%9D%A2%E8%AF%95/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/"/>
      <url>/2023/03/01/%E9%9D%A2%E8%AF%95/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><h1 id="JS"><a href="#JS" class="headerlink" title="JS"></a>JS</h1><ul><li>数据类型有哪些<pre><code>原始类型，引用类型区别是:原始类型是按值传递，引用类型是按引用传递   原始类型 基本数据类型：栈内存   引用数据类型：指针存储在栈，值存储在堆中</code></pre></li><li>判断数据类型的方法有哪些</li><li>instanceof 的原理</li><li></li><li>原型，原型链的理解</li><li>作用域，作用域链</li><li>this 的指向</li><li>事件循环机制</li><li>普通函数和箭头函数的区别是</li><li></li></ul><h1 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h1><p>mvc 和 mvvm 的区别</p><p>vue2 响应式原理<br>   虚拟dom</p><p>vue2 和 vue3 的区别<br>   1 双向数据绑定原理发生了改变<br>      vue2 双向数据绑定是利用ES5 的一个API Object.definePropert() 对数据进行劫持，结合发布订阅模式的方式列实现的，<br>      vue3 中使用了es6 Proxy API 对数据代理。<br>      优势：defineProperty 只能监听某个属性，不能对全对象监听。可以直接监听数组，不用再单独的对数组做特异性操作，直接可以检测到数据的变化。<br>   2 vue3 支持碎片化<br>      也就是说在组件可以拥有多个根节点。<br>   3 Composition API (合成型API)<br>      Vue2 与Vue3 最大的区别————Vue 使用选项类型API(options API) 对比Vue3 合成型API (Composition API)<br>      vue2 选项API 在代码里分割了不同的属性，data、computed属性、methods等。Vue3 组合式API 能让我们用方法来分割</p><h1 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h1><p>   讲讲对webpack 的理解</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>浏览器缓存</title>
      <link href="/2023/03/01/%E9%9D%A2%E8%AF%95/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/"/>
      <url>/2023/03/01/%E9%9D%A2%E8%AF%95/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<h1 id="浏览器缓存机制"><a href="#浏览器缓存机制" class="headerlink" title="浏览器缓存机制"></a>浏览器缓存机制</h1><h2 id="为什么要使用缓存"><a href="#为什么要使用缓存" class="headerlink" title="为什么要使用缓存"></a>为什么要使用缓存</h2><p>缓存是性能优化中简单高效的一种优化方式。一个优秀的缓存策略可以缩短网页请求资源的距离，减少延迟，并且由于缓存文件可以重复利用，还可以减少带宽，降低网络负载。</p><p>对于一个数据请求来说，可以分为发起网络请求、后端处理、浏览器响应三个步骤。浏览器缓存可以帮我们在发起网络请求和浏览器响应优化性能。例如 直接使用缓存而不发起请求，或者发起请求但后端存储的数据和前端一致，那就没有必要将数据回传回来，这样就减少了响应数据。</p><h2 id="缓存位置"><a href="#缓存位置" class="headerlink" title="缓存位置"></a>缓存位置</h2><p>从缓存位置上来说分为四种，并且各自有优先级，当依次查找缓存且都没有命中的时候，才会去请求网络。<br>Service Worker<br>Memory Cache<br>Disk Cache<br>Push Cache</p><h3 id="Service-Worker"><a href="#Service-Worker" class="headerlink" title="Service Worker"></a>Service Worker</h3><p>是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。使用 Service Worker 的话，传输协议必须为 HTTPS。因为 Service Worker 中涉及到请求拦截，所以必须使用 HTTPS 协议来保障安全。它可以让我们自由控制缓存哪些文件，如何匹配缓存，如何读取缓存，并且缓存是持续性的。</p><ul><li>实现缓存功能的步骤<ul><li>首先注册 Service Worker</li><li>监听到 install 事件以后就可以缓存文件，在下次用户访问的时候就可以通过拦截请求的方式查询是否存在缓存，存在缓存的话就可以直接读取缓存文件，否则就去请求数据</li><li>当没有命中缓存的时候，我们需要去调用 fetch 函数获取数据。会根据缓存查找优先级去查找数据，但是不管是从 Memory Cache 中还是网络请求中获取的数据，浏览器都会显示我们是从 Service Worker 中获取的内容。</li></ul></li></ul><h3 id="Memory-Cache"><a href="#Memory-Cache" class="headerlink" title="Memory Cache"></a>Memory Cache</h3><p><code>Memory Cache</code> 是内存中的缓存，主要包含的是当前页面中已经抓取到的资源。eg:页面样式、脚本、图片等。</p><ul><li>内存缓存的特点<br>内存缓存读取高效，但是缓存持续性很短，会随着进程的释放而释放。<code>一旦关闭 Tab 页面，内存中的缓存也就被释放了。</code> 计算的内存容量小，所以缓存不能全部放在内存中。<br>注意点：<code>内存缓存在缓存资源时并不关心返回资源的 HTTP 缓存头 Cache-Control是什么值，同时资源的匹配也并非仅仅是对 URL 做匹配，还可能会对 Content-Type，CORS 等其他特征做校验。</code></li></ul><h3 id="Disk-Cache"><a href="#Disk-Cache" class="headerlink" title="Disk Cache"></a>Disk Cache</h3><p>Disk Cache 也就是存储在硬盘中的缓存，读取速度慢，但是什么都可以存储到硬盘中。<br>在所有浏览器缓存中，Disk Cache 覆盖面是最大的，它会根据 HTTP Herder 中的字段判断哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源已经过期需要重新请求，并且即使在跨站点的情况下，相同地址的资源一旦被硬盘缓存下来，就不会再次去请求数据。</p><h3 id="Push-Cache"><a href="#Push-Cache" class="headerlink" title="Push Cache"></a>Push Cache</h3><p>Push Cache (推送缓存) 是 HTTP/2 中的内容，Service Worker Memory Cache Disk Cache 三种缓存都没有命中的时，才会使用。Push Cache 只在会话中存在，一旦会话结束就被释放，并且缓存时间也很短暂。在 Chome 浏览器中只有五分钟左右，同时它也并非严格执行 HTTP 头中的缓存指令。</p><ul><li>所有的资源都能被推送并且能够被缓存，但是 Edge 和 Safari 浏览器支持相对比较差</li><li>可以推送 no-cache 和 no-store 的资源</li><li>一旦连接关闭，Push Cache 就释放</li><li>多个页面可以使用同一个 HTTP/2 连接，也就是可以使用同一个 Push Cache</li><li>Push Cache 中的缓存只能被使用一次</li><li>浏览器可以拒绝接受已经存在的资源推送</li><li>可以给其他域名推送资源</li></ul><p>如果以上四种缓存都没有命中的话，那么就只能发起请求来获取资源。为了性能上的考虑，大部分的接口都应该选择好缓存策略，<code>通常浏览器缓存策略分为两种：强缓存和协商缓存，并且缓存策略都是通过设置 HTTP Header 来实现</code></p><h2 id="缓存过程分析"><a href="#缓存过程分析" class="headerlink" title="缓存过程分析"></a>缓存过程分析</h2><p>浏览器和服务器的通讯方式为应答模式，即浏览器发起 HTTP 请求-服务器响应该请求，<code>那么浏览器怎么确定一个资源该不该缓存，如何去缓存呢？</code>浏览器第一次向服务器发起该请求后拿到请求结果后，将请求结果和缓存标识存入浏览器缓存，<code>浏览器对于缓存的处理是根据第一次请求资源时返回的响应头来确定的。</code></p><p><img src="https://upload-images.jianshu.io/upload_images/3174701-de3d6e025582103a?imageMogr2/auto-orient/strip%7CimageView2/2/w/670/format/webp" alt="发起请求"></p><ul><li>浏览器每次发起请求，都会在浏览器缓存中查找该请求的结果以及缓存标识</li><li>浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存中。</li></ul><h2 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h2><p>强缓存：不会向服务器发送请求，直接从缓存中读取资源，在 chorme 控制台中可以看到该请求返回 200 的状态码，并且 Size 显示 from disk cache 或 from memory cache 。强缓存可以通过设置两种 HTTP Header 实现： Expires 和 Cache-Control</p><h3 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h3><p><code>缓存过期时间，用来指定资源到期的时间，是服务器端的具体的时间点</code>。也就是说 Expires= max-age + 请求时间，需要和 Last-modified 结合使用。<code>Last-Modified</code>是服务器认为文件的最后修改时间，是第一次请求文件的时候，服务器返回的一个属性。<br>Expires 是 Web 服务器响应消息头字段，在响应 http 请求时告诉浏览器在过期时间前浏览器可以直接从缓存取数据，而无需再次请求</p><p>Expires 是 Http/1 的产物，受限于本地时间，如果修改了本地时间，可能会造成缓存失效。</p><h3 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h3><p>Cache-Control 是最重要的规则，主要用于控制网页缓存。可以在请求头或者响应头中设置。</p><p><img src="https://upload-images.jianshu.io/upload_images/3174701-8ff981603cdfded0?imageMogr2/auto-orient/strip%7CimageView2/2" alt="Cache-Control"></p><ul><li><p>public</p><ul><li>所有内容都将被缓存(客户端和代理服务器都可缓存)。响应可被任何中间节点缓存，</li><li>Browser &lt;– proxy1 &lt;– proxy2 &lt;– server 中间的 proxy 可以缓存。</li></ul></li><li><p>private</p><ul><li>所有内容只有客户端可以缓存，cache-control 的默认取值。具体来说，表示中间节点不允许缓存</li><li>对于 Browser &lt;– proxy1 &lt;– proxy2 &lt;– server，proxy 会把 server 返回的数据发送给 proxy1，自己不缓存任何数据，当下次浏览器再次请求时 proxy 会做好请求转发而不是自作主张给自己缓存的数据。</li></ul></li><li><p>no-cache</p><ul><li>客户端缓存内容，是否使用缓存则需要经过协商缓存来验证决定。表示不使用 Cache-Control 的缓存控制方式做前置验证，而是使用 Etag 或者 Last-Modified 字段来控制缓存。</li></ul></li><li><p>no-store</p><ul><li>所有的内容都不会被缓存，即不使用强制缓存，也不使用协商缓存。</li></ul></li><li><p>max-age</p><ul><li>max-age=xxx 表示缓存内容将在 xxx 秒后失效。</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/3174701-3fa81f5e9efac5af?imageMogr2/auto-orient/strip%7CimageView2/2" alt></p></li></ul><h3 id="Expires-和-Cache-Control-两者对比"><a href="#Expires-和-Cache-Control-两者对比" class="headerlink" title="Expires 和 Cache-Control 两者对比"></a>Expires 和 Cache-Control 两者对比</h3><p>Expires 是 http1.0 的产物，Cache-Control 是 Http1.1 的产物，<code>两者同时存在的话，Cache-Control优先级高于Expires</code>。<br>强缓存判断是否缓存的依据是来自于是否超出某个时间或者某个时间段，而不关心服务器端文件是否已经更新，这就可能会导致加载文件不是服务器端最新的内容。此时我们需要用协商缓存策略。</p><h2 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h2><p><code>协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程</code></p><ul><li>协商缓存生效，返回 304 和 Not Modified</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/3174701-660fd163329d080b?imageMogr2/auto-orient/strip%7CimageView2/2/w/709/format/webp" alt="协商缓存生效"></p><ul><li>协商缓存失效，返回 200 和请求结果<br><img src="https://upload-images.jianshu.io/upload_images/3174701-24953079cfebf2bf?imageMogr2/auto-orient/strip%7CimageView2/2/format/webp" alt="协商缓存失效"><br>协商缓存可以通过设置 HttP Header 实现：Last-Modified 和 ETag</li></ul><h3 id="Last-Modified-和-If-Modified-Since"><a href="#Last-Modified-和-If-Modified-Since" class="headerlink" title="Last-Modified 和 If-Modified-Since"></a>Last-Modified 和 If-Modified-Since</h3><p>浏览器在第一次访问资源时，服务器返回资源的同时，在 response header 中添加 Last-Modified 的 header,值是这个资源在服务器上的最后修改时间。<br>浏览器下次请求这个资源，浏览器检测到有 Last-Modified 这个 header，于是 添加 If-Modified-Since header 值就是 Last-Modified 中的值；服务器再次收到这个资源的请求，会根据 If-Modified-Since 中的值与服务器中这个资源的最后修改时间做对比，如果没有变化，返回 304 和空的响应体，直接从缓存中读取，如果 If-Modified-Since 的时间小于服务器中资源最后修改时间，说明文件有更新于是返回新的资源文件和 200</p><p><img src="https://upload-images.jianshu.io/upload_images/3174701-bb7148a4431ccda1?imageMogr2/auto-orient/strip%7CimageView2/2/w/438/format/webp" alt></p><p>弊端：</p><ul><li>如果只是在本地打开文件，没有对文件进行修改，但是还是会造成 Last-Modified 被修改，服务器不能命中缓存</li><li>Last-Modified 只能以秒计时，如果在不可感知的时间内修改文件，服务器会认为会命中缓存</li></ul><p>根据文件修改时间来决定是否缓存存在问题，可以直接根据文件内容是否修改来决定缓存策略</p><h3 id="ETag-和-If-None-Match"><a href="#ETag-和-If-None-Match" class="headerlink" title="ETag 和 If-None-Match"></a>ETag 和 If-None-Match</h3><p>ETag 是服务器响应请求时，返回当前资源文件的一个唯一标识(Hash 值 由服务器生成)，只要资源有变化。ETag 就会重新生成。在下一次加载资源向服务器发送请求时，会将上次返回的 ETag 值放到 request header 里的 If-None-Match 里，服务器比较客户端传过来的 If-None-Match 跟自己服务器上该资源的 ETag 是否一致。就可以判断资源是不是最新的</p><p>Last-Modified 和 ETag 的对比</p><ul><li>精确度<br>Etag 要优于 Last-Modifed，Last-Modified 的时间单位是秒，如果资源在一秒内改变多次，Last-Modified 其实并不能体现出来，如果是负载均衡的服务器各个服务器生成的 Last-Modified 也有可能不一致。 ETag 每次都会改变确保了精确度。</li><li>性能上<br>ETag 要逊于 Last-Modified ，last-Modified 只需要记录时间，ETag 需要服务器通过算法来计算一个 hash 值。</li><li>优先级<br>服务器校验优先考虑 ETag</li></ul><h2 id="缓存机制"><a href="#缓存机制" class="headerlink" title="缓存机制"></a>缓存机制</h2><p>强缓存优先于协商缓存，若强缓存(Expires 和 Cache-Control) 生效则直接使用缓存，若不生效则进行协商缓存(Last-Modified/If-Modified-since 和 ETag/If-None-Match)，协商缓存由服务器决定是否使用缓存，若协商缓存失效，则缓存失效，返回 200 重新返回资源和缓存标识，再存入浏览器缓存中，生效则返回 304 继续使用缓存<br><img src="https://upload-images.jianshu.io/upload_images/3174701-9d9e8b52a18ed35a?imageMogr2/auto-orient/strip%7CimageView2/2/w/519/format/webp" alt></p><h2 id="实际场景应用缓存策略"><a href="#实际场景应用缓存策略" class="headerlink" title="实际场景应用缓存策略"></a>实际场景应用缓存策略</h2><h3 id="频繁变动的资源"><a href="#频繁变动的资源" class="headerlink" title="频繁变动的资源"></a>频繁变动的资源</h3><p>Cache-Control:no-cache<br>对于频繁变动的资源，首先需要使用 Cache-Control:no-cache 使浏览器每次都请求服务器，然后配合 ETag 或者 Last-Modified 来验证资源是否有效。这样的作法虽然不能节省请求数量，但是可以显著减少响应数据的大小</p><h3 id="不常变动的资源"><a href="#不常变动的资源" class="headerlink" title="不常变动的资源"></a>不常变动的资源</h3><p>Cache-Control:max-age = 31356000</p><p>通常处理这类资源时，给他们的 Cache-Control 配置一个很大的 max-age= 31536000(一年)，这样浏览器之后请求相同 Url 会命中强制缓存。而为了解决更新的问题，就需要在文件名中添加 hash 版本号等动态字符，之后更改为动态字符，从而达到更改引用 URL 的目的让之前的强制缓存失效(其实并未立即消失，只是暂时不再使用而已)</p><h2 id="用户行为对浏览器缓存的影响"><a href="#用户行为对浏览器缓存的影响" class="headerlink" title="用户行为对浏览器缓存的影响"></a>用户行为对浏览器缓存的影响</h2><p>指的就是用户再浏览器操作时，会触发怎样的缓存策略。主要有三种</p><ul><li>打开网页，地址输入 URL:查找 <code>disk cache</code> 中是否有匹配。如有则使用，没有则发送网络请求。</li><li>普通刷新(F5) 因为 tab 页没有关闭，因此 <code>memory cache</code>是可用的，会被优先使用(如果匹配的话)，其次才是 disk cache</li><li>强制刷新( Ctrl + F5): 浏览器不使用缓存，因此发送请求的头部均带有 <code>Cache-control:no-cache</code> ( 为了兼容，还带了 Pargam:no-cache),服务器直接返回 200 和最新内容。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 浏览器缓存 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>从URL输入到页面展现涉及的知识。</title>
      <link href="/2023/03/01/%E9%9D%A2%E8%AF%95/%E4%BB%8EURL%E8%BE%93%E5%85%A5%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%A4%BA/"/>
      <url>/2023/03/01/%E9%9D%A2%E8%AF%95/%E4%BB%8EURL%E8%BE%93%E5%85%A5%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%A4%BA/</url>
      
        <content type="html"><![CDATA[<p>总体分为六个过程</p><ul><li>DNS 解析：将域名解析成 IP 地址</li><li>TCP 连接：TCP 三次握手</li><li>发送 HTTP 请求</li><li>服务器处理请求并返回 HTTP 报文</li><li>浏览器解析渲染页面</li><li>断开连接：TCP 四次挥手</li></ul><h1 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h1><p>URL (Unifrom Resource Locator)，统一资源定位符，用于定位互联网上资源，俗称网址。</p><ul><li><p>遵循的语法规则<br>scheme://host.domain:port/path/filename</p><ul><li>scheme - 定义因特网服务的类型。常见的协议有 http、https、ftp、file 其中最常见的类型是 http，而 https 则是进行加密的网络传输。</li><li>host - 定义域主机(http 的默认主机是 www)</li><li>domain - 定义因特网<code>域名</code>，eg: w3school.com.cn</li><li>port - 定义主机上的端口号 (http 的默认端口号是 80)</li><li>path - 定义服务器上的路径 (如果省略，则文档必须位于网站的根目录中)</li><li>filename - 定义文档/资源的名称</li></ul></li><li><p>URL 编码</p><p>URL 只能使用 ASCII 字符集，不属于 ASCII 中的字符，都必须进行编码才能使用 URL 来进行表示，若传输时使用了特殊字符会造成不必要的问题，导致服务器不能解析。</p><ul><li>编码方法<br>使用 JavaScript 中 3 对方法进行 URL 的 编码/解码 <code>escape/unescape，encodeURI/decodeURI 和encodeURIComponent/decodeURIComponent</code>,<br>三者适用场合不同，<code>encodeURI</code> 用于对整个 URI 进行编码 <code>encodeURIComponent</code> 被用于对 URI 的一部份进行编码，通常是指查询字符串或路径。</li></ul></li></ul><h1 id="域名解析-DNS"><a href="#域名解析-DNS" class="headerlink" title="域名解析 (DNS)"></a>域名解析 (DNS)</h1><p>在浏览器输入网址后，首先要经过域名解析，浏览器并不能直接通过域名找到对应的服务器，而是通过 IP 地址</p><h2 id="IP-地址"><a href="#IP-地址" class="headerlink" title="IP 地址"></a>IP 地址</h2><p>IP 地址是指互联网协议地址，是 IP Address 的缩写。 IP 地址是 IP 协议提供的一种统一的地址格式，它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。Ip 地址是一个 32 位的二进制数。</p><p><code>域名相当于 IP 地址乔装打扮的伪装者，带着一副面具。作用就是便于记忆和沟通的一组服务器的地址。</code>与 Ip 地址的一组纯数字相比，用字母配合数字的表示形式来指定计算机名更符合人类的记忆习惯，但要计算机去理解就相对变得的困难，为了解决这个问题,DNS 服务器应运而生。</p><h2 id="什么是域名解析"><a href="#什么是域名解析" class="headerlink" title="什么是域名解析"></a>什么是域名解析</h2><p>DNS 协议提供通过域名查找 IP 地址，或逆向从 IP 地址反查域名的服务，DNS 是一个网络服务器，我们的域名解析简单来说就是在 DNS 上记录一条信息。</p><h2 id="浏览器如何通过域名去查询-URL-对应的-IP"><a href="#浏览器如何通过域名去查询-URL-对应的-IP" class="headerlink" title="浏览器如何通过域名去查询 URL 对应的 IP"></a>浏览器如何通过域名去查询 URL 对应的 IP</h2><ul><li>浏览器缓存：浏览器会按照一定的频率缓存 DNS 记录。</li><li>操作系统缓存：如果浏览器缓存中找不到需要的 DNS 记录，那就从操作系统中找。</li><li>路由缓存： 路由器也有 DNS 缓存。</li><li>ISP 的 DNS 服务器：ISP 是互联网提供商 (Internet Service Provider)的简称，ISP 有专门的 DNS 服务器应对 DNS 查询请求。</li><li>根服务器：ISP 的 DNS 服务器还找不到的话，它就会向根服务器发出请求，进行递归查询 (DNS 服务先问根域名服务器.com 域名服务器的 IP 地址，然后再问 .baidu 域名服务器，依次类推)</li></ul><p><code>浏览器通过向 DNS 服务器发送域名，DNS 服务器查询到与域名相对应的 IP 地址，然后返回给浏览器，浏览器再将 IP 地址打在协议上，同时请求参数也会在协议搭载，然后一并发送给对应的服务器。</code></p><h1 id="TCP-三次握手"><a href="#TCP-三次握手" class="headerlink" title="TCP 三次握手"></a>TCP 三次握手</h1><p>三次握手其实就是指建立一个 TCP 连接时，需要客户端和服务器端总共发送三个包。进行三次握手的主要目的是为了确认双方的接收能力和发送能力是否正常，指定自己的初始化序列号为后面的可靠性传送做准备。<br>在客户端发送数据之前会发起 TCP 三次握手用以同步客户端和服务端的序列号和确认号，并交换 TCP 窗口大小信息。</p><h3 id="握手过程"><a href="#握手过程" class="headerlink" title="握手过程"></a>握手过程</h3><p>刚开始客户端处于 closed 的状态，服务器处于 Listen 状态。</p><ul><li>第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN。此时客户端处于 SYN_Send 状态</li><li>第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 作为应答，并且也是指定了自己的初始化序列号 ISN，同时会把客户端的 ISN+1 作为 ACK 的值，表示已经收到了客户端的 SYN，此时服务器处于 SYN_REVD 的状态</li><li>第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，把服务器 ISN+1 作为 ACK 的值。表示已经收到了服务端的 SYN 报文，此时客户端处于 establised 状态。</li><li>服务器收到 ACK 报文之后，也处于 establised 状态。<br><img src="https://user-gold-cdn.xitu.io/2019/4/10/16a074b331fb0d85?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt></li></ul><p>注意点：解释一下为啥只有三次握手才能确认双方的接受与发送能力是否正常，而两次却不可以：<br>第一次握手：客户端发送网络包，服务端收到了。这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。<br>第二次握手：服务端发包，客户端收到了。这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。<br>第三次握手：客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。</p><h1 id="发送-HTTP-请求"><a href="#发送-HTTP-请求" class="headerlink" title="发送 HTTP 请求"></a>发送 HTTP 请求</h1><p>http 请求报文由请求行(request line)、请求头(header)、请求体、空行(blank line)四部分组成。</p><ul><li>请求行包含请求方法、URL、协议版本<ul><li>请求方法包含 8 种:get、post、put、delete、patch、head、options、trace<ul><li>get 请求<br>数据是英文字母/数字，原样发送；如果是空格，转换为 + ；如果是中文/其他字符，则直接把字符串用 BASE64 加密,得出：%E4%BD，其中%XX 中的 XX 为该字符号以 16 进制表示的 ASCII。</li><li>post 请求</li></ul></li><li>URL 即请求地址，由&lt;协议&gt;://&lt;主机&gt;:&lt;端口&gt;/&lt;路径&gt;?&lt;参数&gt; 组成</li><li>协议版本即 http 版本号。</li></ul></li><li>请求头包含请求附加信息，由关键字/值对组成每行一对，关键字和值用英文冒号分隔。<br>请求头部通知服务器有关于客户端请求的信息。它包含许多有关的客户端环境和请求正文的有用信息。eg:host，表示主机名，使用 keepalive,即持久连接，一个连接可以发多个请求；</li><li>请求体，可以承载多个请求参数的数据，包含回车符、换行符、和请求数据。</li></ul><p><img src="https://segmentfault.com/img/bVQL82?w=594&h=232" alt="http请求报文格式"></p><h1 id="服务器处理请求并返回-HTTP-报文"><a href="#服务器处理请求并返回-HTTP-报文" class="headerlink" title="服务器处理请求并返回 HTTP 报文"></a>服务器处理请求并返回 HTTP 报文</h1><h2 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h2><p>服务器是网络环境中的高性能计算机，它侦听网络上的其他计算机(客户机)提交的服务请求，并提供响应的服务，eg:网页服务、文件下载、邮件服务、视频服务。客户端的主要功能是浏览网页、看视频、等等两者截然不同。每台服务器上都会安装处理请求的应用————web server .<br><code>web server 担任管控的角色</code>，对于不同用户发送的请求，会结合配置文件，把不同请求委托给服务器上处理相应请求的程序进行处理，然后返回后台程序处理产生的结果作为响应。</p><h1 id="浏览器解析渲染页面"><a href="#浏览器解析渲染页面" class="headerlink" title="浏览器解析渲染页面"></a>浏览器解析渲染页面</h1><p>浏览器解析渲染页面分为五个步骤</p><ul><li>根据 HTML 解析出 DOM 树</li><li>根据 CSS 解析生成 CSS 规则树</li><li>结合 DOM 树和 CSS 规则树，生成渲染树</li><li>根据渲染树计算每一个节点是信息</li><li>根据计算好的信息绘制页面</li></ul><h2 id="根据-HTML-解析出-DOM-树"><a href="#根据-HTML-解析出-DOM-树" class="headerlink" title="根据 HTML 解析出 DOM 树"></a>根据 HTML 解析出 DOM 树</h2><ul><li>根据 HTML 的内容，将标签按照结构解析成为 DOM 树，DOM 树解析的过程是一个深度优先遍历。即先构建当前节点的所有子节点，再构建下一个兄弟节点。</li><li>在读取 HTML 文档，构建 DOM 树的过程中，若遇到 script 标签，则 DOM 树的构建会暂停，直至脚本执行完毕。</li></ul><h2 id="根据-CSS-解析生成-CSS-规则树"><a href="#根据-CSS-解析生成-CSS-规则树" class="headerlink" title="根据 CSS 解析生成 CSS 规则树"></a>根据 CSS 解析生成 CSS 规则树</h2><ul><li>解析 CSS 规则树时 js 执行将暂停，直至 CSS 规则树就绪。</li><li>浏览器在 CSS 规则树生成之前不会进行渲染。</li></ul><h2 id="结合-DOM-树和-CSS-规则树，生成渲染树"><a href="#结合-DOM-树和-CSS-规则树，生成渲染树" class="headerlink" title="结合 DOM 树和 CSS 规则树，生成渲染树"></a>结合 DOM 树和 CSS 规则树，生成渲染树</h2><ul><li>DOM 树和 CSS 规则树全部准备好了以后，浏览器才开始构建渲染树。</li><li>精简 CSS 并可以加快 CSS 规则树的构建，从而加快页面相应速度。</li></ul><h2 id="根据渲染树计算每一个节点的信息-布局"><a href="#根据渲染树计算每一个节点的信息-布局" class="headerlink" title="根据渲染树计算每一个节点的信息(布局)"></a>根据渲染树计算每一个节点的信息(布局)</h2><ul><li>布局：通过渲染树中渲染对象的信息，计算出每一个渲染对象的位置和尺寸。</li><li>回流：在布局完成后，发现了某个部分发生了变化影响了布局，那就需要倒回去重新渲染。</li></ul><h2 id="根据计算好的信息绘制页面"><a href="#根据计算好的信息绘制页面" class="headerlink" title="根据计算好的信息绘制页面"></a>根据计算好的信息绘制页面</h2><ul><li>绘制阶段：系统会遍历呈现树，并调用呈现器的”paint”方法，将呈现器的内容显示在屏幕上。</li><li>重绘：某个元素的背景颜色，文字颜色等，不影响元素周围或内部布局的属性，将只会引起浏览器的重绘。</li><li>回流：某个元素的尺寸发生了变化，则需要重新计算渲染树，重新渲染。</li></ul><h1 id="断开连接"><a href="#断开连接" class="headerlink" title="断开连接"></a>断开连接</h1><p>当数据传送完毕，需要断开 tcp 连接，此时发起 tcp 四次挥手。</p><ul><li>发起方向被动方发送报文，Fin、Ack、Seq，表示已经没有数据传输了。并进入 FIN_WAIT_1 状态。(第一次挥手：由浏览器发起的，发送给服务器，我请求报文发送完了，你准备关闭吧)</li><li>被动方发送报文，Ack、Seq，表示同意关闭请求。此时主机发起方进入 FIN_WAIT_2 状态。(第二次挥手：由服务器发起的，告诉浏览器，我请求报文接受完了，我准备关闭了，你也准备吧)</li><li>被动方向发起方发送报文段，Fin、Ack、Seq，请求关闭连接。并进入 LAST_ACK 状态。(第三次挥手：由服务器发起，告诉浏览器，我响应报文发送完了，你准备关闭吧)</li><li>发起方向被动方发送报文段，Ack、Seq。然后进入等待 TIME_WAIT 状态。被动方收到发起方的报文段以后关闭连接。发起方等待一定时间未收到回复，则正常关闭。(第四次挥手：由浏览器发起，告诉服务器，我响应报文接受完了，我准备关闭了，你也准备吧)</li></ul>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 从URL输入到页面展现涉及的知识。 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>作用域-作用域链</title>
      <link href="/2023/03/01/%E9%9D%A2%E8%AF%95/%E4%BD%9C%E7%94%A8%E5%9F%9F-%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/"/>
      <url>/2023/03/01/%E9%9D%A2%E8%AF%95/%E4%BD%9C%E7%94%A8%E5%9F%9F-%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h1><p>作用域是运行时代码的某些特定部分中变量，函数和对象的可访问性。即作用域决定了代码区块中变量和其他资源的可见性。<br>函数作用域在函数定义的时候就决定了。函数内部有个内部属性[[scope]],当函数创建的时候，就会保存所有父变量对象到其中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function outFun2()&#123;</span><br><span class="line">  var inVariable = &#x27;内层变量2&#x27;</span><br><span class="line">&#125;</span><br><span class="line">outFun2()</span><br><span class="line">console.log(inVariable)  // Uncaught ReferenceError: inVariable is not defined</span><br></pre></td></tr></table></figure><p>作用域最大的用处是隔离变量，不同作用域下同名变量不会有冲突。Es6 之前 JavaScript 没有块级作用域，只有全局作用域和函数作用域。</p><h2 id="全局作用域和函数作用域"><a href="#全局作用域和函数作用域" class="headerlink" title="全局作用域和函数作用域"></a>全局作用域和函数作用域</h2><ul><li><p>最外层的函数和在最外层函数外面定义的变量拥有全局作用域</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var outVariable = &#x27;我是最外层变量&#x27;</span><br><span class="line">function outFun() &#123;</span><br><span class="line">  var inVariable = &#x27;内层变量&#x27;;</span><br><span class="line">  function innerFun() &#123;</span><br><span class="line">    console.log(inVariable)</span><br><span class="line">  &#125;</span><br><span class="line">  innerFun()</span><br><span class="line">&#125;</span><br><span class="line">console.log(outVariable)   // 我是外层变量</span><br><span class="line">outFun()                   // 内层变量</span><br><span class="line">console.log(inVariable)    // inVariable is not defined</span><br><span class="line">innerFun()                 // innerFun is not defined</span><br></pre></td></tr></table></figure></li><li><p>所有未定义直接赋值的变量自动声明为拥有全局作用域</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function outFun2()&#123;</span><br><span class="line">  variable = &#x27;未定义直接赋值的变量&#x27;;</span><br><span class="line">  var inVariable2 = &#x27;内层变量2&#x27;</span><br><span class="line">&#125;</span><br><span class="line">outFun2()</span><br><span class="line">console.log(variable)      // 未定义直接赋值的变量</span><br><span class="line">console.log(inVariable2)   // inVariable2 is not defined</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>所有 window 对象的属性拥有全局作用域<br>一般情况下，window 对象的内置属性都拥有全局作用域，eg:window.name、window.location 等。</p></li></ul><p>全局作用域有个弊端：如果我们写了很多行 JS 代码，变量定义都没有用函数包括，那么他们就全部都在全局作用域中。这样就会污染全局命名空间，容易起命名冲突。</p><p>注意：全局作用域在页面打开时被创建，页面关闭时被销毁。</p><h2 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a>函数作用域</h2><p>函数作用域，是指声明在函数内部的变量，和全局作用域相反，局部作用域一般只在固定的代码片段内可以访问到</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function doSomeThing()&#123;</span><br><span class="line">  var blogName = &#x27;blogName&#x27;</span><br><span class="line">  function innerSay()&#123;</span><br><span class="line">    alert(blogName)</span><br><span class="line">  &#125;</span><br><span class="line">  innerSay()</span><br><span class="line">&#125;</span><br><span class="line">console.log(blogName) // blogName is not defined</span><br><span class="line">innerSay()            // innerSay is not defined</span><br></pre></td></tr></table></figure><ul><li>调用函数时，函数作用域被创建，函数执行完毕，函数作用域被销毁。</li><li>每调用一次函数就会创建一个新的函数作用域，他们之间是互相独立的。</li><li>函数作用域中可以访问到全局作用域的变量，在函数外部无法访问函数内部的变量。</li><li>在函数作用域中访问变量、函数会先在自身作用域中寻找，若是没有找到会到函数上一级作用域中寻找，一直到全局作用域，若是还没有找到返回 undefined。</li><li>函数作用域中也有声明提前的特性，对于变量和函数都起作用。</li><li>在函数中定义形参，等同于声明变量。</li></ul><p>作用域是分层的，内层作用域可以访问外层作用域的变量。</p><h2 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h2><p>块级作用域可通过新增命令 let 和 const 声明，所声明的变量在指定块的作用域外无法被访问。</p><ul><li>块级作用域的特点<ul><li>变量声明不会提前到代码顶部<br>let/const 声明并不会被提升到当前代码块的顶部，因此需要手动将 let/const 声明放置到顶部，以便让变量在整个代码块内部可用。</li><li>禁止重复声明，如果一个标识符已经在代码块内声明过，那么在此代码块内使用同一个标进行 let 声明就会抛出错误。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var count = 30</span><br><span class="line">let count = 40  // Uncaught SyntaxError: Identifier &#x27;count&#x27; has already been declare</span><br></pre></td></tr></table></figure></li></ul></li></ul><h1 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h1><h2 id="Scopr-Chain-作用域链"><a href="#Scopr-Chain-作用域链" class="headerlink" title="[[Scopr Chain]] 作用域链"></a>[[Scopr Chain]] 作用域链</h2><p>当查找变量的时候，会先从当前上下文的变量对象中查找，如果没有找到就会从父级执行上下文的变量对象中查找，一直找到全局上下文的变量对象(全局对象)。这样由多个执行上下文的变量对象构成的链表就是作用域链。<br>根据在内部函数可以访问外部函数变量的这种机制，用链式查找决定哪些数据能被内部函数访问，这就时作用域链。</p><h1 id="JS-执行环境"><a href="#JS-执行环境" class="headerlink" title="JS 执行环境"></a>JS 执行环境</h1><p>执行环境(Execution context，EC) 或执行上下文。分为三种( 全局执行环境、函数执行环境、eval()执行环境)<br>js 为每一个执行环境关联了一个变量对象。环境中定义的所有变量和函数都保存在这个对象中。</p><h2 id="EC-的组成"><a href="#EC-的组成" class="headerlink" title="EC 的组成"></a>EC 的组成</h2><p>当 JavaScript 代码执行的时候，会进入不同的执行环境(执行上下文)，这些执行环境会构成了一个执行环境栈(执行上下文栈)(Execution context stack,ECS)<br><img src="https://segmentfault.com/img/bVbenRf?w=881&h=466" alt="执行环境"></p><h3 id="变量对象-VO-和-活动对象-AO"><a href="#变量对象-VO-和-活动对象-AO" class="headerlink" title="变量对象(VO) 和 活动对象(AO)"></a>变量对象(VO) 和 活动对象(AO)</h3><p><code>变量对象(VO)</code>: 变量对象即包含变量的对象，除了我们无法访问它外，和普通对象没有区别。变量对象存储了在<code>上下文中定义的变量</code>和<code>函数声明</code>。</p><p><code>活动对象(AO)</code>: 活动对象和变量对象是一个东西，变量对象是规范上的或者说是引擎上实现的，不可在 JavaScript 环境中访问，只有到当进入一个执行上下文中，这个执行上下文的变量对象才会被激活，activation object <code>只有被激活的变量对象，也就是活动对象上的各种属性才能被访问</code>。<br>活动对象是在进入函数执行环境时刻被创建的，它通过函数的 argument 属性初始化</p><h3 id="执行环境"><a href="#执行环境" class="headerlink" title="执行环境"></a>执行环境</h3><p>全局执行环境是最外围的执行环境，全局执行环境被认为是 window 对象，因此所有的全局变量和函数都作为 window 对象的属性和方法创建的。<br>js 的执行顺序是根据函数的调用来决定的，当一个函数被调用时，该函数环境变量对象就被压入一个环境栈中。在函数执行之后，栈将该函数的变量对象弹出，把控制权交给之前的执行环境变量对象。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var scope = &#x27;global&#x27;</span><br><span class="line">  function fn1()&#123;</span><br><span class="line">    return scope</span><br><span class="line">  &#125;</span><br><span class="line">  function fn2()&#123;</span><br><span class="line">    return scope</span><br><span class="line">  &#125;</span><br><span class="line">  fn1()</span><br><span class="line">  fn2()</span><br></pre></td></tr></table></figure><p><img src="https://segmentfault.com/img/bVbenRt?w=1042&h=436" alt></p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 作用域-作用域链 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>双向数据绑定原理&amp; MVVM</title>
      <link href="/2023/03/01/%E9%9D%A2%E8%AF%95/vue%E5%8E%9F%E7%90%86&amp;MVVM/"/>
      <url>/2023/03/01/%E9%9D%A2%E8%AF%95/vue%E5%8E%9F%E7%90%86&amp;MVVM/</url>
      
        <content type="html"><![CDATA[<h2 id="几种实现双向数据绑定的做法"><a href="#几种实现双向数据绑定的做法" class="headerlink" title="几种实现双向数据绑定的做法"></a>几种实现双向数据绑定的做法</h2><p>实现数据绑定的做法有大致有：</p><ul><li>发布者-订阅者模式<br>一般通过 sub、pub 的方式实现数据和视图的绑定监听，更新数据的方式通常做法是 vm.set(‘property’,value)</li><li>脏值检查 (angular.js)<br>是通过脏值检测的方式比对数据是否有变更，来决定是否更新视图，最简单的方式是通过 setInterval() 定时轮询检测数据变动，angular 只有在指定的事件触发时进入脏值检测，大致流程<ul><li>DOM 事件，例如用户输入文本点击按钮等</li><li>XHR 响应事件($http)</li><li>浏览器 Location 变更事件($location)</li><li>Timer 事件($timeout,$interval)</li><li>执行 $digest() 或 $apply()</li></ul></li><li>数据劫持 (vue.js)<br>vue.js 是数据劫持结合发布者-订阅者模式的方式，通过 Object.defineProperty() 来劫持各个属性的 setter，getter,在数据变动时发布消息给订阅者，触发相应的监听回调。</li></ul><h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p>要实现 mvvm 的双向绑定，就必须要实现以下几点：</p><ul><li>实现一个数据监听 Observer，能够对数据对象的所有属性进行监听，如有变动可拿到最新值并通知订阅者</li><li>实现一个指令解析器 Compile,对每一个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数。</li><li>实现一个 Watcher,作为连接 Observer 和 Compile 的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数，从而更新视图。</li></ul><p><img src="https://segmentfault.com/img/bVBQYu?w=730&h=390" alt></p><h3 id="实现-Observer"><a href="#实现-Observer" class="headerlink" title="实现 Observer"></a>实现 Observer</h3><p>利用 Object.defineProperty() 来监听属性变动，那么将需要监听的数据对象进行递归遍历，包括子属性对象的属性，都加上 setter 和 getter, 这样给这个对象的某个值赋值，就会触发 setter，那么就能监听到了数据变化</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">function observe(data) &#123;</span><br><span class="line">    if (!data || typeof data !== &#x27;object&#x27;) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    // 取出所有属性遍历</span><br><span class="line">    Object.keys(data).forEach(function(key) &#123;</span><br><span class="line">        defineReactive(data, key, data[key]);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function defineReactive(data, key, val) &#123;</span><br><span class="line">    observe(val); // 监听子属性</span><br><span class="line">    Object.defineProperty(data, key, &#123;</span><br><span class="line">        enumerable: true, // 可枚举</span><br><span class="line">        configurable: false, // 不能再define</span><br><span class="line">        get: function() &#123;</span><br><span class="line">            return val;</span><br><span class="line">        &#125;,</span><br><span class="line">        set: function(newVal) &#123;</span><br><span class="line">            console.log(&#x27;哈哈哈，监听到值变化了 &#x27;, val, &#x27; --&gt; &#x27;, newVal);</span><br><span class="line">            val = newVal;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们就可以监听每个数据的变化了，监听到变化之后就是怎么通知订阅者了，接下来我们需要实现一个消息订阅器，就是维护一个数组，用来收集订阅者，数据变动触发 notify,再调用订阅者的 update 方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">  function defineReactive(data, key, val) &#123;</span><br><span class="line">    var dep = new Dep();</span><br><span class="line">    observe(val); // 监听子属性</span><br><span class="line"></span><br><span class="line">    Object.defineProperty(data, key, &#123;</span><br><span class="line">        // ... 省略</span><br><span class="line">        set: function(newVal) &#123;</span><br><span class="line">            if (val === newVal) return;</span><br><span class="line">            console.log(&#x27;哈哈哈，监听到值变化了 &#x27;, val, &#x27; --&gt; &#x27;, newVal);</span><br><span class="line">            val = newVal;</span><br><span class="line">            dep.notify(); // 通知所有订阅者</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Dep() &#123;</span><br><span class="line">    this.subs = [];</span><br><span class="line">&#125;</span><br><span class="line">Dep.prototype = &#123;</span><br><span class="line">    addSub: function(sub) &#123;</span><br><span class="line">        this.subs.push(sub);</span><br><span class="line">    &#125;,</span><br><span class="line">    notify: function() &#123;</span><br><span class="line">        this.subs.forEach(function(sub) &#123;</span><br><span class="line">            sub.update();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>who 是订阅者？怎么往订阅器添加订阅者？<br>订阅者就是 Watcher 而且 var dep = new Dep() 是在 defineReactive 方法内部定义的，所以想通过 dep 添加订阅者，是在 getter 里面</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">  Object.defineProperty(data, key, &#123;</span><br><span class="line">    get: function() &#123;</span><br><span class="line">        // 由于需要在闭包内添加watcher，所以通过Dep定义一个全局target属性，暂存watcher, 添加完移除</span><br><span class="line">        Dep.target &amp;&amp; dep.addSub(Dep.target);</span><br><span class="line">        return val;</span><br><span class="line">    &#125;</span><br><span class="line">    // ... 省略</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// Watcher.js</span><br><span class="line">Watcher.prototype = &#123;</span><br><span class="line">    get: function(key) &#123;</span><br><span class="line">        Dep.target = this;</span><br><span class="line">        this.value = data[key];    // 这里会触发属性的getter，从而添加订阅者</span><br><span class="line">        Dep.target = null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现-Compile"><a href="#实现-Compile" class="headerlink" title="实现 Compile"></a>实现 Compile</h3><p>compile 主要做的事情是解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图。<br><img src="https://segmentfault.com/img/bVBQY3?w=625&h=259" alt></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">  function Compile(el) &#123;</span><br><span class="line">    this.$el = this.isElementNode(el) ? el : document.querySelector(el);</span><br><span class="line">    if (this.$el) &#123;</span><br><span class="line">        this.$fragment = this.node2Fragment(this.$el);</span><br><span class="line">        this.init();</span><br><span class="line">        this.$el.appendChild(this.$fragment);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Compile.prototype = &#123;</span><br><span class="line">    init: function() &#123; this.compileElement(this.$fragment); &#125;,</span><br><span class="line">    node2Fragment: function(el) &#123;</span><br><span class="line">        var fragment = document.createDocumentFragment(), child;</span><br><span class="line">        // 将原生节点拷贝到fragment</span><br><span class="line">        while (child = el.firstChild) &#123;</span><br><span class="line">            fragment.appendChild(child);</span><br><span class="line">        &#125;</span><br><span class="line">        return fragment;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;a</span><br></pre></td></tr></table></figure><h3 id="实现-Watcher"><a href="#实现-Watcher" class="headerlink" title="实现 Watcher"></a>实现 Watcher</h3><p>Watcher 订阅者作为 Observer 和 Compile 之间的通信的桥梁，主要做的事情是：</p><ul><li>在自身实例化时往属性订阅器(dep)里添加自己</li><li>自身必须有一个 updata()方法</li><li>待属性变动 dep.notice() 时，能调用自身的 update() 方法并触发 Compile 中绑定的函数。</li></ul><h3 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h3><p>View: 视图层(UI 用户界面)<br>ViewModel: 业务逻辑层(一切 js 可视为业务逻辑层)<br>Model: 数据层(存储数据及对数据的处理如增删改查)</p><ul><li>MVVM 将数据双向绑定作为核心思想，View 和 Model 之间没有联系它们通过 ViewModel 这个桥梁进行交互。</li><li>Model 和 ViewModel 之间的交互是双向的，因此 View 的变化会自动同步到 Model，而 Model 的变化也会立即反映到 View 上显示。</li><li>用户操作 View， ViewModel 感知到变化，然后通知 Model 发生相应改变；反之当 Model 发生改变，ViewModel 也能感知到变化，使 View 做出相应更新。</li><li>ViewModel 通过双向数据绑定把 View 层和 Model 层连接起来，而 View 和 Model 之间的同步完全是自动的，无需人为干涉，开发者只需关注业务逻辑，不需要手动操作 DOM。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> vue知识点，双向数据绑定原理&amp; MVVM </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>生命周期知识</title>
      <link href="/2023/03/01/%E9%9D%A2%E8%AF%95/vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9F%A5%E8%AF%86/"/>
      <url>/2023/03/01/%E9%9D%A2%E8%AF%95/vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<p>var app = new Vue({})</p><p>第一个钩子函数就是 beforeCreate，在这之前组件还没有真正的初始化。<br>在 beforeCreate 之后，Vue 对 data 对象作了 getter/setter 处理，并且将对象放在一个 Observe 里面以便监控对象。还使用 initEvents 绑定事件。</p><p><code>此时不能访问data的属性以及绑定的事件</code></p><p>组件初始化完成后，遇到 created。在这个阶段我们可以访问到了 data 的属性以及绑定的事件。</p><p>通过 created 阶段后组件的生命周期到了 beforemount,在这个阶段 DOM 结构还没有生成。但是已经创建了 el，组件挂载的根节点。在 beforemount 执行之后开始渲染 DOM。执行_render 方法，_mount 方法，然后会有 new 出一个 watcher 对象，形成 VNode 节点，然后更新 DOM。</p><p>渲染完毕后组件就会到下一个声明周期 mounted，一般的异步请求都会写在这里。这个阶段 DOM 已经渲染出来了。</p><p>Q: 什么是生命周期</p><p>A: Vue 实例从创建到销毁的过程，就是生命周期。也就是从开始创建、初始化数据、编译模板、挂载 DOM-&gt;渲染、更新-&gt;渲染、卸载等一系列过程。</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> vue知识点 </category>
          
          <category> 生命周期知识 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>路由模式原理</title>
      <link href="/2023/03/01/%E9%9D%A2%E8%AF%95/vue%E8%B7%AF%E7%94%B1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2023/03/01/%E9%9D%A2%E8%AF%95/vue%E8%B7%AF%E7%94%B1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="路由的实现"><a href="#路由的实现" class="headerlink" title="路由的实现"></a>路由的实现</h2><p>前端路由的实现：本质上是检测 url 的变化，截获 url 地址，然后解析来匹配路由规则。但是 url 每次变化都会刷新页面，页面刷新 JavaScript 怎么检测和截获 url?2014 年之前，大家是通过 hash 来实现路由 url hash 类似于 <code>https://ssss.com/a/#file</code> <code>#</code> 后面 hash 值的变化，并不会导致浏览器向服务器发出请求，也就不会刷新页面，而 hash 值的变化都会触发 <code>hashchange</code>事件，通过这个事件我们就可以知道 hash 值发生了那些改变。</p><p>14 年后，HTML5 标准发布，多了两个 API <code>pushState 和 replaceState</code>,通过两个 API 可以改变 url 地址且不会发送请求。还有 <code>onpopstate</code>事件。用了 HTMl5 的实现，单页路由的 url 就不会多出一个 <code>#</code> 变得更加美观。但没有 # 所以当用户刷新页面之类的操作时，浏览器还是会给服务器发送请求，需要后台配置支持因为是单页面应用，如果后台没有正确的配置，当用户在浏览器直接访问 <code>htpp://oursit.com/user/id</code>就会返回 404</p><p>所以要在服务端增加一个覆盖所有情况的候选资源：如果 url 匹配不到任何静态资源，则应该返回一个 <code>index.html</code> ,这个 页面就是你 app 依赖的页面。</p><h2 id="hash-模式"><a href="#hash-模式" class="headerlink" title="hash 模式"></a>hash 模式</h2><p>hash 模式的工作原理是 hashchange 事件，可以在 window 监听 hash 的变化。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">window.onhashchange = function(event)&#123;</span><br><span class="line">  console.log(event)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有两个属性 newURL 和 oldURL。根据 hash 值的变化加载对应的动态页面数据。</p><h2 id="history-模式"><a href="#history-模式" class="headerlink" title="history 模式"></a>history 模式</h2><p>HTML5 新增的 API</p><ul><li>history.pushState():往历史记录堆栈顶部添加一条记录</li><li>history.replaceState():更改当前的历史记录。</li><li>history.state: 用于存储以上方法的 data 数据</li><li>window.onpopstate : 响应 pushState 或 replaceState 的调用</li></ul><p>当使用 history 模式时，还需要后台配置支持，因为我们的应用是单页面应用，如果后台没有正确的配置，当用户在浏览器直接访问 <code>http://www.xxxxxx/detail</code> 就会返回 404 。所以需要在服务器增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html。服务器就不在返回 404 错误页面，因为会对所有路径返回 index.html 文件。为了避免这种情况，应该在 Vue 应用里面覆盖所有的路由情况，然后给出一个 404 页面。</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> vue知识点，路由模式原理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SPA单页面</title>
      <link href="/2023/03/01/%E9%9D%A2%E8%AF%95/SPA/"/>
      <url>/2023/03/01/%E9%9D%A2%E8%AF%95/SPA/</url>
      
        <content type="html"><![CDATA[<h3 id="SPA-单页面，优缺点是"><a href="#SPA-单页面，优缺点是" class="headerlink" title="SPA 单页面，优缺点是"></a>SPA 单页面，优缺点是</h3><p>SPA ( single-page-application ) 仅在页面初始化时加载相应的 HTML、JavaScript 和 CSS。页面加载完成，SPA 不会因为用户的操作而进行页面的重新加载或者跳转;取而代之的是利用路由机制实现 HTML 内容的变换，UI 与用户的交互，避免页面的重新加载。</p><p>单页面</p><p><code>单页面应用，就是只有一个页面的应用，页面的刷新和内部子页面的跳转完全由js来控制。</code></p><ul><li><p>单页面应用的特点</p><ul><li>本地路由，由 js 定义路由、根据路由渲染页面、控制页面的跳转。</li><li>所有的文件只会加载一次，最大限度重用文件，并且极大提升加载速度。</li><li>按需加载<br>根据业务逻辑拆分代码为独立的异步 js 文件(不存在于 html 的 Script 中)，在触发对应逻辑(如路由跳转，组件使用等)时通过 js 代码进行下载并使用。</li></ul></li><li><p>优点：</p><ul><li>有良好的交互体验<br>能提升页面切换体验，用户在访问应用页面是不会频繁的去切换浏览页面，从而避免了页面的重新加载。</li><li>前后端分离开发<br>前端进行交互逻辑，后端负责数据处理。</li><li>减轻服务器压力<br>服务器只用出数据就可以，不用管展示逻辑和页面合成。</li><li>共有一套后端代码<br>不用修改后端程序代码就可以同时用于多种客户端。</li></ul></li><li><p>缺点：</p><ul><li>初次加载很耗时多<br>为实现单页面 Web 应用功能及显示效果，需要在加载页面的时候将 JavaScript、CSS 统一加载，部分页面可以在需要的时候加载</li><li>SEO 难度较高<br>由于所有的内容都会在一个页面中动态替换显示，</li><li>前进后退路由管理<br>由于单页面应用在一个页面显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理。</li></ul></li><li><p>性能优化</p><ul><li>加载优化<br>通常一开始就会加载所必需的的代码(JavaScript HTML CSS),首屏加载太慢会按需加载。<br><code>按需加载</code>就是按照当前呈现的不同页面加载不同的文件，<br>当首屏加载完毕后，设备&amp;网络处于空闲状态，可以对其他路由组件进行预加载。<br>根据路由拆分减少初始化加载体积，利用异步加载方式，在路由注册时提供拉取组件的方法，仅在需要进入对应路由时，组件才会被加载进来。</li><li>SEO 优化</li></ul></li><li><p>体验优化</p><ul><li>构建骨架图。</li><li>页面切换<br>页面切换前：在确保组件数据加载完毕前，可保证页面可交互，减少用户阻塞感。<br>切换时增加动画</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> vue知识点，SPA单页面 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/03/01/%E6%B8%B2%E6%9F%93%E6%B5%81%E6%B0%B4%E7%BA%BF/"/>
      <url>/2023/03/01/%E6%B8%B2%E6%9F%93%E6%B5%81%E6%B0%B4%E7%BA%BF/</url>
      
        <content type="html"><![CDATA[<h2 id="渲染流水线"><a href="#渲染流水线" class="headerlink" title="渲染流水线"></a>渲染流水线</h2><p><img src="https://raw.githubusercontent.com/wqxc/Picture/main/chrome/image-20210519171828121.png" alt></p><h3 id="加载主页面"><a href="#加载主页面" class="headerlink" title="加载主页面"></a>加载主页面</h3><p>加载主页面，调用网络进程，下载HTML文件。</p><p>下载完成之后，渲染进程解析HTML，而后构建DOM。</p><p>在解析HTML的时候，浏览器会预先下载HTML文件内需要的JS资源和CSS资源。</p><p>这里JS会阻塞DOM的解析，必然也会影响渲染吗，</p><p>另外的，JS的执行，需要CSSOM构建完毕之后才能执行，</p><p>所以CSS会阻塞JS的执行，JS会阻塞DOM的解析，所以，CSS也间接的会阻塞DOM的解析，这里的阻塞不是必然的，是一种可能性。</p><p>CSS会阻塞浏览器的渲染。</p><p>所以，CSS放在最前边，JS放在最后边。</p><h3 id="构建DOM"><a href="#构建DOM" class="headerlink" title="构建DOM"></a>构建DOM</h3><p>HTML文件浏览器是不认识的，需要转换为浏览器能够处理的结构 ———— <strong>DOM</strong></p><h3 id="样式计算"><a href="#样式计算" class="headerlink" title="样式计算"></a>样式计算</h3><p>样式计算是在CSS文件获取完成之后进行的，主要作用是计算出每一个DOM节点中，每一个元素的样式，这个过程分为下图所示的三样：</p><p><img src="https://raw.githubusercontent.com/wqxc/Picture/main/chrome/image-20210519171905175.png" alt="样式计算"></p><h5 id="第一，将CSS文件转换为浏览器能识别的形式—styleSheets"><a href="#第一，将CSS文件转换为浏览器能识别的形式—styleSheets" class="headerlink" title="第一，将CSS文件转换为浏览器能识别的形式—styleSheets"></a>第一，将CSS文件转换为浏览器能识别的形式—styleSheets</h5><p>CSS样式来源主要有三种：1、<style> 标签内的CSS。 2、link标签引入的。3、内嵌入HTML标签的CSS</p><p>CSS文件，和HTML文件一样，浏览器本身是理解不了的，需要将其转换为浏览器可以理解的结构—styleSheets。 styleSheets 也叫做 CSSOM</p><h5 id="第二，转换样式表中的属性值，使其标准化"><a href="#第二，转换样式表中的属性值，使其标准化" class="headerlink" title="第二，转换样式表中的属性值，使其标准化"></a>第二，转换样式表中的属性值，使其标准化</h5><p>比如，CSS中又很多 2rem,blue,bold 值。</p><p>就需要将其标准化为一个值，比如 2rem 就是  32px，blue 被解析为rgb, bold被解析为700.</p><h5 id="第三，计算出DOM树中每个节点的具体样式"><a href="#第三，计算出DOM树中每个节点的具体样式" class="headerlink" title="第三，计算出DOM树中每个节点的具体样式"></a>第三，计算出DOM树中每个节点的具体样式</h5><p>这里涉及CSS的继承规则和层叠规则。</p><p>首先是CSS继承，CSS继承就是每个DOM节点都包含有父节点的样式。比如，html设定了font-size:20px.</p><p>其他的文本，没有设定 font-size 就会默认继承 html的字体。</p><p>层叠规则主要是根据CSS权重来处理。</p><p>样式计算阶段的目的是为了计算出DOM节点中，每个元素的具体样式，根据CSS的继承和层叠两个规则。</p><h3 id="布局阶段"><a href="#布局阶段" class="headerlink" title="布局阶段"></a>布局阶段</h3><p>到了现在，我们有了DOM树和CSSOM树，有了元素，有了样式，唯一缺少的是DOM元素的几何信息，接下来要做的就是计算出DOM树中 <strong>可见元素</strong> 的位置信息。</p><p>布局阶段，主要完成两件是 <strong>创建布局树</strong> 和 <strong>布局计算</strong></p><h5 id="创建布局树"><a href="#创建布局树" class="headerlink" title="创建布局树"></a>创建布局树</h5><p>DOM树种包含了很多不可见的元素，比如head标签，display：none 属性的元素，所以还要额外的构建一棵可见元素的布局树。</p><p>核心是遍历DOM树，可见的就放在布局树上，不可见的就放弃。</p><h5 id="布局计算"><a href="#布局计算" class="headerlink" title="布局计算"></a>布局计算</h5><p>计算布局树的坐标位置，这个过程很复杂。</p><p>计算完成之后，每一个元素的几何坐标信息就存储在布局树中。</p><p>这时候，布局树就包含了布局的多数信息。</p><h3 id="分层"><a href="#分层" class="headerlink" title="分层"></a>分层</h3><p>布局阶段，计算了元素的位置信息，按道理来说，有了元素，有了元素的位置信息，已经可以绘制页面了，但是，直接进行绘制的话，会有很大的性能问题，这里，浏览器做了另外的操作  ————  <strong>分层</strong></p><p>为什么要分层？</p><p>页面上会有很多的效果，比如 3D变换，页面的滚动，横向的元素运动等。</p><p>如果所有的元素，在一个层面内，元素的变化必然引整个页面的重新布局计算。</p><p>而分层就可以解决这个问题，将这些变换的元素单独的分为一层，一些特殊的效果在这些层上去做，将影响降为最小。</p><p>最终，将多个分层合并在一起，最终合成一个页面，展示出来。</p><p>分层阶段，渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的———— <strong>图层树</strong></p><h5 id="如何成为一层"><a href="#如何成为一层" class="headerlink" title="如何成为一层"></a>如何成为一层</h5><p>第一：拥有层叠上下文属性的元素会被单独提升为一层</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">position</span>: absolute|releative  并且 z-index值不为auto</span><br><span class="line">flex 容器的子元素  z-index 不为auto</span><br><span class="line">grid 容器的子元素，z-index不为auto</span><br><span class="line">opacity 属性值小于<span class="number">1</span> </span><br><span class="line">transform/filter 等属性值不为none</span><br><span class="line"></span><br><span class="line">如上，拥有这些属性的元素被称之为拥有层叠上下文属性</span><br></pre></td></tr></table></figure><p>第二：需要裁剪的地方会被创建为图层,举个例子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">    div &#123;</span><br><span class="line">        <span class="attr">width</span>: <span class="number">200</span>;</span><br><span class="line">        <span class="attr">height</span>: <span class="number">200</span>;</span><br><span class="line">        <span class="attr">overflow</span>: auto;</span><br><span class="line">        <span class="attr">background</span>: gray;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;p&gt; 所以元素有了层叠上下文的属性或者需要被剪裁，那么就会被提升成为单独一层，你可以参看下</span><br><span class="line">        &lt;p&gt; 从上图我们可以看到，document 层上有 A 和 B 层，而 B 层之上又有两个图层。这些图层组</span><br><span class="line">        &lt;p&gt; 图层树是基于布局树来创建的，为了找出哪些元素需要在哪些层中，渲染引擎会遍历布局树来创</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><p>如上所示，div宽高都是200，超出之后浏览器会自动滚动。出现这种剪裁情况的时候，渲染引擎会为文字部分单独创建一个层，出现滚动的话，滚动条会被提升为单独的层。</p><p><img src="https://raw.githubusercontent.com/wqxc/Picture/main/chrome/image-20210520114909460.png" alt="分层"></p><p>如上图文字被单独提升为一层，有滚动的情况下，滚动条也会被单独提升为一层。</p><p>到这里，分层完成，分层树构建完成。接下来就是绘制</p><h3 id="图层绘制"><a href="#图层绘制" class="headerlink" title="图层绘制"></a>图层绘制</h3><p>渲染引擎会把一个图层的绘制拆分成很多的小的 <strong>绘制指令</strong>，然后再把这些指令按照顺序组成一个待绘制列表。</p><p><img src="https://raw.githubusercontent.com/wqxc/Picture/main/chrome/image-20210520120237554.png" alt="绘制列表"></p><p>图层绘制阶段，输出的内容就是这些待绘制的列表。</p><h3 id="栅格化"><a href="#栅格化" class="headerlink" title="栅格化"></a>栅格化</h3><p>绘制列表记录的是绘制顺序，和绘制指令的列表，真正的绘制操作是由渲染引擎中的<strong>合成线程</strong>来完成的。</p><p>渲染引擎可以认为是一个进程，从加载页面到计算样式再到布局阶段再到分层都是运行在主线程上的。</p><p><img src="https://raw.githubusercontent.com/wqxc/Picture/main/chrome/image-20210520142913259.png" alt="渲染进程"></p><p>如图所示，当图层的绘制列表准备好之后，主线程会把改绘制列表  <strong>提交（commit）</strong>给合成线程.</p><h3 id="光栅化"><a href="#光栅化" class="headerlink" title="光栅化"></a>光栅化</h3><p>合成线程，首先是要注意一个概念 ———— <strong>视口</strong></p><h5 id="视口"><a href="#视口" class="headerlink" title="视口"></a>视口</h5><p>视口就是用户能看到的一部分，一个页面可能很大，大到超出当前的屏幕，有时候需要滚动很久才能到底部，用户能看到的就是屏幕那么大的空间。</p><p>如果一个页面很大，完全绘制的话是没有意义的，毕竟用户都看不到，性能开销也很大。</p><h5 id="图块"><a href="#图块" class="headerlink" title="图块"></a>图块</h5><p>图块是栅格化执行的最小单位。</p><p>合成线程会将图层划分为图块，一般这些图块大小都是256x256 或者是 512x512</p><p><img src="https://raw.githubusercontent.com/wqxc/Picture/main/chrome/image-20210520145517614.png" alt="分块"></p><p>如图，每一个小块儿就是图块，黑色框就是视口，或者是叫做屏幕，当前需要展示的图块就是 红线画的那些。</p><p>视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的，栅格化是指将图块转换为位图。</p><p>渲染进程维护了一个栅格化线程池，所有的图块栅格化都是在线程池内执行的，如下：</p><p><img src="https://raw.githubusercontent.com/wqxc/Picture/main/chrome/image-20210520151012247.png" alt="渲染进程"></p><p>记得一点，栅格化线程将图块转换为位图。一般这个过程会有GPU的参与，用来快速的栅格化，GPU栅格化的位图都保存在GPU中。</p><p>GPU是运行在GPU进程中的，这里使用了GPU来快速栅格化，就涉及到跨进程操作了。</p><p>操作的流程如下所示：</p><p><img src="https://raw.githubusercontent.com/wqxc/Picture/main/chrome/image-20210520152755253.png" alt="加GPU进程"></p><p>这里虽然也叫做栅格化，但是和前边我们说额栅格化不是一回事，比较常见的说法这里的栅格化也可以叫做光栅化。</p><h5 id="位图"><a href="#位图" class="headerlink" title="位图"></a>位图</h5><p>位图也叫做点阵图，像素图，光栅图等。</p><p>由被称作像素的单个点组成的，这些点可以进行不同的排列组合，比如使用RGB编码，用红绿蓝三原色的光学强度来表示一种颜色</p><p>比如 RGB(0,0,0) 表示一个黑色的块儿，不同的RGB拼接在一起就可以形成一幅画。</p><p>最常见的，比如 色盲图谱，一个个的点会组成不同的图像或者是数字，这些也可以称之为位图。</p><h3 id="合成"><a href="#合成" class="headerlink" title="合成"></a>合成</h3><p>光栅化的最后就生成位图，每一个图层对应一个位图或者是一张图片，最后这些图片会根据层叠的顺序合并为一张图片。</p><p>最终生成的图片发送到后缓冲区。</p><p>简单的来说，一旦所有的图块都被光栅化了，合成线程就会生成一个绘制图块的命令，该命令会被提交给浏览器进程。</p><p>浏览器进程里的有专门的组件来接收这个命令，而后负责将页面内容绘制到内存中。</p><h3 id="显示"><a href="#显示" class="headerlink" title="显示"></a>显示</h3><p>页面的显示依靠的是显示器，显示器显示图像的核心是显卡，显示器上的页面（其实是图片）来自于显卡的一个叫做  <strong>前缓冲区</strong>  的地方。</p><p>显示器要做的事情很简单，就是每秒钟读取60张图片，并将读取的图片显示在浏览器上。</p><h5 id="显卡的职责"><a href="#显卡的职责" class="headerlink" title="显卡的职责"></a>显卡的职责</h5><p>显卡的职责就是不断的合成新的图像，并保存在 <strong>后缓冲区</strong> ，一旦写入完成，系统就会让前后缓冲区对调，保证显示器总是读取最新的图像。一般而言，显卡的更新频率和显示器的刷新频率是一致的，但是，有些时候，在一些复杂的场景中，显卡处理图片会很慢，就会造成卡顿。</p><h5 id="帧和帧率"><a href="#帧和帧率" class="headerlink" title="帧和帧率"></a>帧和帧率</h5><p>渲染流水线生成的一张图片，被称之为一帧，每秒钟渲染流水线制造了多少张图片，被称之为帧率。</p><p>如果渲染引擎生成某些帧的时间过长了，用户就会觉得卡顿。</p><h5 id="如何生成一帧图像"><a href="#如何生成一帧图像" class="headerlink" title="如何生成一帧图像"></a>如何生成一帧图像</h5><p>有三种方式来生成一帧图像</p><p>第一：重排</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">首先说说第一种，在首次加载一个网站的时候，这三种方式都会被使用。</span><br><span class="line"></span><br><span class="line">重排很简单，就是修改了元素的几何信息，比如朝<span class="variable constant_">DOM</span>里添加一个元素，或者是删除一个元素等，都会触发重排，继而生成一帧图像，这个过程需要 重新构建布局树，而后的渲染阶段都要重新来一遍，这个过程是很耗性能的</span><br></pre></td></tr></table></figure><p>第二： 重绘</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">重绘不会影响布局阶段，操作效率要比重排要高一些，但是，依旧需要计算绘制信息，触发绘制操作之后的所有操作。 包括 绘制 分块，光栅化，合成，显示等</span><br></pre></td></tr></table></figure><p>第三：合成</p><p>在合成线程中完成的任务都不会涉及图层内容的改变，一般都是图层的运动操作，比如滚动，动画，旋转等。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">相对而言，合成的效率就明显高了很多，合成操作不需要触发布局和绘制操作，而且合成是在合成线程上运行的，不会阻塞主线程，如果合成还采用了<span class="variable constant_">GPU</span>的话，效率就更高了。</span><br><span class="line">.<span class="property">box</span> &#123;</span><br><span class="line"> will-<span class="attr">change</span>: transform, opacity;</span><br><span class="line"> &#125;</span><br><span class="line">如上，这是告诉渲染进程这个元素要做一些比较秀的操作，transform 或者是 opacity，渲染引擎将该元素单独实现为一层，等变换发生的时候，渲染引擎会通过合成线程直接去处理变换，这些变换并没有涉及到主线程，就大大的提升了渲染的效率。</span><br><span class="line"></span><br><span class="line">但是，虽然will-change 好用，但是用的多了也会影响效率的。</span><br></pre></td></tr></table></figure><p>最后来一张总结的图</p><p><img src="https://raw.githubusercontent.com/wqxc/Picture/main/chrome/image-20210520181235864.png" alt="全部的渲染"></p></style></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>登录认证知识</title>
      <link href="/2023/03/01/%E7%99%BB%E5%BD%95%E8%AE%A4%E8%AF%81/"/>
      <url>/2023/03/01/%E7%99%BB%E5%BD%95%E8%AE%A4%E8%AF%81/</url>
      
        <content type="html"><![CDATA[<h2 id="基于-Cookie-Session-的认证方案"><a href="#基于-Cookie-Session-的认证方案" class="headerlink" title="基于 Cookie/Session 的认证方案"></a>基于 Cookie/Session 的认证方案</h2><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><p>  由于HTTP 是一种无状态的协议。服务器单从网络连接无法知道客户身份。然后就给客户端们颁发一个通行证，每人一个，无论谁访问都必须携带自己通行证。这样服务器就能从通行证上确认客户身份。<br>    Cookie 实际上是一小段的文本信息。客户端请求服务器，如果服务器需要记录该用户状态，就使用 response 向客户浏览器颁发一个 Cookie。客户端浏览器会把 Cookie 保存起来。当浏览器再请求该网站时，浏览器把请求的网址连同该Cookie 一同提交给服务器。服务器检查该 Cookie,以此来辨认用户状态。</p><h4 id="Cookie的不可跨域名性"><a href="#Cookie的不可跨域名性" class="headerlink" title="Cookie的不可跨域名性"></a>Cookie的不可跨域名性</h4><p>  Cookie 具有不可跨域名性，根据Cookie的规范，浏览器访问 Google只会携带 Goole的 Cookie,而不会携带 Baidu 的Cookie</p><h3 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h3><p>  Session 是另一种记录客户端状态的机制，不同的是 Cookie 保存在客户端浏览器中，而Session 保存在服务器上。客户端访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上。客户端再次访问的时候只需要从该 Session 中查找该客户的状态就可以了。</p><p><code>Cookie 机制是通过检查客户身上的  通行证 来确定客户身份，那么 Session 机制就是通过检查服务器上的  客户明细表 来确认客户身份。</code></p><p>  Session 服务器给每个客户端分配不同的 <code>身份标识</code>，然后 <code>客户端</code> 每次向服务器发送请求的时候，都带上这个<code>身份标识</code>，服务器就知道这个请求是来自于谁。</p><ul><li>优缺点<br>服务器用 Session 把用户信息临时保存在了服务器上，用户离开网站后session 会被销毁，这种用户信息存储方式相对 cookie来说更安全。<br>缺陷：如果服务器做了负载均衡，那么下一个操作请求到了另一台服务器的时候 session 就会丢失。<br>Session 的使用比Cookie 方便，但是过多的 Session 存储在服务器内存中，会对服务器造成压力。</li></ul><h4 id="Cookie-与-Session-的区别和联系"><a href="#Cookie-与-Session-的区别和联系" class="headerlink" title="Cookie 与 Session 的区别和联系"></a>Cookie 与 Session 的区别和联系</h4><ul><li>cookie 数据保存在客户端的浏览器上，session 数据放在服务器上；</li><li>cookie 不是很安全，别人可以分析存放在本地的 Cookie 并进行Cookie欺骗，考虑安全应当使用 session.</li><li>session 会在一定时间内保存在服务器上。当访问增多，会比较占用服务器的性能。考虑到减轻服务器性能方面，应当使用Cookie</li><li>Cookie 存储大小为 3K，存放在客户端的Cookie 不能超过 3K.</li></ul><p>Cookie 和 Session 的方案虽然分别属于客户端和服务端，但是服务端的 session 的实现对客户端的 Cookie 的依赖关系的，服务端执行 session机制时候会生成session的id，这个id 值会发送给客户端，客户端每次请求都会把这个 id 值放到 http 请求的头部发送给服务端，而这个 id 值在客户端会保存下来，保存的容器就是 Cookie 。因此当我们完全禁掉浏览器 Cookie的时候，服务端的session 也不能正常使用。</p><h2 id="基于-Token-的认证方式"><a href="#基于-Token-的认证方式" class="headerlink" title="基于 Token 的认证方式"></a>基于 Token 的认证方式</h2><p> 原理：基于Token的身份验证是<code>无状态</code> ，我们不将信息存储在服务器中。</p><h3 id="基于Token的身份验证的过程如下："><a href="#基于Token的身份验证的过程如下：" class="headerlink" title="基于Token的身份验证的过程如下："></a>基于Token的身份验证的过程如下：</h3><ul><li>用户通过用户名和密码发送请求</li><li>服务器端程序验证。</li><li>服务器端程序返回一个 带签名的 token 给客户端。</li><li>客户端存储token，并且每次访问 API 都携带 Token 到服务器端</li><li>服务端验证 token，校验成功则返回请求数据，校验失败则返回错误码。<br><img src="https://images2018.cnblogs.com/blog/1350514/201805/1350514-20180504123850641-479661599.png" alt="token登录流程"></li></ul><h4 id="Token-的优势"><a href="#Token-的优势" class="headerlink" title="Token 的优势"></a>Token 的优势</h4><ul><li>无状态、可扩展<br>客户端存储的Token是无状态的，并且是能够被扩展。</li><li>安全性<br>请求中发送 token 而不再是发送 cookie 能够防止 CSRF(跨战情求伪造)。即使在客户端使用 Cookie 存储 token , cookie也仅仅是一个存储机制而不是拥有认证。不将信息存储在Session 中，让我们减少了对 Session 操作。<br>  token 是有时效性的，一段时间之后用户需要重新验证。</li><li>可扩展性<br>Token 能够创建与其他程序共享权限的程序。</li><li>多平台跨域</li></ul>]]></content>
      
      
      <categories>
          
          <category> 登录认证知识 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>浏览器缓存</title>
      <link href="/2023/03/01/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/"/>
      <url>/2023/03/01/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<p>浏览器对于请求资源，拥有一些成熟的缓存策略，按照发生的时间顺序分别为 <code>存储策略、过期策略、协商策略</code>。其中 <code>存储策略</code> 在收到响应后应用，<code>过期策略、协商策略</code> 在发送请求前应用</p><p><img src="https://lc-gold-cdn.xitu.io/54a021d766b64e993d39.png" alt="浏览器缓存机制剖析图"></p><h3 id="http-header-中与缓存有关的-key"><a href="#http-header-中与缓存有关的-key" class="headerlink" title="http header 中与缓存有关的 key"></a>http header 中与缓存有关的 key</h3><table><thead><tr><th>key</th><th>描述</th><th>策略类型</th></tr></thead><tbody><tr><td>Cache-Control</td><td>指定缓存机制，覆盖其它设置</td><td>存储策略</td></tr><tr><td>Pragma</td><td>http1.0 字段，指定缓存机制</td><td>存储策略</td></tr><tr><td>Expires</td><td>http1.0 字段，指定缓存的过期时间</td><td>过期策略</td></tr><tr><td>Last-Modified</td><td>资源最后一次的修改时间</td><td>协商策略</td></tr><tr><td>ETag</td><td>唯一标识请求资源的字符串</td><td>协商策略</td></tr></tbody></table><h3 id="缓存协商策略用于重新验证缓存资源是否有效"><a href="#缓存协商策略用于重新验证缓存资源是否有效" class="headerlink" title="缓存协商策略用于重新验证缓存资源是否有效"></a>缓存协商策略用于重新验证缓存资源是否有效</h3><table><thead><tr><th>key</th><th>描述</th></tr></thead><tbody><tr><td>if-Modified-Since</td><td>缓存校验字段，值为资源最后一次修改的时间，即上次收到的 Last-Modified 值</td></tr><tr><td>if-Unmodifed-Since</td><td>与上面相同，处理方式与上面相反</td></tr><tr><td>if-Match</td><td>缓存校验字段，值为唯一标识请求资源的字符串，即上次的 ETag 值</td></tr><tr><td>if-None-Match</td><td>同上，处理方式与之相反</td></tr></tbody></table><h3 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h3><p>浏览器缓存里，<code>Cache-Control</code> 是金字塔顶尖的规则，它藐视一切其他设置，只要其他设置与其抵触，一律覆盖，它还是一个复合规则，包含多种值，横跨 <code>存储策略、过期策略</code> 两种,同时在请求头和响应头都可设置。<br>语法 <code>Cache-Control:cache-directive</code></p><table><thead><tr><th>Cache-directive</th><th>描述</th><th>存储策略</th><th>过期策略</th><th>请求字段</th><th>响应字段</th></tr></thead><tbody><tr><td>public</td><td>资源将被客户端和代理服务器缓存</td><td>是</td><td>否</td><td>否</td><td>是</td></tr><tr><td>private</td><td>资源仅被客户端缓存，代理服务器不缓存</td><td>是</td><td>否</td><td>否</td><td>是</td></tr><tr><td>no-store</td><td>请求和响应都不缓存</td><td>是</td><td>否</td><td>是</td><td>是</td></tr><tr><td>no-cache</td><td>相当于 max-age:0,must-revalidate 即资源被缓存，但是缓存立刻过期，同时下次访问时强制验证资源有效性。</td><td>是</td><td>是</td><td>是</td><td>是</td></tr><tr><td>max-age</td><td>缓存资源，但是指定时间(单位为秒)后缓存过期</td><td>是</td><td>是</td><td>是</td><td>是</td></tr></tbody></table><h3 id="Pragma"><a href="#Pragma" class="headerlink" title="Pragma"></a>Pragma</h3><p>http1.0 字段，通常设置为 Pragma:no-cache,作用同 Cache-Control:no-cache,当一个 no-cache 请求发送给一个不遵循 HTTP/1.1 的服务器时，客户端应该包含 pragma 指令。</p><h3 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h3><p>即将到期时间，以服务器时间为参考系，其优先级比 Cache-Control:max-age 低，两者同时出现在响应头时， Expires 将被后者覆盖，如果 Expires, Cache-Control:max-age 或 Cache-Control:s-maxage 都没有在响应头中出现，并且也没有其它缓存的设置，那么浏览器默认会采用一个启发式算法，通常会取响应头的 Date_value -Last-Modified_value 值的 10%作为缓存时间。</p><h3 id="ETag"><a href="#ETag" class="headerlink" title="ETag"></a>ETag</h3><p>实体标签，服务器资源的唯一标识符，浏览器可以根据 ETag 值缓存数据，节省宽带，如果资源已经改变，etag 可以帮助防止同步更新资源的相互覆盖，ETag 优先级比 Last-Modified 高。</p><h3 id="If-Match"><a href="#If-Match" class="headerlink" title="If-Match"></a>If-Match</h3><p>语法：if-Match:ETag_value 或者 if-match:ETag_value,ETag_value<br>缓存校验字段，其值为上次收到的一个或多个 etag 值，常用于判断条件是否满足</p><h3 id="Last-Modified"><a href="#Last-Modified" class="headerlink" title="Last-Modified"></a>Last-Modified</h3><p>用于标记请求资源的最后一次修改时间，格式为 GMT(格林尼治标准时间)。优先级比 ETag 低，且只能精确到秒，因此不适合短时间内频繁的改动的资源，服务器端的静态资源，通常需要编译打包，可能出现资源内容没有改变，而 Last-Modified 却改变的情况。</p><h3 id="If-Modified-Since"><a href="#If-Modified-Since" class="headerlink" title="If-Modified-Since"></a>If-Modified-Since</h3><p>缓存校验字段，其值为上次响应头的 Last-Modified 值，若与请求资源当前的 Last-Modified 值相同，那么将返回 304 状态码的响应，反之将返回 200 状态码响应。</p><h3 id="If-Unmodified-Since"><a href="#If-Unmodified-Since" class="headerlink" title="If-Unmodified-Since"></a>If-Unmodified-Since</h3><p>缓存校验字段，表示资源未修改则正常执行更新，否则返回 412 状态码的响应。</p><h3 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h3><p>一旦资源命中强缓存，浏览器便不会向服务器发送请求，而是直接读取缓存。对于常规请求，只要存在该资源的缓存，且 Cache-Control:max-age 或者 expires 没有过期，那么就命中强缓存。</p><h3 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h3><p>协商缓存的响应结果，不仅验证了资源的有效性，同时还更新了浏览器缓存。<br>缓存过期后，继续请求该资源。有两种做法。</p><ul><li>根据上次响应中的 ETag_value,自动往 request header 中添加 If-None-Match 字段的值与资源的 ETag 值进行比较，若相同，则命中协商缓存，返回 304 响应。</li><li>根据上次响应中的 Last-Modified_vlaue,自动往 request header 中添加 If-Modified-Since 字段，服务器收到请求后，拿 If-Modified-Since 字段的值与资源的 Last-Modified 值进行比较，若相同，则命中协商缓存，返回 304 响应。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>HTTP 知识</title>
      <link href="/2023/03/01/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E6%B6%89%E5%8F%8A%E7%9A%84%E7%9F%A5%E8%AF%86/http/"/>
      <url>/2023/03/01/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E6%B6%89%E5%8F%8A%E7%9A%84%E7%9F%A5%E8%AF%86/http/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是-HTTP"><a href="#什么是-HTTP" class="headerlink" title="什么是 HTTP"></a>什么是 HTTP</h2><p>超文本传输协议，是一个基于请求与响应，无状态的，应用层的协议，常基于 TCP/IP 协议传输数据，互联网上应用最为广泛的一种网络协议，所有的 WWWW 文件都必须遵守这个标准。</p><h2 id="HTTP-的基本优化"><a href="#HTTP-的基本优化" class="headerlink" title="HTTP 的基本优化"></a>HTTP 的基本优化</h2><p>影响一个　HTTP网络请求的因素主要有两个带宽和延迟<br>　＿带宽＿：当我们停留在拨号上网的阶段，带宽可能会成为一个比较严重影响请求的问题。<br>　＿延迟＿：<br>    - 浏览器阻塞：浏览器对于同一个域名，同时只能有4 个连接，超过浏览器最大数限制，后续请求就会被阻塞。<br>    - DNS 查询：浏览器需要知道目标服务器的IP 才能建立连接。将域名解析为IP。通常可以利用DNS缓存结果来达到减少查询的时间的目的。<br>    - 建立链接：HTTP 是基于TCP 协议的，浏览器最快也要在第三次握手时才能捎带 HTTP 请求报文，达到真正的建立连接。但是这些连接无法复用会导致每次请求都经历三次握手和慢启动。三次握手在高延迟的场景下影响比较明显，慢启动则对文件类请求影响较大。</p><h2 id="HTTP-1-0-和-HTTP-1-1-的区别"><a href="#HTTP-1-0-和-HTTP-1-1-的区别" class="headerlink" title="HTTP 1.0  和 HTTP 1.1 的区别"></a>HTTP 1.0  和 HTTP 1.1 的区别</h2><p>http 1.1 是当前使用最为广泛的 HTTP 协议。主要区别是：<br>    - 缓存处理：在HTTP 1.0 中主要使用header 里的 if-Modified-Since,Expires 来作为缓存判断的标准。http 1.1 则引入更多的缓存控制策略 例如：Entity tag if-Unmodified-Since,if-Match,if-None-Match等更多可供选择的缓存头来控制缓存策略。<br>    - 带宽优化及网络连接的使用，http 1.1 在请求头引入 rang 头域，它允许只请求资源的某个部分，方便开发者自由的选择以便于充分利用带宽和连接。<br>    - 错误通知的管理，在 http 1.1 中新增了24个错误状态响应码。<br>    - Host头处理：在HTTP 1.0 中认为每台服务器都绑定一个唯一的ip地址，因此，请求消息中的 URL 并没有传递主机名。因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）<br>    - 长连接：HTTP1.1支持长连接 和请求的流水线处理，在一个TCP连接上可以传送多个 HTTP 请求和响应，减少了建立和关闭连接的消耗和延迟，在 HTTP1.1中默认开启Connection:keep-alive,一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。</p><h2 id="HTTPS与HTTP的一些区别"><a href="#HTTPS与HTTP的一些区别" class="headerlink" title="HTTPS与HTTP的一些区别"></a>HTTPS与HTTP的一些区别</h2><pre><code>- HTTPS 协议需要到CA申请证书，- HTTP 协议运行在TCP之上，所有传输的内容都是明文，HTTPS 运行在 SSL/TLS之上，SSL/TLS运行在TCP 之上，所有传输的内容都经过加密的。- HTTP 和 HTTPS 使用的是完全不同的连接方式，用的端口也不一样。- HTTPS可以有效的防止运营商劫持。</code></pre><h3 id="什么是多路复用"><a href="#什么是多路复用" class="headerlink" title="什么是多路复用"></a>什么是多路复用</h3><p>多路复用：通过单一的 HTTP/2链接请求发起多重的请求-响应消息，多个请求stream 共享一个TCP连接，实现</p><h2 id="http-状态码"><a href="#http-状态码" class="headerlink" title="http 状态码"></a>http 状态码</h2>]]></content>
      
      
      <categories>
          
          <category> 浏览器渲染涉及的知识点 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>正则表达式,</title>
      <link href="/2023/03/01/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2023/03/01/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="匹配小括号里面的内容"><a href="#匹配小括号里面的内容" class="headerlink" title="匹配小括号里面的内容"></a>匹配小括号里面的内容</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let reg =  /(?&lt;=\()(.+?)(?=\))/g</span><br><span class="line">let str = &quot;(9001)(9002)(9003)&quot;</span><br><span class="line">str.match(reg)</span><br><span class="line"> // [&#x27;9001&#x27;,&#x27;9002&#x27;,&#x27;9003&#x27;]</span><br></pre></td></tr></table></figure><h3 id="将中括号替换为点"><a href="#将中括号替换为点" class="headerlink" title="将中括号替换为点"></a>将中括号替换为点</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let str = &#x27;a[12][334]&#x27;</span><br><span class="line">// 方法一</span><br><span class="line">  str.replace(/\[/g, &quot;.&quot;).replace(/\]/g, &quot;&quot;);</span><br><span class="line">    // a.12.334</span><br><span class="line">// 方法二</span><br><span class="line">  str.replace(/\[([^\[\]]*)\]/g, &quot;.$1&quot;);</span><br><span class="line">    // a.12.334</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 正则表达式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>前端状态管理</title>
      <link href="/2023/03/01/%E5%89%8D%E7%AB%AF%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/"/>
      <url>/2023/03/01/%E5%89%8D%E7%AB%AF%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是状态"><a href="#什么是状态" class="headerlink" title="什么是状态"></a>什么是状态</h2><p><code>状态是数据的变化</code>,例如颜色是红或是蓝，而颜色从红色变为蓝色这就是状态。<br> 状态的改变对应着视图的渲染或某段逻辑的执行。比如颜色从红色变为蓝色可能就要重新渲染视图，并且执行发送请求到服务端的逻辑。<br> <code>通过视图交互或者其他方式触发状态的变化。状态变化联动视图的渲染和逻辑的执行，这就是前端应用的核心。</code></p><h2 id="什么是状态管理"><a href="#什么是状态管理" class="headerlink" title="什么是状态管理"></a>什么是状态管理</h2><p>状态管理具体有两层含义：</p><ul><li>状态变化之前的逻辑，一般是异步的。</li><li>状态变化之后的联动处理，比如渲染视图或执行某段逻辑<br>举一些例子🌰</li></ul><ul><li><p>React 的 setState 不会马上修改状态，而是异步的批量的执行，把状态做一下合并。</p></li><li><p>Redux 的 action 在修改全局 state 之前也是要经历中间件的处理。<br>这些都是状态变化之前的异步过程的管理，是状态管理的第一层含义。</p></li><li><p>再例如 React setState修改了状态之后要触发视图的渲染和生命周期函数的执行，hooks 在依赖数组的状态变化之后也会重新执行(vue的data修改之后会重新渲染视图、执行computed和watch逻辑)</p></li><li><p>Redux 修改了全局状态之后要通知组件做渲染或者做其他逻辑的处理，Vuex、Mobx 等都是。<br>这些状态变化之后联动处理的管理，是状态管理的第二层含义。</p><p>那 Vue、React 和全局状态管理的库 Redux、Mobx、Vuex都是怎么实现状态管理的</p></li></ul><h2 id="状态管理的两种实现思路"><a href="#状态管理的两种实现思路" class="headerlink" title="状态管理的两种实现思路"></a>状态管理的两种实现思路</h2><p>  状态不会是一个，多个状态的集合会用对象的key、value 来表示，例如React 的 state 对象 Vue 的 data 对象<br>  如何监听一个对象的变化？</p><ul><li><p>我们是不是可以提供一个api 来修改，在这个api内做 state变化之前的处理，并且在state变化之后做联动处理。<br>所以这样的方案只能通过提供的api 来触发状态修改，直接修改state的值是触发不了状态管理逻辑。</p><p>React 的setState就是这种思路，通过setState修改状态会做状态变化之前的批量异步的状态合并，会触发状态变化之后视图渲染和hooks、生命周期的重新执行。直接修改state是没有用的。</p><ul><li>那怎么让直接修改状态也能监听到变化？<br>可以对对象做一层代理，代理它的set和get ，当执行get 的时候把依赖改状态的逻辑收集起来，当set修改状态的时候通知所有依赖它的逻辑(视图渲染、逻辑执行)做更新。<br>这种思路叫做响应式，也就是状态变化之后自动响应变化做联动处理的意思。</li></ul></li></ul><p><code>监听对象的变化就这两种方式：一 提供api来修改，内部做联动处理。二对对象做一层代理，set的时候做联动处理，通知get时收集的所有依赖。</code></p><h2 id="前端框架状态变化的性能优化"><a href="#前端框架状态变化的性能优化" class="headerlink" title="前端框架状态变化的性能优化"></a>前端框架状态变化的性能优化</h2><p>  频繁的修改state不是每一次都要做联动处理，有一些可以合并，所以React的setState是异步，会做批量的state合并(React 的setState传入的不是最终的state,而是state的diff,React内部去把这些diffstate更新到state.)<br>  而Vue是直接修改的是同一个对象，所以没有必要做合并，它的Watcher 执行是异步的，对多次放到队列里的Watcher 做下去重就行。 </p><h2 id="组件间的状体管理"><a href="#组件间的状体管理" class="headerlink" title="组件间的状体管理"></a>组件间的状体管理</h2><p> 组件内的状态管理是利用前端框架自带的state机制来管理。<br> 组件之间？一个组件的state变了如何联动其他组件变化。</p><h3 id="props"><a href="#props" class="headerlink" title="props"></a>props</h3><p>  通过props，把当前的组件的state作为props 传入其他组件，这样就可以联动变化。但是props只能一层层传递，如果组件和联动变化的组件相隔很层，传递props就很麻烦。<br> React 提供了Context 、Vue 提供了Event Bus。</p><h3 id="Context、Event-Bus"><a href="#Context、Event-Bus" class="headerlink" title="Context、Event Bus"></a>Context、Event Bus</h3><p>  React 组件可以在content中存放state,当context 中的state 变化的时候会直接触发相关联组件的渲染。</p><h3 id="Redux、Mobx、Vuex"><a href="#Redux、Mobx、Vuex" class="headerlink" title="Redux、Mobx、Vuex"></a>Redux、Mobx、Vuex</h3><pre><code>redux 就提供了中间件的机制，组件里发送action到store 之前会经历层层中间件的处理，在这里可以做一些可复用的逻辑的封装。redux 就是提供api来修改的方案，通过reducer函数来对传入的action做处理，返回新的state。mobx 没有提供中间件机制，它的action是执行状态class 的某个方法，可以用class的那套来做封装。mobx是响应式代理的方案，它对全局state做了一层代理(通过Object.defineProperty)，状态的get收集依赖，set的时候触发依赖更新。vuex则像是两种思路的结合，内部是响应式代理来实现的变化监听，但是暴露出的api却是 redux 的 action 那一套。</code></pre><p>不管是前端框架内置的组件内状态变化管理的方案(react的setState、vue的直接修改data),还是前端框架提供的组件的状态管理方案(props、react的content、vue 的 event bus) 或是第三方的全局状态管理方案(redux、vuex、mobx等)都没有脱离那两种实现状态管理的方式：提供修改状态的api或者对状态对象做一层响应式代理。<br>也没有脱离状态管理的两层含义：对状态变化前的异步过程做管理，状态变化后做联动处理。只不过它们用在了不同的地方(前端框架内、全局状态管理库)，提供了不同的封装形式(对象、函数)，基于不同的思想(函数式、面向对象)结合了不同的异步管理方案。<br><code>状态是数据的变化。前端应用的核心问题就是管理状态，管理状态变化之前的通过视图或者其他方式触发的异步过程，管理状态变化之后的联动渲染和联动的逻辑执行</code></p>]]></content>
      
      
      <categories>
          
          <category> 状态管理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>正则知识点,</title>
      <link href="/2023/03/01/%E6%AD%A3%E5%88%99/%E6%AD%A3%E5%88%99%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
      <url>/2023/03/01/%E6%AD%A3%E5%88%99/%E6%AD%A3%E5%88%99%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h2 id="正则表达式字符匹配"><a href="#正则表达式字符匹配" class="headerlink" title="正则表达式字符匹配"></a>正则表达式字符匹配</h2><p>正则表达式是匹配模式，要么匹配字符，要么匹配位置。</p><h3 id="两种模糊匹配"><a href="#两种模糊匹配" class="headerlink" title="两种模糊匹配"></a>两种模糊匹配</h3><p>  如果正则只有精确匹配是没有多大意义的。正则之所以强大是因为其能实现模糊匹配。<br>  而模糊匹配有两个方向上的模糊：横向模糊和纵向模糊。</p><h4 id="横向模糊匹配"><a href="#横向模糊匹配" class="headerlink" title="横向模糊匹配"></a>横向模糊匹配</h4><p>  横向模糊匹配指的是，一个正则可以匹配的字符串的长度是不固定的，可以是多种情况的。<br>  其实现方式是使用量词。例如{m,n}，表示连续出现最少m次，最多n次。<br>  eg: /ab{2,5}c/ 表示匹配这样一个字符串：第一个字符是 ‘a’，接下来是2到5个字符串’b’，最后一个字符串’c’。<br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var reg = /ab&#123;2,5&#125;c/g</span><br><span class="line">var string = &#x27;abc abbc abbbc abbbbc&#x27;</span><br><span class="line">string.match(reg)</span><br><span class="line"> // [&#x27;abbc&#x27;,&#x27;abbbc&#x27;,&#x27;abbbbc&#x27;]</span><br></pre></td></tr></table></figure><br>   案例中使用的正则后面多了一个g，是正则的修饰符，表示全局匹配，即在目标字符串中按顺序找到满足匹配模式的所有字串，强调的是’所有’，而不只是’第一个’。</p><h4 id="纵向模糊匹配"><a href="#纵向模糊匹配" class="headerlink" title="纵向模糊匹配"></a>纵向模糊匹配</h4><p>  纵向模糊匹配指的是，一个正则匹配的字符串，具体到某一个字符时，它可以不是某个确定的字符，可以有很多种可能。<br>  其实现方式是使用字符组。例如[abc]，表示该字符可以是字符’a’、’b’、’c’种任何一个。<br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var reg = /a[123]c/g</span><br><span class="line">var string = &#x27;a0c a1c a2c a3c a4c&#x27;</span><br><span class="line">string.match(reg)</span><br><span class="line">// [&#x27;a1c&#x27;,&#x27;a2c&#x27;,&#x27;a3c&#x27;]</span><br></pre></td></tr></table></figure></p><h3 id="字符组"><a href="#字符组" class="headerlink" title="字符组"></a>字符组</h3><p>  虽然是叫字符组，胆汁酸其中一个字符。</p><ul><li>范围表示法<br>用连字符 - 来省略和简写<br>eg [123456789]  =&gt; [1-9]</li><li>排除字符组<br>用 [^] 来表示除了里面的字符。<br>  eg:[^abc] 表示除了’a’、’b’、’c’之外的任意一个字符。</li><li>常见的简写形式。<ul><li>\d 就是 [0-9]。表示是一位数字。</li><li>\D 就是 [^0-9]。表示除数字以外的任意字符。</li><li>\w 就是 [0-9a-zA-Z_]。表示数字、大小写字母和下划线。</li><li>\W 就是 [^0-9a-zA-Z_]。 非单词字符。</li><li>\s 就是 [\t\v\n\r\f]。表示空白字符，包括空格、水平制表符、垂直制表符、换行符、回车符、换页符。</li><li>\S 就是 [^\t\v\n\r\f]。非空白符。</li><li>.  就是 [^\n\r\u2028\u2029]。 通配符，表示几乎任意字符。换行符、回车符、行分符和段分割符除外。  </li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 正则表达式 </category>
          
          <category> 正则知识点 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>前端存储</title>
      <link href="/2023/03/01/%E5%89%8D%E7%AB%AF%E5%AD%98%E5%82%A8/"/>
      <url>/2023/03/01/%E5%89%8D%E7%AB%AF%E5%AD%98%E5%82%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h1><p>HTTP Cookie (也叫 Web Cookie 或浏览器 Cookie) 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一个服务器再发起请求时被携带并发送到服务器上，它用于告知服务端两个请求是否来自同一浏览器。</p><ul><li><p>Cookie 的作用主要有三个</p><ul><li>会话状态管理 (eg:用户登录状态、购物车、游戏分数)</li><li>个性化设置 (eg:用户自定义设置、主题等)</li><li>浏览器行为跟踪 (eg:跟踪分析用户行为)</li></ul></li><li><p>Cookie 的特点</p><ul><li>Cookie 的大小受限制，一般为 4 KB;</li><li>同一域名下存放 Cookie 的个数值有限制的，不同的浏览器的个数不一样，一般为 20 个;</li><li>Cookie 支持设置过期时间，过期后自动销毁;</li><li>每次发起同域下的 HTTP 请求时，都会携带当前域名下的 Cookie;</li><li>支持设置为 HttpOnly,防止 Cookie 被客户端的 JavaScript 访问。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//设置 Cookie</span><br><span class="line">document.cookie = &quot;name=semlinker&quot;;</span><br><span class="line">document.cookie = &quot;favorite_food=tripe&quot;;</span><br><span class="line"></span><br><span class="line">//获取指定名字的cookie</span><br><span class="line">document.cookie = &quot;test1=Hello&quot;;</span><br><span class="line">document.cookie = &quot;test2=World&quot;;</span><br><span class="line">var myCookie = document.cookie</span><br><span class="line">.replace(/(?:(?:^|._;\s_)test2\s*\=\s*([^;]_)._$)|^.*$/, &quot;\$1&quot;);</span><br><span class="line">alert(myCookie); // World</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h1 id="localStorage"><a href="#localStorage" class="headerlink" title="localStorage"></a>localStorage</h1><p>一种持久化的存储方式，不手动清除，数据就永远不会过期。采用键值对的方式存储数据，按域名将数据分别保存到对应的数据库文件里。</p><ul><li>localStorage 的特点：<ul><li>大小限制为 5MB~10MB;</li><li>在同源的所有标签页和窗口之间共享数据；</li><li>数据保存在客户端，不与服务器进行通信；</li><li>数据持久化存在且不会过期，重启浏览器后仍然存在；</li><li>对数据的操作是同步的。</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 通过setItem()增加一个数据项</span><br><span class="line">localStorage.setItem(&#x27;myName&#x27;, &#x27;Semlinker&#x27;);</span><br><span class="line"></span><br><span class="line">// 通过getItem()获取某个数据项</span><br><span class="line">let me = localStorage.getItem(&#x27;myName&#x27;);</span><br><span class="line"></span><br><span class="line">// 通过removeItem()移除某个数据项</span><br><span class="line">localStorage.removeItem(&#x27;myName&#x27;);</span><br><span class="line"></span><br><span class="line">// 移除所有数据项</span><br><span class="line">localStorage.clear();</span><br></pre></td></tr></table></figure><h1 id="sessionStorage"><a href="#sessionStorage" class="headerlink" title="sessionStorage"></a>sessionStorage</h1><p>sessionStorage 是一种会话级别的缓存，关闭浏览器时数据会被清除。sessionStorage 的作用域是窗口级别的，不同窗口之间保存的 sessionStorage 数据是不能共享的。</p><p><code>在该标签或窗口打开一个新页面时会复制顶级浏览会话的上下文作为新会话的上下文</code><br><code>多窗口之间sessionStorage不可以共享状态！！！但是在某些特定场景下新开的页面会复制之前页面的sessionStorage！！</code><br><code>其实不仅window.open(&quot;同源页面&quot;)这种方式新开的页面会复制之前的sessionStorage，通过a标签新开的页面同样也会</code></p><ul><li>sessionStorage 的特点<ul><li>sessionStorage 的数据只存在于当前浏览器的标签页；</li><li>数据在刷新后依然存在，但是关闭浏览器标签页之后数据就会被清除；</li><li>对数据的操作是同步的。</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 通过setItem()增加一个数据项</span><br><span class="line">sessionStorage.setItem(&#x27;myName&#x27;, &#x27;Semlinker&#x27;);</span><br><span class="line"></span><br><span class="line">// 通过getItem()获取某个数据项</span><br><span class="line">let me = sessionStorage.getItem(&#x27;myName&#x27;);</span><br><span class="line"></span><br><span class="line">// 通过removeItem()移除某个数据项</span><br><span class="line">sessionStorage.removeItem(&#x27;myName&#x27;);</span><br><span class="line"></span><br><span class="line">// 移除所有数据项</span><br><span class="line">sessionStorage.clear();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/03/01/%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/"/>
      <url>/2023/03/01/%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/</url>
      
        <content type="html"><![CDATA[<h2 id="JS-执行环境、作用域、作用域链"><a href="#JS-执行环境、作用域、作用域链" class="headerlink" title="JS 执行环境、作用域、作用域链"></a>JS 执行环境、作用域、作用域链</h2><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><ul><li>什么是作用域</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript 高级,</title>
      <link href="/2023/03/01/%E5%86%8D%E7%9C%8BJS%E9%AB%98%E7%BA%A7/"/>
      <url>/2023/03/01/%E5%86%8D%E7%9C%8BJS%E9%AB%98%E7%BA%A7/</url>
      
        <content type="html"><![CDATA[<h3 id="JavaScript-执行过程"><a href="#JavaScript-执行过程" class="headerlink" title="JavaScript 执行过程"></a>JavaScript 执行过程</h3><p>JavaScript 运行分为两个阶段</p><ul><li><p>预解析</p><ul><li><p>全局解析(所有的变量和函数声明都会提前；同名的函数和变量函数的优先级高)</p></li><li><p>先查找函数声明，再查找变量声明</p><ul><li>函数声明有冲突，会被后面的覆盖</li><li>变量声明有冲突，会忽略</li></ul></li><li><p>将找到的函数和变量保存到一个对象中(全局保存到 window 对象中)</p></li><li><p>变量的值是 undefined，函数的值则指向该函数(函数字符串)</p><ul><li>{a:undefined,f:’function (){}’}</li></ul></li><li><p>函数内部预解析(所有的变量、函数和形参都会参与预解析)</p><ul><li>读取整个函数源代码</li><li>将函数的参数添加到词法对象中</li><li>先查找函数声明，再查找变量声明<ul><li>函数声明有冲突，会被后面的覆盖</li><li>变量声明有冲突，会忽略</li></ul></li><li>将找到的函数和变量保存到一个词法对象中。</li><li>变量的值是 undefined，函数的值则指向该函数(函数字符串)<ul><li>{a:undefined,f:’function (){}’}</li></ul></li><li>函数</li></ul><ul><li>形参</li><li>普通变量</li></ul></li></ul></li></ul><ul><li>执行<br>先解析全局作用域，然后执行全局作用域中的代码，在执行全局代码的过程中遇到函数调用就会先进行函数预解析，然后再执行函数内部代码。</li></ul><h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><h4 id="什么是对象"><a href="#什么是对象" class="headerlink" title="什么是对象"></a>什么是对象</h4><p>Everything is object (万物皆对象)</p><ul><li>对象到底是什么，可以从两个层次来理解<ul><li>对象是单个事务的抽象<br>一本书、一辆车、一个人都可以是对象。当实物被抽象成对象，实物之间的关系就变成了对象之间的关系。</li><li>对象是一个容器，封装了属性(property) 和方法 (method)<br>属性是对象的状态，方法是对象的行为(完成某种任务)<br>实际开发中，对象是一个抽象的概念，可以理解为：数据集或功能集。<br>ECMAScript 把对象定义为：无序属性的集合，其属性可以包含基本值、对象或者函数。</li></ul></li></ul><h4 id="什么是面向对象"><a href="#什么是面向对象" class="headerlink" title="什么是面向对象"></a>什么是面向对象</h4><p>面向对象是过程式代码的一种高度封装，目的在于提高代码的开发效率和可维护性。</p><ul><li><p>面向对象编程<br>面向对象编程 — Object Oriented Programming，简称 OOP，是一种编程开发思想。它将真实世界各种复杂的关系，抽象为一个对象，然后由对象之间的分工与合作，完成对真实世界的模拟。<br>在面向对象程序开发思想中，每一个对象都是功能中心，具有明确分工。可以完成接收信息、处理数据、发出信息等任务。<br>面向对象编程具有灵活、代码复用、高度模块化等特点，容易开发和维护。</p></li><li><p>面向对象与面向过程</p><ul><li>面向过程就是亲历亲为，事无巨细，面面俱到，步步紧跟，有条不紊</li><li>面向对象就是找一个对象，指挥得到结果</li><li>面向对象将执行者转变成指挥者</li><li>面向对象不是面向过程的替代，而是面向过程的封装。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaScript 高级 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>web 代码编辑器</title>
      <link href="/2023/03/01/%E5%89%8D%E7%AB%AF%E4%BD%BF%E7%94%A8%E4%BB%A3%E7%A0%81%E7%BC%96%E8%BE%91%E5%99%A8/"/>
      <url>/2023/03/01/%E5%89%8D%E7%AB%AF%E4%BD%BF%E7%94%A8%E4%BB%A3%E7%A0%81%E7%BC%96%E8%BE%91%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="web-代码编辑器"><a href="#web-代码编辑器" class="headerlink" title="web 代码编辑器"></a>web 代码编辑器</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=&quot;yanzi-monaco-editor&quot; :style=&quot;settings.style&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;topTabs&quot; :class=&quot;&#123; &#x27;topTabs-dark&#x27;: theme === &#x27;vs-dark&#x27; &#125;&quot;&gt;</span><br><span class="line">      &lt;el-tabs</span><br><span class="line">        v-model=&quot;currentModelName&quot;</span><br><span class="line">        type=&quot;card&quot;</span><br><span class="line">        @tab-remove=&quot;removeTab&quot;</span><br><span class="line">        @tab-click=&quot;activeTab&quot;</span><br><span class="line">      &gt;</span><br><span class="line">        &lt;el-tab-pane</span><br><span class="line">          :closable=&quot;item.closable&quot;</span><br><span class="line">          v-for=&quot;item in modelList&quot;</span><br><span class="line">          :key=&quot;item.name&quot;</span><br><span class="line">          :label=&quot;item.title&quot;</span><br><span class="line">          :name=&quot;item.name&quot;</span><br><span class="line">        &gt;</span><br><span class="line">          &lt;template&gt;</span><br><span class="line">            &lt;span slot=&quot;reference&quot;&gt;&#123;&#123; item.content &#125;&#125;&lt;/span&gt;</span><br><span class="line">          &lt;/template&gt;</span><br><span class="line">        &lt;/el-tab-pane&gt;</span><br><span class="line">      &lt;/el-tabs&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 工具条 --&gt;</span><br><span class="line">    &lt;div</span><br><span class="line">      class=&quot;editorTools&quot;</span><br><span class="line">      :class=&quot;&#123;</span><br><span class="line">        editorToolsFullPage: fullPage,</span><br><span class="line">        &#x27;editorTools-dark&#x27;: theme === &#x27;vs-dark&#x27;,</span><br><span class="line">      &#125;&quot;</span><br><span class="line">    &gt;</span><br><span class="line">      &lt;i</span><br><span class="line">        @click=&quot;changeEditType(&#x27;1&#x27;)&quot;</span><br><span class="line">        :class=&quot;&#123; toolItemActive: editType == &#x27;1&#x27; &#125;&quot;</span><br><span class="line">        class=&quot;toolItem iconfont iconfenlan&quot;</span><br><span class="line">      &gt;&lt;/i&gt;</span><br><span class="line">      &lt;i</span><br><span class="line">        @click=&quot;changeEditType(&#x27;2&#x27;)&quot;</span><br><span class="line">        :class=&quot;&#123; toolItemActive: editType == &#x27;2&#x27; &#125;&quot;</span><br><span class="line">        class=&quot;toolItem iconfont icondaima&quot;</span><br><span class="line">      &gt;&lt;/i&gt;</span><br><span class="line">      &lt;i</span><br><span class="line">        @click=&quot;changeEditType(&#x27;3&#x27;)&quot;</span><br><span class="line">        :class=&quot;&#123; toolItemActive: editType == &#x27;3&#x27; &#125;&quot;</span><br><span class="line">        class=&quot;toolItem iconfont iconkanfangxuanfang&quot;</span><br><span class="line">      &gt;&lt;/i&gt;</span><br><span class="line">      &lt;el-popover placement=&quot;bottom&quot; title=&quot;&quot; trigger=&quot;hover&quot;&gt;</span><br><span class="line">        &lt;el-button-group&gt;</span><br><span class="line">          &lt;el-button @click=&quot;reset(&#x27;&#x27;)&quot; size=&quot;mini&quot; plain&gt;清空&lt;/el-button&gt;</span><br><span class="line">          &lt;el-button @click=&quot;reset(&#x27;vue&#x27;)&quot; size=&quot;mini&quot; plain&gt;Vue&lt;/el-button&gt;</span><br><span class="line">          &lt;el-button @click=&quot;reset(&#x27;html&#x27;)&quot; size=&quot;mini&quot; plain&gt;HTML&lt;/el-button&gt;</span><br><span class="line">        &lt;/el-button-group&gt;</span><br><span class="line">        &lt;i class=&quot;toolItem iconfont iconreset&quot; slot=&quot;reference&quot;&gt;&lt;/i&gt;</span><br><span class="line">      &lt;/el-popover&gt;</span><br><span class="line"></span><br><span class="line">      &lt;el-popover placement=&quot;bottom-start&quot; title=&quot;&quot; width=&quot;200&quot; trigger=&quot;hover&quot;&gt;</span><br><span class="line">        &lt;div class=&quot;storageBox&quot;&gt;</span><br><span class="line">          &lt;h3&gt;js库&lt;/h3&gt;</span><br><span class="line">          &lt;el-button</span><br><span class="line">            size=&quot;mini&quot;</span><br><span class="line">            type=&quot;text&quot;</span><br><span class="line">            @click=&quot;</span><br><span class="line">              insertText(&#x27;https://code.xzlovecyy.com/files/js/vue.min.js&#x27;)</span><br><span class="line">            &quot;</span><br><span class="line">            &gt;Vue&lt;/el-button</span><br><span class="line">          &gt;</span><br><span class="line">          &lt;el-button</span><br><span class="line">            size=&quot;mini&quot;</span><br><span class="line">            type=&quot;text&quot;</span><br><span class="line">            @click=&quot;</span><br><span class="line">              insertText(</span><br><span class="line">                &#x27;https://code.xzlovecyy.com/files/element-ui/lib/index.js&#x27;</span><br><span class="line">              )</span><br><span class="line">            &quot;</span><br><span class="line">            &gt;Element UI&lt;/el-button</span><br><span class="line">          &gt;</span><br><span class="line">          &lt;el-button</span><br><span class="line">            size=&quot;mini&quot;</span><br><span class="line">            type=&quot;text&quot;</span><br><span class="line">            @click=&quot;</span><br><span class="line">              insertText(&#x27;https://code.xzlovecyy.com/files/js/jquery.min.js&#x27;)</span><br><span class="line">            &quot;</span><br><span class="line">            &gt;jQuery&lt;/el-button</span><br><span class="line">          &gt;</span><br><span class="line">          &lt;el-button</span><br><span class="line">            size=&quot;mini&quot;</span><br><span class="line">            type=&quot;text&quot;</span><br><span class="line">            @click=&quot;</span><br><span class="line">              insertText(&#x27;https://code.xzlovecyy.com/files/js/echarts.min.js&#x27;)</span><br><span class="line">            &quot;</span><br><span class="line">            &gt;Echarts&lt;/el-button</span><br><span class="line">          &gt;</span><br><span class="line">          &lt;el-button</span><br><span class="line">            size=&quot;mini&quot;</span><br><span class="line">            type=&quot;text&quot;</span><br><span class="line">            @click=&quot;</span><br><span class="line">              insertText(&#x27;https://code.xzlovecyy.com/files/js/axios.min.js&#x27;)</span><br><span class="line">            &quot;</span><br><span class="line">            &gt;axios&lt;/el-button</span><br><span class="line">          &gt;</span><br><span class="line">          &lt;el-button</span><br><span class="line">            size=&quot;mini&quot;</span><br><span class="line">            type=&quot;text&quot;</span><br><span class="line">            @click=&quot;</span><br><span class="line">              insertText(&#x27;https://code.xzlovecyy.com/files/layui/layui.all.js&#x27;)</span><br><span class="line">            &quot;</span><br><span class="line">            &gt;Layui&lt;/el-button</span><br><span class="line">          &gt;</span><br><span class="line">          &lt;el-button</span><br><span class="line">            size=&quot;mini&quot;</span><br><span class="line">            type=&quot;text&quot;</span><br><span class="line">            @click=&quot;</span><br><span class="line">              insertText(&#x27;https://code.xzlovecyy.com/files/js/highlight.min.js&#x27;)</span><br><span class="line">            &quot;</span><br><span class="line">            &gt;highlight&lt;/el-button</span><br><span class="line">          &gt;</span><br><span class="line">          &lt;h3&gt;css库&lt;/h3&gt;</span><br><span class="line">          &lt;el-button</span><br><span class="line">            size=&quot;mini&quot;</span><br><span class="line">            type=&quot;text&quot;</span><br><span class="line">            @click=&quot;</span><br><span class="line">              insertText(</span><br><span class="line">                &#x27;https://code.xzlovecyy.com/files/element-ui/lib/theme-chalk/index.css&#x27;</span><br><span class="line">              )</span><br><span class="line">            &quot;</span><br><span class="line">            &gt;Element UI&lt;/el-button</span><br><span class="line">          &gt;</span><br><span class="line">          &lt;el-button</span><br><span class="line">            size=&quot;mini&quot;</span><br><span class="line">            type=&quot;text&quot;</span><br><span class="line">            @click=&quot;</span><br><span class="line">              insertText(&#x27;https://code.xzlovecyy.com/files/layui/css/layui.css&#x27;)</span><br><span class="line">            &quot;</span><br><span class="line">            &gt;Layui&lt;/el-button</span><br><span class="line">          &gt;</span><br><span class="line">          &lt;el-button</span><br><span class="line">            size=&quot;mini&quot;</span><br><span class="line">            type=&quot;text&quot;</span><br><span class="line">            @click=&quot;</span><br><span class="line">              insertText(</span><br><span class="line">                &#x27;https://code.xzlovecyy.com/files/css/bootstrap.min.css&#x27;</span><br><span class="line">              )</span><br><span class="line">            &quot;</span><br><span class="line">            &gt;Bootstrap&lt;/el-button</span><br><span class="line">          &gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;i class=&quot;toolItem iconfont iconicon-store&quot; slot=&quot;reference&quot;&gt;&lt;/i&gt;</span><br><span class="line">      &lt;/el-popover&gt;</span><br><span class="line">      &lt;i</span><br><span class="line">        @click=&quot;changeTheme(&#x27;vs-dark&#x27;)&quot;</span><br><span class="line">        v-if=&quot;theme == &#x27;vs&#x27;&quot;</span><br><span class="line">        class=&quot;toolItem iconfont iconyejianmoshishenyemoshiyueliang&quot;</span><br><span class="line">      &gt;&lt;/i&gt;</span><br><span class="line">      &lt;i</span><br><span class="line">        @click=&quot;changeTheme(&#x27;vs&#x27;)&quot;</span><br><span class="line">        v-else</span><br><span class="line">        class=&quot;toolItem iconfont iconday&quot;</span><br><span class="line">      &gt;&lt;/i&gt;</span><br><span class="line">      &lt;i</span><br><span class="line">        @click=&quot;changeFullPage()&quot;</span><br><span class="line">        v-if=&quot;fullPage&quot;</span><br><span class="line">        class=&quot;toolItem iconfont iconsuoxiao&quot;</span><br><span class="line">      &gt;&lt;/i&gt;</span><br><span class="line">      &lt;i</span><br><span class="line">        @click=&quot;changeFullPage()&quot;</span><br><span class="line">        v-else</span><br><span class="line">        class=&quot;toolItem iconfont iconfullscreen&quot;</span><br><span class="line">      &gt;&lt;/i&gt;</span><br><span class="line">      &lt;i</span><br><span class="line">        @click=&quot;runingCode()&quot;</span><br><span class="line">        v-if=&quot;isRun&quot;</span><br><span class="line">        :class=&quot;&#123; rotate: isRun &#125;&quot;</span><br><span class="line">        class=&quot;toolItem iconfont iconyunxingzhong&quot;</span><br><span class="line">        style=&quot;color: #67c23a !important; background: transparent !important&quot;</span><br><span class="line">      &gt;&lt;/i&gt;</span><br><span class="line">      &lt;i</span><br><span class="line">        @click=&quot;runingCode()&quot;</span><br><span class="line">        v-else</span><br><span class="line">        class=&quot;toolItem iconfont icontingzhi&quot;</span><br><span class="line">        style=&quot;color: #f56c6c !important; background: transparent !important&quot;</span><br><span class="line">      &gt;&lt;/i&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;div class=&quot;eidtorContent&quot; :class=&quot;&#123; eidtorContentFullPage: fullPage &#125;&quot;&gt;</span><br><span class="line">      &lt;div</span><br><span class="line">        class=&quot;monacoEditor&quot;</span><br><span class="line">        id=&quot;monaco&quot;</span><br><span class="line">        ref=&quot;monaco&quot;</span><br><span class="line">        :style=&quot;setEditorStyle()&quot;</span><br><span class="line">      &gt;&lt;/div&gt;</span><br><span class="line">      &lt;iframe</span><br><span class="line">        class=&quot;viewIframe&quot;</span><br><span class="line">        id=&quot;viewIframe&quot;</span><br><span class="line">        ref=&quot;viewIframe&quot;</span><br><span class="line">        :style=&quot;setViewStyle()&quot;</span><br><span class="line">      &gt;&lt;/iframe&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;el-dialog</span><br><span class="line">      title=&quot;选择语言&quot;</span><br><span class="line">      :visible.sync=&quot;showSelectMode&quot;</span><br><span class="line">      width=&quot;280px&quot;</span><br><span class="line">      custom-class=&quot;selectModelDialog&quot;</span><br><span class="line">    &gt;</span><br><span class="line">      &lt;el-radio-group v-model=&quot;mode&quot; @change=&quot;selectModeRadio&quot;&gt;</span><br><span class="line">        &lt;el-radio-button type=&quot;primary&quot; label=&quot;html&quot;&gt;html&lt;/el-radio-button&gt;</span><br><span class="line">        &lt;el-radio-button label=&quot;javascript&quot;&gt;javascript&lt;/el-radio-button&gt;</span><br><span class="line">        &lt;el-radio-button label=&quot;css&quot;&gt;css&lt;/el-radio-button&gt;</span><br><span class="line">      &lt;/el-radio-group&gt;</span><br><span class="line">    &lt;/el-dialog&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">/* eslint-disable */</span><br><span class="line">&lt;!-- import cache from &#x27;../utils/cache&#x27;</span><br><span class="line">import toast from &#x27;../utils/tips&#x27;</span><br><span class="line">import templateJS from &#x27;../utils/template&#x27; --&gt;</span><br><span class="line">/* eslint-disable */</span><br><span class="line">import * as monaco from &#x27;monaco-editor/esm/vs/editor/editor.main.js&#x27;</span><br><span class="line">import &#123; emmetHTML &#125; from &#x27;emmet-monaco-es&#x27;</span><br><span class="line">import Vue from &#x27;vue&#x27;</span><br><span class="line">import ElementUI from &#x27;element-ui&#x27;</span><br><span class="line">import &#x27;element-ui/lib/theme-chalk/index.css&#x27;</span><br><span class="line">Vue.use(ElementUI)</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#x27;yanzi-monaco-editor&#x27;,</span><br><span class="line">  components: &#123;&#125;,</span><br><span class="line">  props: &#123;</span><br><span class="line">    settings: &#123;</span><br><span class="line">      type: Object,</span><br><span class="line">      default: function () &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">          style: &#123;</span><br><span class="line">            width: &#x27;100%&#x27;,</span><br><span class="line">            height: &#x27;100%&#x27;,</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      fullPage: false, // 是否全屏</span><br><span class="line">      editType: &#x27;1&#x27;, // 编辑模式， 【1 = 二栏边写边看、2 = 一栏编辑、 3 = 一栏预览】</span><br><span class="line">      showSelectMode: false, // 添加model前，选择语言dialog</span><br><span class="line">      mode: &#x27;&#x27;, // 当前选中的 语言</span><br><span class="line">      dispose: null, // 编辑器销毁方法</span><br><span class="line">      theme: &#x27;vs-dark&#x27;, // 编辑器主题 vs, hc-black, or vs-dark</span><br><span class="line">      myEditor: &#123;&#125;, // 初始化编辑器对象</span><br><span class="line">      currentModelName: &#x27;&#x27;, // 当前选中 tab model 的名称用于切换编辑器的model</span><br><span class="line">      // 顶部的 tabs ,永远都会保留 + 这个 tab</span><br><span class="line">      modelList: [</span><br><span class="line">        &#123;</span><br><span class="line">          title: &#x27;+&#x27;,</span><br><span class="line">          name: &#x27;+&#x27;,</span><br><span class="line">        &#125;,</span><br><span class="line">      ],</span><br><span class="line">      isRun: false, // 是否实时运行</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    // 运行代码</span><br><span class="line">    runingCode() &#123;</span><br><span class="line">      this.isRun = !this.isRun</span><br><span class="line">      cache.set(&#x27;isRun&#x27;, this.isRun)</span><br><span class="line">      if (this.isRun) &#123;</span><br><span class="line">        this.showView()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    // 重置编辑器内容</span><br><span class="line">    reset(type) &#123;</span><br><span class="line">      let model = this.myEditor.getModel()</span><br><span class="line">      console.log(model)</span><br><span class="line">      if (type == &#x27;vue&#x27;) &#123;</span><br><span class="line">        this.myEditor.setValue(templateJS.vue)</span><br><span class="line">      &#125; else if (type === &#x27;html&#x27;) &#123;</span><br><span class="line">        this.myEditor.setValue(templateJS.html)</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        this.myEditor.setValue(&#x27;&#x27;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    // 切换全屏</span><br><span class="line">    changeFullPage() &#123;</span><br><span class="line">      this.fullPage = !this.fullPage</span><br><span class="line">      this.myEditor.layout()</span><br><span class="line">    &#125;,</span><br><span class="line">    // 切换编辑方式</span><br><span class="line">    changeEditType(editType) &#123;</span><br><span class="line">      this.editType = editType</span><br><span class="line">      this.myEditor.layout()</span><br><span class="line">    &#125;,</span><br><span class="line">    changeTheme(theme) &#123;</span><br><span class="line">      // 切换主题</span><br><span class="line">      this.theme = theme</span><br><span class="line">      console.log(theme)</span><br><span class="line">      monaco.editor.setTheme(theme)</span><br><span class="line">      localStorage.setItem(&#x27;theme&#x27;, theme)</span><br><span class="line">    &#125;,</span><br><span class="line">    // 复制内容到剪贴板</span><br><span class="line">    insertText(content) &#123;</span><br><span class="line">      var line = this.myEditor.getPosition()</span><br><span class="line">      var range = new monaco.Range(line.lineNumber, 1, line.lineNumber, 1)</span><br><span class="line">      let suffix = content.substring(content.lastIndexOf(&#x27;.&#x27;) + 1)</span><br><span class="line">      var id = &#123; major: 1, minor: 1 &#125;</span><br><span class="line">      /* eslint-disable */</span><br><span class="line">      var text =</span><br><span class="line">        suffix == &#x27;js&#x27;</span><br><span class="line">          ? `\t&lt;script src=&quot;$&#123;content&#125;&quot;&gt;&lt;\/script&gt;`</span><br><span class="line">          : `\t&lt;link rel=&quot;stylesheet&quot; href=&quot;$&#123;content&#125;&quot;/&gt;`</span><br><span class="line">      /* eslint-disable */</span><br><span class="line">      var op = &#123;</span><br><span class="line">        identifier: id,</span><br><span class="line">        range: range,</span><br><span class="line">        text: text,</span><br><span class="line">        forceMoveMarkers: true,</span><br><span class="line">      &#125;</span><br><span class="line">      this.myEditor.executeEdits(&#x27;my-source&#x27;, [op])</span><br><span class="line">      // this.myEditor.insertText(content);</span><br><span class="line">    &#125;,</span><br><span class="line">    // 选中 tab</span><br><span class="line">    activeTab(e) &#123;</span><br><span class="line">      // 点击不能关闭的，即是添加操作</span><br><span class="line">      if (!e.closable) &#123;</span><br><span class="line">        this.openSelectMode()</span><br><span class="line">        return</span><br><span class="line">      &#125;</span><br><span class="line">      let model = this.getModelByName(e.name)</span><br><span class="line">      this.changeEditorModel(model)</span><br><span class="line">    &#125;,</span><br><span class="line">    // 切换 编辑器 model</span><br><span class="line">    changeEditorModel(model) &#123;</span><br><span class="line">      this.dispose &amp;&amp; this.dispose()</span><br><span class="line">      if (model.mode == &#x27;html&#x27;) &#123;</span><br><span class="line">        this.dispose = emmetHTML(monaco)</span><br><span class="line">      &#125;</span><br><span class="line">      this.myEditor.setModel(model.model)</span><br><span class="line">      this.bindEvent(model.model)</span><br><span class="line">    &#125;,</span><br><span class="line">    // 在 tabs 列表中获得编辑器model</span><br><span class="line">    getActiveModel(name, type) &#123;</span><br><span class="line">      for (var i = 0; i &lt; this.modelList.length; i++) &#123;</span><br><span class="line">        if (type == &#x27;name&#x27; &amp;&amp; name == this.modelList[i].name) &#123;</span><br><span class="line">          return this.modelList[i] &amp;&amp; this.modelList[i]</span><br><span class="line">        &#125;</span><br><span class="line">        if (type == &#x27;title&#x27; &amp;&amp; name == this.modelList[i].name) &#123;</span><br><span class="line">          return this.modelList[i] &amp;&amp; this.modelList[i]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    // 按 name 获得 model</span><br><span class="line">    getModelByName(name) &#123;</span><br><span class="line">      return this.getActiveModel(name, &#x27;name&#x27;)</span><br><span class="line">    &#125;,</span><br><span class="line">    // 按 title 获得 model</span><br><span class="line">    getModelByTitle(title) &#123;</span><br><span class="line">      return this.getActiveModel(title, &#x27;title&#x27;)</span><br><span class="line">    &#125;,</span><br><span class="line">    // 选择 model</span><br><span class="line">    openSelectMode() &#123;</span><br><span class="line">      this.showSelectMode = true</span><br><span class="line">    &#125;,</span><br><span class="line">    // 选择完，创建model</span><br><span class="line">    selectModeRadio() &#123;</span><br><span class="line">      this.showSelectMode = false</span><br><span class="line">      this.setModel(&#123;</span><br><span class="line">        mode: this.mode,</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    // 添加 一个 tab</span><br><span class="line">    addTab(modelContainer) &#123;</span><br><span class="line">      let newTabName =</span><br><span class="line">        this.modelList.length == 1 ? &#x27;tab-1&#x27; : &#x27;tab-&#x27; + this.modelList.length</span><br><span class="line">      this.modelList.splice(this.modelList.length - 1, 0, modelContainer)</span><br><span class="line">      this.$nextTick(() =&gt; &#123;</span><br><span class="line">        this.currentModelName = newTabName.toString()</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    // 关闭 一个 tab</span><br><span class="line">    removeTab(targetName) &#123;</span><br><span class="line">      let tabs = this.modelList</span><br><span class="line">      let activeName = this.currentModelName</span><br><span class="line">      if (activeName === targetName) &#123;</span><br><span class="line">        tabs.forEach((tab, index) =&gt; &#123;</span><br><span class="line">          if (tab.name === targetName) &#123;</span><br><span class="line">            let nextTab = tabs[index - 1]</span><br><span class="line">            if (nextTab) &#123;</span><br><span class="line">              activeName = nextTab.name</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">      this.currentModelName = activeName</span><br><span class="line">      let removeModel = this.getModelByName(targetName)</span><br><span class="line">      removeModel.model.dispose()</span><br><span class="line">      this.modelList = tabs.filter((tab) =&gt; tab.name !== targetName)</span><br><span class="line">      if (this.modelList.length &gt; 1) &#123;</span><br><span class="line">        let modelContainer = this.modelList[this.modelList.length - 2]</span><br><span class="line">        this.changeEditorModel(modelContainer)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    // 初始化编辑器容器</span><br><span class="line">    initEditor() &#123;</span><br><span class="line">      if (this.settings.mode == &#x27;html&#x27;) &#123;</span><br><span class="line">        this.dispose = emmetHTML(monaco)</span><br><span class="line">      &#125;</span><br><span class="line">      let that = this</span><br><span class="line">      let ed = document.getElementById(&#x27;monaco&#x27;)</span><br><span class="line">      this.myEditor = monaco.editor.create(ed, &#123;</span><br><span class="line">        theme: this.theme,</span><br><span class="line">        automaticLayout: true,</span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">      // this.selection = this.myEditor.getSelection();</span><br><span class="line">      // console.log(this.selection);</span><br><span class="line">    &#125;,</span><br><span class="line">    // 增加一个 model</span><br><span class="line">    setModel(source) &#123;</span><br><span class="line">      let newTabName = &#x27;tab-&#x27; + this.modelList.length</span><br><span class="line">      let suffix</span><br><span class="line">      switch (source.mode) &#123;</span><br><span class="line">        case &#x27;html&#x27;:</span><br><span class="line">          suffix = &#x27;.html&#x27;</span><br><span class="line">          break</span><br><span class="line">        case &#x27;javascript&#x27;:</span><br><span class="line">          suffix = &#x27;.js&#x27;</span><br><span class="line">          break</span><br><span class="line">        case &#x27;css&#x27;:</span><br><span class="line">          suffix = &#x27;.css&#x27;</span><br><span class="line">          break</span><br><span class="line">      &#125;</span><br><span class="line">      let addMode = Object.assign(source, &#123;</span><br><span class="line">        title: source.name || &#x27;新建文件&#x27; + suffix,</span><br><span class="line">        name: newTabName,</span><br><span class="line">        closable: true,</span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">      const model = monaco.editor.createModel(source.content || &#x27;&#x27;, source.mode)</span><br><span class="line">      addMode.model = model</span><br><span class="line">      this.changeEditorModel(addMode)</span><br><span class="line">      this.addTab(addMode)</span><br><span class="line">      this.mode = &#x27;&#x27;</span><br><span class="line">    &#125;,</span><br><span class="line">    // 绑定事件</span><br><span class="line">    bindEvent(model) &#123;</span><br><span class="line">      /* eslint-disable */</span><br><span class="line">      let that = this</span><br><span class="line">      model.onDidChangeContent((event) =&gt; &#123;</span><br><span class="line">        const newValue = that.myEditor.getValue()</span><br><span class="line">        that.showView(newValue)</span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">      /* eslint-disable */</span><br><span class="line">    &#125;,</span><br><span class="line">    setEditorStyle() &#123;</span><br><span class="line">      switch (this.editType) &#123;</span><br><span class="line">        case &#x27;1&#x27;:</span><br><span class="line">          return &#x27;width:50%;&#x27;</span><br><span class="line">        case &#x27;2&#x27;:</span><br><span class="line">          return &#x27;width:100%;&#x27;</span><br><span class="line">        case &#x27;3&#x27;:</span><br><span class="line">          return &#x27;width:0;&#x27;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    setViewStyle() &#123;</span><br><span class="line">      switch (this.editType) &#123;</span><br><span class="line">        case &#x27;1&#x27;:</span><br><span class="line">          return &#x27;width:50%;&#x27;</span><br><span class="line">        case &#x27;2&#x27;:</span><br><span class="line">          return &#x27;width:0;&#x27;</span><br><span class="line">        case &#x27;3&#x27;:</span><br><span class="line">          return &#x27;width:100%;&#x27;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    // 实时运行代码，content 为要修改的内容</span><br><span class="line">    showView(content) &#123;</span><br><span class="line">      if (!this.isRun) &#123;</span><br><span class="line">        return</span><br><span class="line">      &#125;</span><br><span class="line">      try &#123;</span><br><span class="line">        if (!content) &#123;</span><br><span class="line">          content = this.getValue()</span><br><span class="line">        &#125;</span><br><span class="line">        if (!content) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        let language = this.getModelByName(this.currentModelName).mode</span><br><span class="line">        switch (language) &#123;</span><br><span class="line">          case &#x27;javascript&#x27;:</span><br><span class="line">            /* eslint-disable */</span><br><span class="line">            content = `&lt;style&gt;*&#123;margin:0;&#125;&lt;/style&gt;&lt;script&gt;  $&#123;content&#125;  &lt;\/script&gt;`</span><br><span class="line">            /* eslint-disable */</span><br><span class="line">            break</span><br><span class="line">          case &#x27;css&#x27;:</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 获得 iframe 对象</span><br><span class="line">        var o = this.$refs.viewIframe</span><br><span class="line"></span><br><span class="line">        var ed = document.all ? o.contentWindow.document : o.contentDocument</span><br><span class="line">        let body = ed.body</span><br><span class="line">        body.style.margin = &#x27;0px&#x27;</span><br><span class="line">        ed.open()</span><br><span class="line">        ed.write(content)</span><br><span class="line">        ed.close()</span><br><span class="line">      &#125; catch (error) &#123;</span><br><span class="line">        toast.tipsError(&#x27;运行报错&#x27;)</span><br><span class="line">        console.log(&#x27;=====================运行报错=======================&#x27;)</span><br><span class="line">        console.log(error)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    // 获得 编辑器最新内容</span><br><span class="line">    getValue() &#123;</span><br><span class="line">      return this.myEditor.getValue()</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    // 获取缓存的主题设置</span><br><span class="line">    let theme = cache.get(&#x27;theme&#x27;)</span><br><span class="line">    this.theme = theme || this.settings.theme</span><br><span class="line"></span><br><span class="line">    let isRun = cache.get(&#x27;isRun&#x27;)</span><br><span class="line">    this.isRun = isRun == &#x27;true&#x27; ? true : false</span><br><span class="line"></span><br><span class="line">    this.initEditor()</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">@import url(&#x27;//at.alicdn.com/t/font_2401967_3h51xwp68ox.css&#x27;);</span><br><span class="line">* &#123;</span><br><span class="line">  margin: 0;</span><br><span class="line">  padding: 0;</span><br><span class="line">  list-style: none;</span><br><span class="line">  text-decoration: none;</span><br><span class="line">&#125;</span><br><span class="line">html,</span><br><span class="line">body &#123;</span><br><span class="line">  width: 100%;</span><br><span class="line">  height: 100vh;</span><br><span class="line">&#125;</span><br><span class="line">#app &#123;</span><br><span class="line">  width: 100%;</span><br><span class="line">  height: 100%;</span><br><span class="line">&#125;</span><br><span class="line">.topTabs &#123;</span><br><span class="line">  height: 41px;</span><br><span class="line">&#125;</span><br><span class="line">.topTabs-dark &#123;</span><br><span class="line">  background: #3c3c3c !important;</span><br><span class="line">  color: #fff !important;</span><br><span class="line">&#125;</span><br><span class="line">.topTabs-dark .el-tabs--card &gt; .el-tabs__header .el-tabs__nav &#123;</span><br><span class="line">  border: 1px solid #666;</span><br><span class="line">&#125;</span><br><span class="line">.topTabs-dark .el-tabs--card &gt; .el-tabs__header &#123;</span><br><span class="line">  border-bottom: 1px solid #666;</span><br><span class="line">&#125;</span><br><span class="line">.topTabs-dark .el-tabs--card &gt; .el-tabs__header .el-tabs__item &#123;</span><br><span class="line">  color: #ccc;</span><br><span class="line">  border-bottom: 1px solid transparent;</span><br><span class="line">  border-left: 1px solid #333;</span><br><span class="line">&#125;</span><br><span class="line">.topTabs-dark .el-tabs--card &gt; .el-tabs__header .el-tabs__item:hover &#123;</span><br><span class="line">  color: #eee;</span><br><span class="line">&#125;</span><br><span class="line">.topTabs-dark .el-tabs--card &gt; .el-tabs__header .el-tabs__item.is-active &#123;</span><br><span class="line">  border-bottom-color: #666;</span><br><span class="line">  color: #fff;</span><br><span class="line">  background: #555;</span><br><span class="line">&#125;</span><br><span class="line">.editorTools &#123;</span><br><span class="line">  height: 40px;</span><br><span class="line">&#125;</span><br><span class="line">.editorTools-dark &#123;</span><br><span class="line">  background: #3c3c3c !important;</span><br><span class="line">  color: #fff !important;</span><br><span class="line">&#125;</span><br><span class="line">.editorTools .toolItem &#123;</span><br><span class="line">  display: inline-block;</span><br><span class="line">  font-size: 18px;</span><br><span class="line">  height: 40px;</span><br><span class="line">  width: 40px;</span><br><span class="line">  line-height: 40px;</span><br><span class="line">  text-align: center;</span><br><span class="line">  cursor: pointer;</span><br><span class="line">  color: #666;</span><br><span class="line">&#125;</span><br><span class="line">.editorTools-dark .toolItem &#123;</span><br><span class="line">  color: #ccc;</span><br><span class="line">&#125;</span><br><span class="line">.toolItemActive &#123;</span><br><span class="line">  background: #ccc;</span><br><span class="line">&#125;</span><br><span class="line">.editorTools-dark .toolItemActive &#123;</span><br><span class="line">  background: #ccc !important;</span><br><span class="line">  color: #252526 !important;</span><br><span class="line">&#125;</span><br><span class="line">.editorTools &#123;</span><br><span class="line">  text-align: left;</span><br><span class="line">&#125;</span><br><span class="line">.editorTools .toolItem:hover &#123;</span><br><span class="line">  background: #eee;</span><br><span class="line">&#125;</span><br><span class="line">.editorTools-dark .toolItem:hover &#123;</span><br><span class="line">  background: #ccc !important;</span><br><span class="line">  color: #252526 !important;</span><br><span class="line">&#125;</span><br><span class="line">.editorToolsFullPage,</span><br><span class="line">.eidtorContentFullPage &#123;</span><br><span class="line">  z-index: 10;</span><br><span class="line">  position: fixed;</span><br><span class="line">  left: 0;</span><br><span class="line">  width: 100%;</span><br><span class="line">  background: #fff;</span><br><span class="line">&#125;</span><br><span class="line">.editorToolsFullPage &#123;</span><br><span class="line">  top: 0;</span><br><span class="line">  height: 41px;</span><br><span class="line">&#125;</span><br><span class="line">.eidtorContentFullPage &#123;</span><br><span class="line">  top: 41px;</span><br><span class="line">  height: calc(100% - 41px) !important;</span><br><span class="line">&#125;</span><br><span class="line">.storageBox .el-button &#123;</span><br><span class="line">  margin-top: 10px;</span><br><span class="line">&#125;</span><br><span class="line">.eidtorContent &#123;</span><br><span class="line">  height: calc(100% - 81px);</span><br><span class="line">&#125;</span><br><span class="line">.monacoEditor &#123;</span><br><span class="line">  overflow: hidden;</span><br><span class="line">  width: 50%;</span><br><span class="line">  height: 100%;</span><br><span class="line">  display: inline-block;</span><br><span class="line">  vertical-align: top;</span><br><span class="line">&#125;</span><br><span class="line">.monaco-editor &#123;</span><br><span class="line">  height: 100%;</span><br><span class="line">&#125;</span><br><span class="line">.viewIframe &#123;</span><br><span class="line">  vertical-align: top;</span><br><span class="line">  width: 50%;</span><br><span class="line">  height: 100%;</span><br><span class="line">  display: inline-block;</span><br><span class="line">  margin: 0;</span><br><span class="line">  border: none;</span><br><span class="line">&#125;</span><br><span class="line">.el-tabs__nav-scroll &#123;</span><br><span class="line">  user-select: none;</span><br><span class="line">&#125;</span><br><span class="line">.selectModelDialog .el-dialog__body div &#123;</span><br><span class="line">  display: flex;</span><br><span class="line">  justify-content: center;</span><br><span class="line">&#125;</span><br><span class="line">.el-tabs__header &#123;</span><br><span class="line">  margin: 0 !important;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.rotate &#123;</span><br><span class="line">  /* transition: 0.5s; */</span><br><span class="line">  /* transform-origin: 30px 30px; */</span><br><span class="line">  animation: rotate 1s linear infinite; /*开始动画后无限循环，用来控制rotate*/</span><br><span class="line">&#125;</span><br><span class="line">@keyframes rotate &#123;</span><br><span class="line">  0% &#123;</span><br><span class="line">    transform: rotate(0);</span><br><span class="line">  &#125;</span><br><span class="line">  100% &#123;</span><br><span class="line">    transform: rotate(360deg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>webSocket封装</title>
      <link href="/2023/03/01/webSocket%E5%B0%81%E8%A3%85/websocket/"/>
      <url>/2023/03/01/webSocket%E5%B0%81%E8%A3%85/websocket/</url>
      
        <content type="html"><![CDATA[<h2 id="webSocket-封装，重连"><a href="#webSocket-封装，重连" class="headerlink" title="webSocket 封装，重连"></a>webSocket 封装，重连</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// import &#123; getToken &#125; from &#x27;@/utils/authToken&#x27; // 与后端的协商，websocket请求需要带上token参数</span><br><span class="line">let websock = null</span><br><span class="line">let messageCallback = null</span><br><span class="line">let errorCallback = null</span><br><span class="line">let wsUrl = &#x27;&#x27;</span><br><span class="line"></span><br><span class="line">var lockReconnect = false;//避免重复连接</span><br><span class="line">// 接收ws后端返回的数据</span><br><span class="line">function websocketonmessage (e) &#123; </span><br><span class="line"></span><br><span class="line">  messageCallback(e.data)</span><br><span class="line">  heartCheck.reset().start();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * 发起websocket连接</span><br><span class="line"> * @param &#123;Object&#125; agentData 需要向后台传递的参数数据</span><br><span class="line"> */</span><br><span class="line">function websocketSend (agentData) &#123;</span><br><span class="line">  // 加延迟是为了尽量让ws连接状态变为OPEN   </span><br><span class="line">  setTimeout(() =&gt; &#123; </span><br><span class="line">    // 添加状态判断，当为OPEN时，发送消息</span><br><span class="line">    if (websock.readyState === websock.OPEN) &#123; // websock.OPEN = 1 </span><br><span class="line">      // 发给后端的数据需要字符串化</span><br><span class="line">      websock.send(JSON.stringify(agentData))</span><br><span class="line">    &#125;</span><br><span class="line">    if (websock.readyState === websock.CLOSED) &#123; // websock.CLOSED = 3 </span><br><span class="line">      console.log(&#x27;websock.readyState=3&#x27;)</span><br><span class="line">      // Message.error(&#x27;ws连接异常，请稍候重试&#x27;)</span><br><span class="line">      errorCallback()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, 500)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">// 关闭ws连接</span><br><span class="line">function websocketclose (e) &#123;  </span><br><span class="line">  // e.code === 1000  表示正常关闭。 无论为何目的而创建, 该链接都已成功完成任务。</span><br><span class="line">  // e.code !== 1000  表示非正常关闭。</span><br><span class="line">  if (e &amp;&amp; e.code !== 1000) &#123;</span><br><span class="line">    reconnect(wsUrl);    //异常关闭，自动重连</span><br><span class="line">    // Message.error(&#x27;ws连接异常，请稍候重试&#x27;)</span><br><span class="line">    errorCallback(e)</span><br><span class="line">    // // 如果需要设置异常重连则可替换为下面的代码，自行进行测试</span><br><span class="line">    // if (tryTime &lt; 10) &#123;</span><br><span class="line">    //   setTimeout(function() &#123;</span><br><span class="line">    //    websock = null</span><br><span class="line">    //    tryTime++</span><br><span class="line">    //    initWebSocket()</span><br><span class="line">    //    console.log(`第$&#123;tryTime&#125;次重连`)</span><br><span class="line">    //  &#125;, 3 * 1000)</span><br><span class="line">    //&#125; else &#123;</span><br><span class="line">    //  Message.error(&#x27;重连失败！请稍后重试&#x27;)</span><br><span class="line">    //&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 建立ws连接</span><br><span class="line">function websocketOpen (e) &#123;</span><br><span class="line">  // console.log(&#x27;ws连接成功&#x27;)</span><br><span class="line">  heartCheck.reset().start();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">// 初始化weosocket</span><br><span class="line">function initWebSocket () &#123; </span><br><span class="line">  console.log(&#x27;重连重连&#x27;)</span><br><span class="line">  if (typeof (WebSocket) === &#x27;undefined&#x27;) &#123;</span><br><span class="line">    Message.error(&#x27;您的浏览器不支持WebSocket，无法获取数据&#x27;)</span><br><span class="line">    return false</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  // const token = &#x27;JWT=&#x27; + getToken()</span><br><span class="line">  // ws请求完整地址</span><br><span class="line">  const requstWsUrl = wsUrl // .// + &#x27;?&#x27; + token</span><br><span class="line">  websock = new WebSocket(requstWsUrl)</span><br><span class="line"></span><br><span class="line">  websock.onmessage = function (e) &#123;</span><br><span class="line">    websocketonmessage(e)</span><br><span class="line">  &#125; </span><br><span class="line">  websock.onopen = function () &#123;</span><br><span class="line">    </span><br><span class="line">    websocketOpen()</span><br><span class="line">  &#125;</span><br><span class="line">  websock.onerror = function () &#123;</span><br><span class="line">    // Message.error(&#x27;ws连接异常，请稍候重试&#x27;)</span><br><span class="line">    errorCallback()</span><br><span class="line">    reconnect(wsUrl);</span><br><span class="line">  &#125;</span><br><span class="line">  websock.onclose = function (e) &#123;</span><br><span class="line">   </span><br><span class="line">    websocketclose(e)</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * 发起websocket请求函数</span><br><span class="line"> * @param &#123;string&#125; url ws连接地址</span><br><span class="line"> * @param &#123;Object&#125; agentData 传给后台的参数</span><br><span class="line"> * @param &#123;function&#125; successCallback 接收到ws数据，对数据进行处理的回调函数</span><br><span class="line"> * @param &#123;function&#125; errCallback ws连接错误的回调函数</span><br><span class="line"> */</span><br><span class="line">export function sendWebsocket (url,agentData, successCallback, errCallback) &#123; </span><br><span class="line">  wsUrl = url</span><br><span class="line">  initWebSocket()</span><br><span class="line">  messageCallback = successCallback</span><br><span class="line">  errorCallback = errCallback</span><br><span class="line">  websocketSend(agentData)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 关闭websocket函数</span><br><span class="line"> */</span><br><span class="line">export function closeWebsocket () &#123;</span><br><span class="line">  if (websock) &#123;</span><br><span class="line">    websock.close() // 关闭websocket</span><br><span class="line">    websock.onclose() // 关闭websocket</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function reconnect() &#123;</span><br><span class="line">  </span><br><span class="line">    if(lockReconnect) return;</span><br><span class="line">    lockReconnect = true;</span><br><span class="line">    //没连接上会一直重连，设置延迟避免请求过多</span><br><span class="line">    setTimeout(function () &#123;</span><br><span class="line">      </span><br><span class="line">      initWebSocket();</span><br><span class="line">        lockReconnect = false;</span><br><span class="line">    &#125;, 2000);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//心跳检测</span><br><span class="line">var heartCheck = &#123;</span><br><span class="line">    timeout: 6000,//60秒</span><br><span class="line">    timeoutObj: null,</span><br><span class="line">    serverTimeoutObj: null,</span><br><span class="line">    reset: function()&#123;</span><br><span class="line">        clearTimeout(this.timeoutObj);</span><br><span class="line">        clearTimeout(this.serverTimeoutObj);</span><br><span class="line">        return this;</span><br><span class="line">    &#125;,</span><br><span class="line">    start: function()&#123;</span><br><span class="line">        var self = this;</span><br><span class="line">        this.timeoutObj = setTimeout(function()&#123;</span><br><span class="line">            //这里发送一个心跳，后端收到后，返回一个心跳消息，</span><br><span class="line">            //onmessage拿到返回的心跳就说明连接正常</span><br><span class="line">            websock.send(&quot;HeartBeat&quot;);</span><br><span class="line">            self.serverTimeoutObj = setTimeout(function()&#123;//如果超过一定时间还没重置，说明后端主动断开了</span><br><span class="line">              websock.close();//如果onclose会执行reconnect，我们执行ws.close()就行了.如果直接执行reconnect 会触发onclose导致重连两次</span><br><span class="line">            &#125;, self.timeout)</span><br><span class="line">        &#125;, this.timeout)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>webpack</title>
      <link href="/2023/03/01/webpack/webpack/"/>
      <url>/2023/03/01/webpack/webpack/</url>
      
        <content type="html"><![CDATA[<h3 id="webpack-是什么"><a href="#webpack-是什么" class="headerlink" title="webpack 是什么"></a>webpack 是什么</h3><ul><li>Webpack是一个模块打包工具，在Webpack里一切文件皆模块。通过loader转换文件，通过plugin注入钩子，最后输出由多个模块组合的文件。Webpack专注构建模块化项目。</li><li>Webpack可以看作是模块打包机：它做的事情是，分析你的项目结构，找到JavaScript模块以及其他一些不能被浏览器直接运行的扩展语音(如：Scss,TypeScript等)，并将其打包为合适的格式以供浏览器使用。</li></ul><h3 id="Webpack的构建流程是怎么样的？"><a href="#Webpack的构建流程是怎么样的？" class="headerlink" title="Webpack的构建流程是怎么样的？"></a>Webpack的构建流程是怎么样的？</h3><p>Webpack的运行流程是一个串行的过程，从启动到结束会依次执行以下步骤：</p><ul><li>初始化参数：从配置文件和shell语句中读取与合并参数，得到最终参数；</li><li>开始编译：用上一步得到的参数初始化Compiler对象，加载所有配置的插件，执行对象的run方法开始执行编译；</li><li>确定入口：根据配置中的entry找出所有的入口文件；</li><li>编译模块：从入口文件出发，调用所有配置的loader对模块进行编译。再找出该模块依赖的模块，再递归本步骤，直到所有入口依赖的文件都经过本步骤的处理；</li><li>完成模块编译：在经过第四个步骤使用loader编译完所有模块后，得到每个模块被编译后的最终内容以及它们之间的依赖关系；</li><li>输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的Chunk，再把每个Chunk转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会；</li><li>输出完成：在确认好输出内容后，根据配置确定输出的路径和文件名，把文件内容写进到文件系统中；<br>在以上过程中，Webpack会在特定的的时间点广播特定的事件，插件在监听到感兴趣的事件后会执行特定的逻辑。并且插件可以调用Webpack提供的API改变Webpack的运行结果。<h3 id="分别介绍bundle，chunk，module是什么？"><a href="#分别介绍bundle，chunk，module是什么？" class="headerlink" title="分别介绍bundle，chunk，module是什么？"></a>分别介绍bundle，chunk，module是什么？</h3></li></ul><ul><li>bundle：由Webpack打包出来的文件</li><li>chunk：代码块，webpack在进行模块的依赖分析的时候，代码分割出来的代码块</li><li>module：是开发中的单个模块，在Webpack中，一切皆模块，一个模块对应一个文件<h3 id="什么是Loader-什么是Plugin"><a href="#什么是Loader-什么是Plugin" class="headerlink" title="什么是Loader?什么是Plugin?"></a>什么是Loader?什么是Plugin?</h3></li><li>loader: 模块转换器，用于对模块的源代码进行转换</li><li>plugin: 自定义webpack打包过程的方式，插件含有apply属性的JavaScript对象，apply属性会被webpack compiler调用，并且compiler对象可以在整个编译生命周期内访问<h3 id="loader和plugin有哪些不同？"><a href="#loader和plugin有哪些不同？" class="headerlink" title="loader和plugin有哪些不同？"></a>loader和plugin有哪些不同？</h3><h4 id="不同的作用"><a href="#不同的作用" class="headerlink" title="不同的作用"></a>不同的作用</h4>loader直译为“加载器”，Webpack将一切文件视为模块，但是Webpack原生只能解析JavaScript和JSON类型文件。如果想加载解析其他类型文件，就会用到loader。所以loader是让Webpack拥有加载和解析非JavaScript文件的能力<br>plugin直译为”插件“，plugin可以扩展Webpack的功能，让Webpack具有更多的灵活性。在Webpack运行的生命周期中会广播许多事件，plugin可以监听这些事件，在合适的时机通过Webpack提供的API改变输出结果<h4 id="不同的用法"><a href="#不同的用法" class="headerlink" title="不同的用法"></a>不同的用法</h4>loader在module rules中配置，也就说它作为模块解析规则存在。类型为Array，每一项都是一个Object，里面描述了什么类型的文件(test)，使用什么加载(loader)和使用的参数(options)<br>plugin单独在plugins中单独配置。类型为Array，每项都是一个plugin的实例，参数是通过构造函数传入<h3 id="有哪些常见的Loader？"><a href="#有哪些常见的Loader？" class="headerlink" title="有哪些常见的Loader？"></a>有哪些常见的Loader？</h3>file-loader: 将文件输出到一个文件夹中，在代码中通过相对路径(url)去引用输出的文件<br>url-loader: 和file-loader类似，但是能在文件很小的情况下，以base64的方式将内容注入到代码中<br>image-loader: 加载并压缩图片文件<br>babel-lodader: 将ES6转成ES5<br>css-loader: 加载CSS，支持模块化/压缩/文件导入等特性<br>style-loader：把CSS代码注入到JavaScript中，通过DOM操作去加载CSS<br>eslint-loader: 通过ESlint检查JavaScript代码<h3 id="有哪些常见的Plugin？"><a href="#有哪些常见的Plugin？" class="headerlink" title="有哪些常见的Plugin？"></a>有哪些常见的Plugin？</h3>define-plugin: 定义环境变量<br>html-webpack-pulgin: 生成创建html入口文件，并引用对应的外部资源<br>uglifyjs-plugin: 通过Uglifyjs压缩JavaScript代码<br>mini-css-extract-plugin: 分离CSS文件<br>clean-webpack-plugin: 删除打包文件<br>happypack: 实现多线程加速编译</li></ul>]]></content>
      
      
      <categories>
          
          <category> webpack </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue.js 源码解读,</title>
      <link href="/2023/03/01/vue%E6%BA%90%E7%A0%81%E5%90%8D%E8%AF%8D/"/>
      <url>/2023/03/01/vue%E6%BA%90%E7%A0%81%E5%90%8D%E8%AF%8D/</url>
      
        <content type="html"><![CDATA[<h3 id="虚拟-DOM"><a href="#虚拟-DOM" class="headerlink" title="虚拟 DOM"></a>虚拟 DOM</h3><ul><li>什么是虚拟 DOM<br>所谓的虚拟 DOM ,就是一个 js 对象来描述一个 DOM 节点。<br>我们把组成一个 DOM 节点的必要东西通过一个 JS 对象表示出来，那么这个 JS 对象就可以用来描述 DOM 节点，我们把这个 JS 对象就称为是这个真实 DOM 节点的虚拟 DOM 节点。</li><li>为什么要有虚拟 DOM<br>vue 是数据驱动视图的，数据发生变化视图就要随之更新，随之就要操作 DOM,操作 DOM 又是非常耗费性能。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Vue.js 源码解读 </category>
          
          <category> 名词 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue 的理解</title>
      <link href="/2023/03/01/vue%E7%9A%84%E7%90%86%E8%A7%A3/"/>
      <url>/2023/03/01/vue%E7%9A%84%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="变化侦测"><a href="#变化侦测" class="headerlink" title="变化侦测"></a>变化侦测</h1><h2 id="对象的单个属性值实现可观测"><a href="#对象的单个属性值实现可观测" class="headerlink" title="对象的单个属性值实现可观测"></a>对象的单个属性值实现可观测</h2><p>通过 Object.defineProperty 实现对象数据变化的 可观测</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">let car = &#123;</span><br><span class="line">   price:3000</span><br><span class="line">&#125;</span><br><span class="line">let val = 3000</span><br><span class="line">Object.defineProperty(car, &#x27;price&#x27;, &#123;</span><br><span class="line">  enumerable: true,</span><br><span class="line">  configurable: true,</span><br><span class="line">  get()&#123;</span><br><span class="line">    console.log(&#x27;price属性被读取了&#x27;)</span><br><span class="line">    return val</span><br><span class="line">  &#125;,</span><br><span class="line">  set(newVal)&#123;</span><br><span class="line">    console.log(&#x27;price属性被修改了&#x27;)</span><br><span class="line">    val = newVal</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="使对象的所有属性变的可观测"><a href="#使对象的所有属性变的可观测" class="headerlink" title="使对象的所有属性变的可观测"></a>使对象的所有属性变的可观测</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Observer类会通过递归的方式把一个对象的所有属性都转化成可观测对象</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">export class Observer &#123;</span><br><span class="line">  constructor (value) &#123;</span><br><span class="line">    this.value = value</span><br><span class="line">    // 给value新增一个__ob__属性，值为该value的Observer实例</span><br><span class="line">    // 相当于为value打上标记，表示它已经被转化成响应式了，避免重复操作</span><br><span class="line">    def(value,&#x27;__ob__&#x27;,this)</span><br><span class="line">    if (Array.isArray(value)) &#123;</span><br><span class="line">      // 当value为数组时的逻辑</span><br><span class="line">      // ...</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      this.walk(value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  walk (obj: Object) &#123;</span><br><span class="line">    const keys = Object.keys(obj)</span><br><span class="line">    for (let i = 0; i &lt; keys.length; i++) &#123;</span><br><span class="line">      defineReactive(obj, keys[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 使一个对象转化成可观测对象</span><br><span class="line"> * @param &#123; Object &#125; obj 对象</span><br><span class="line"> * @param &#123; String &#125; key 对象的key</span><br><span class="line"> * @param &#123; Any &#125; val 对象的某个key的值</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">function defineReactive (obj,key,val) &#123; // 将传进来的某个属性变成可侦测的</span><br><span class="line">  // 如果只传了obj和key，那么val = obj[key]</span><br><span class="line">  if (arguments.length === 2) &#123;</span><br><span class="line">    val = obj[key]</span><br><span class="line">  &#125;</span><br><span class="line">  if(typeof val === &#x27;object&#x27;)&#123;</span><br><span class="line">    new Observer(val)</span><br><span class="line">  &#125;</span><br><span class="line">  Object.defineProperty(obj, key, &#123;</span><br><span class="line">    enumerable: true,</span><br><span class="line">    configurable: true,</span><br><span class="line">    get()&#123;</span><br><span class="line">      console.log(`$&#123;key&#125;属性被读取了`);</span><br><span class="line">      return val;</span><br><span class="line">    &#125;,</span><br><span class="line">    set(newVal)&#123;</span><br><span class="line">      if(val === newVal)&#123;</span><br><span class="line">          return</span><br><span class="line">      &#125;</span><br><span class="line">      console.log(`$&#123;key&#125;属性被修改了`);</span><br><span class="line">      val = newVal;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过定义了 Observer 类，将一个正常的 object 转换成可观测的 object<br>并且给 value 增加 <code>__ob__</code> 属性值为该 value 的 Observer 实例。 该操作相当于是为 value 打上一个标志，标识已经转换成响应式了，避免重复操作。<br>然后判断数据的类型：(数组和对象的数据监测方式不一样，数组是通过修改数组的操作方法来实现数据变化的监测) object 类型的数据调用 walk 将每一个属性转换成 getter/setter 的形式来侦测变化，当 defineReactive 中当传入的属性值还是一个 object 时使用 new observer（val）来递归子属性，这样我们就可以把 obj 中的所有属性（包括子属性）都转换成 getter/seter 的形式来侦测变化。</p><p>通过一个 observer 类，我们将一个对象传入到里面，这个对象就变成可观测的。</p><h2 id="收集依赖"><a href="#收集依赖" class="headerlink" title="收集依赖"></a>收集依赖</h2><h3 id="为什么要有收集依赖"><a href="#为什么要有收集依赖" class="headerlink" title="为什么要有收集依赖"></a>为什么要有收集依赖</h3><p>数据变的可观测以后，我们知道数据什么时候发生了变化，当数据变化时，通知视图更新。但是我们不知道该通知谁去发生变化，但是也不能一个数据变化，就整个视图就更新。</p><p>解决思路: 就是对每个数据建立一个依赖数组，谁依赖了这个数据，就把谁放入到这个依赖数组中，当该数据发生变化的时候，就去对应的依赖数组，通知数组中的依赖，更新。</p><p>什么时候收集依赖?什么时候通知依赖更新？</p><p><code>在 getter中收集依赖，在setter中通知依赖更新</code>。</p><h3 id="依赖收集的地方"><a href="#依赖收集的地方" class="headerlink" title="依赖收集的地方"></a>依赖收集的地方</h3><p>创建依赖管理器 <code>Dep</code> 类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">export default class Dep &#123;</span><br><span class="line">  constructor () &#123;</span><br><span class="line">    this.subs = []</span><br><span class="line">  &#125;</span><br><span class="line">  addSub (sub) &#123;</span><br><span class="line">    this.subs.push(sub)</span><br><span class="line">  &#125;</span><br><span class="line">  // 删除一个依赖</span><br><span class="line">  removeSub (sub) &#123;</span><br><span class="line">    remove(this.subs,sub)</span><br><span class="line">  &#125;</span><br><span class="line">  // 添加一个依赖</span><br><span class="line">  depend () &#123;</span><br><span class="line">    if (window.target) &#123;</span><br><span class="line">      this.addSub(window.target)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // 通知所有的依赖更新</span><br><span class="line">  notify () &#123;</span><br><span class="line">    const subs = this.subs.slice()</span><br><span class="line">    for (let i = 0, l = subs.length; i&lt;l; i++) &#123;</span><br><span class="line">      subs[i].update()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * Remove an item from an array</span><br><span class="line"> */</span><br><span class="line">export function remove (arr, item) &#123;</span><br><span class="line">  if (arr.length) &#123;</span><br><span class="line">    const index = arr.indexOf(item)</span><br><span class="line">    if (index &gt; -1) &#123;</span><br><span class="line">      return arr.splice(index, 1)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了 Dep 类依赖收集，可以在 getter 中收集依赖，在 setter 中通知依赖更新</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">function defineReactive (obj,key,val) &#123;</span><br><span class="line">  if (arguments.length === 2) &#123;</span><br><span class="line">    val = obj[key]</span><br><span class="line">  &#125;</span><br><span class="line">  if(typeof val === &#x27;object&#x27;)&#123;</span><br><span class="line">    new Observer(val)</span><br><span class="line">  &#125;</span><br><span class="line">  const dep = new Dep()  //实例化一个依赖管理器，生成一个依赖管理数组dep</span><br><span class="line">  Object.defineProperty(obj, key, &#123;</span><br><span class="line">    enumerable: true,</span><br><span class="line">    configurable: true,</span><br><span class="line">    get()&#123;</span><br><span class="line">      dep.depend()    // 在getter中收集依赖</span><br><span class="line">      return val;</span><br><span class="line">    &#125;,</span><br><span class="line">    set(newVal)&#123;</span><br><span class="line">      if(val === newVal)&#123;</span><br><span class="line">          return</span><br><span class="line">      &#125;</span><br><span class="line">      val = newVal;</span><br><span class="line">      dep.notify()   // 在setter中通知依赖更新</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="我们所说的依赖到底是谁"><a href="#我们所说的依赖到底是谁" class="headerlink" title="我们所说的依赖到底是谁"></a>我们所说的依赖到底是谁</h3><p>我们说 <code>谁用到了这个数据谁就是依赖</code>，在代码上的体现，在 vue 中还有一个 Watcher 类，这个 <code>Watcher</code> 就是我们所说的 <code>谁</code>。<br>谁用到了数据，谁就是依赖，我们就为谁创建一个 Watcher 实例。之后当数据发生变化的时，我们不直接通知依赖跟新，而是通知依赖对应的 Watch 实例，由 Watcher 实例去通知真正的视图。<br>Watcher 类的具体实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">export default class Watcher &#123;</span><br><span class="line">  constructor (vm,expOrFn,cb) &#123;</span><br><span class="line">    this.vm = vm;</span><br><span class="line">    this.cb = cb;</span><br><span class="line">    this.getter = parsePath(expOrFn)</span><br><span class="line">    this.value = this.get()</span><br><span class="line">  &#125;</span><br><span class="line">  get () &#123;</span><br><span class="line">    window.target = this;</span><br><span class="line">    const vm = this.vm</span><br><span class="line">    let value = this.getter.call(vm, vm)</span><br><span class="line">    window.target = undefined;</span><br><span class="line">    return value</span><br><span class="line">  &#125;</span><br><span class="line">  update () &#123;</span><br><span class="line">    const oldValue = this.value</span><br><span class="line">    this.value = this.get()</span><br><span class="line">    this.cb.call(this.vm, this.value, oldValue)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Parse simple path.</span><br><span class="line"> * 把一个形如&#x27;data.a.b.c&#x27;的字符串路径所表示的值，从真实的data对象中取出来</span><br><span class="line"> * 例如：</span><br><span class="line"> * data = &#123;a:&#123;b:&#123;c:2&#125;&#125;&#125;</span><br><span class="line"> * parsePath(&#x27;a.b.c&#x27;)(data)  // 2</span><br><span class="line"> */</span><br><span class="line">const bailRE = /[^\w.$]/</span><br><span class="line">export function parsePath (path) &#123;</span><br><span class="line">  if (bailRE.test(path)) &#123;</span><br><span class="line">    return</span><br><span class="line">  &#125;</span><br><span class="line">  const segments = path.split(&#x27;.&#x27;)</span><br><span class="line">  return function (obj) &#123;</span><br><span class="line">    for (let i = 0; i &lt; segments.length; i++) &#123;</span><br><span class="line">      if (!obj) return</span><br><span class="line">      obj = obj[segments[i]]</span><br><span class="line">    &#125;</span><br><span class="line">    return obj</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在创建 Watcher 实例的过程中会自动的把自己添加到这个数据对应的依赖管理器中，以后这个 Watcher 实例就代表这个依赖，当数据变化时，我们就通知 Watcher 实例，由 Watcher 实例再去通知真正的依赖。</p><p>Watcher 类实现的逻辑</p><ul><li><p>当实例化 Watcher 类时，会先执行其构造函数；</p></li><li><p>在构造函数中调用了 this.get()实例方法；</p></li><li><p>在 get()方法中，首先通过 window.target = this 把实例自身赋给了全局的一个唯一对象 window.target 上，然后通过 let value = this.getter.call(vm, vm)获取一下被依赖的数据，获取被依赖数据的目的是触发该数据上面的 getter，上文我们说过，在 getter 里会调用 dep.depend()收集依赖，而在 dep.depend()中取到挂载 window.target 上的值并将其存入依赖数组中，在 get()方法最后将 window.target 释放掉。</p></li><li><p>而当数据变化时，会触发数据的 setter，在 setter 中调用了 dep.notify()方法，在 dep.notify()方法中，遍历所有依赖(即 watcher 实例)，执行依赖的 update()方法，也就是 Watcher 类中的 update()实例方法，在 update()方法中调用数据变化的更新回调函数，从而更新视图。</p></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>1、我们通过 Object.defineProperty 实现了对 Object 数据的可观测，并且封装成 Observer 类，我们能够方便的把 Object 数据中的所有属性(子属性)转换成 getter/setter 的形式来侦测变化。</p><p>2、依赖收集，在 getter 中收集依赖，在 setter 中通知依赖跟新，依赖收集封装成一个 Dep 类。用于存储收集的依赖。</p><p>3、我们为每一个依赖创建一个 Watcher 实例，当数据发生变化的时候，通知 Watcher 实例，由 Watcher 实例去做真实的更新操作</p><ul><li>Data 通过 observer 转换成了 getter/setter 的形式来追踪变化。</li><li>当外界通过 Watcher 读取数据时，会触发 getter 从而将 Watcher 添加到依赖中。</li><li>当数据发生了变化时，会触发 setter，从而向 Dep 中的依赖（即 Watcher）发送通知。</li><li>Watcher 接收到通知后，会向外界发送通知，变化通知到外界后可能会触发视图更新，也有可能触发用户的某个回调函数等</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue.js 源码解读, 更新子节点</title>
      <link href="/2023/03/01/vue%E6%BA%90%E7%A0%813/"/>
      <url>/2023/03/01/vue%E6%BA%90%E7%A0%813/</url>
      
        <content type="html"><![CDATA[<h2 id="更新子节点"><a href="#更新子节点" class="headerlink" title="更新子节点"></a>更新子节点</h2><p>当新的 VNode 与旧的 oldVNode 都是元素节点并且都包含子节点时，那么这两个节点的 VNode 实例上的 children 属性就是所包含的子节点数组。我们把新的 VNode 上的子节点数组记为 newChildren，把旧的 oldVNode 上的子节点数组记为 oldChildren，我们把 newChildren 里面的元素与 oldChildren 里的元素一一进行对比，对比两个子节点数组肯定是要通过循环，外层循环 newChildren 数组，内层循环 oldChildren 数组，每循环外层 newChildren 数组里的一个子节点，就去内层 oldChildren 数组里找看有没有与之相同的子节点</p><p>以上这个过程存在四种情况: 创建子节点、删除字节点、移动子节点、更新节点。</p><h2 id="创建子节点"><a href="#创建子节点" class="headerlink" title="创建子节点"></a>创建子节点</h2><p>newChildren 里面的某个子节点在 oldChildren 里找不到与之相同的子节点，说明 newChildren 里面的这个子节点是之前没有的，是需要此次新增的节点，创建这个节点，创建之后把它插入到 DOM 中合适的位置。</p><p><img src="https://vue-js.com/learn-vue/assets/img/4.cb62f1aa.png" alt="avatar"></p><h2 id="删除子节点"><a href="#删除子节点" class="headerlink" title="删除子节点"></a>删除子节点</h2><p>把 newChildren 里面的每一个子节点都循环一遍，能在 oldChildren 数组里找到的就处理它，找不到的就新增，直到把 newChildren 里面所有子节点都遍历一遍后，发现 oldChildren 还存在未处理的子节点，说明未处理的子节点是需要被废弃的，那么就将这些节点删除。</p><h2 id="更新子节点-1"><a href="#更新子节点-1" class="headerlink" title="更新子节点"></a>更新子节点</h2><p>如果 newChildren 里面的某个子节点在 oldChildren 里找到与之相同的子节点，并且所处的位置也相同，那么就更新 oldChildren 里该节点使之与 newChildren 里的该节点相同。</p><h2 id="移动子节点"><a href="#移动子节点" class="headerlink" title="移动子节点"></a>移动子节点</h2><p>如果 newChildren 里面的某个子节点在 oldChildren 里找到与之相同的子节点，但是所处的位置不同，则此次变化需要调整该子节点的位置，以 newChildren 的位置为准，调整 oldChildren 里改节点的位置。</p><p><img src="https://vue-js.com/learn-vue/assets/img/6.b9621b4d.png" alt="avatar"></p><p>在上图中，绿色的两个节点是相同节点但是所处位置不同，按照上面所说的，我们应该以 newChildren 里子节点的位置为基准，调整 oldChildren 里该节点的位置，所以我们应该把真实 DOM 即 oldChildren 里面的第四个节点移动到第三个节点的位置</p><h2 id="更新子节点的优化"><a href="#更新子节点的优化" class="headerlink" title="更新子节点的优化"></a>更新子节点的优化</h2><p>根据之前的跟新逻辑，可以解决问题，存在可以优化的地方。如果当包含的子节点数量很多时，循环算法的时间复杂度会变的很大，不利于性能的提升。</p><h3 id="优化策略"><a href="#优化策略" class="headerlink" title="优化策略"></a>优化策略</h3><p>我们不按照顺序去循环 newChildren 和 oldChildren 这两个数组，可以先比较这两个数组里特殊位置的子节点。</p><ul><li>新前与旧前<br>先把 newChildren 数组里面的所有未处理子节点的第一个和 oldChildren 数组里面所有未处理子节点的第一个做对比，如果相同，就直接进入更新子节点的操作。</li></ul><p><img src="https://vue-js.com/learn-vue/assets/img/9.e017b452.png" alt="avatar"></p><ul><li>新后与旧后<br>把 newChildren 数组里面的所有未处理子节点的最后一个和 oldChildren 数组里面所有未处理子节点的最后一个做对比，如果相同，就直接进入更新子节点的操作。</li></ul><p><img src="https://vue-js.com/learn-vue/assets/img/10.cf98adc0.png" alt="avatar"></p><ul><li>新后与旧前<br>把 newChildren 数组里面的所有未处理子节点的最后一个和 oldChildren 数组里面所有未处理子节点的第一个做对比，如果相同，就直接进入更新子节点的操作，更新完成后再将 oldChildren 数组里的该节点移动到与 newChildren 数组节点相同的位置。</li></ul><p><img src="https://vue-js.com/learn-vue/assets/img/12.bace2f7f.png" alt="avatar"></p><ul><li>新前与旧后<br>把 newChildren 数组里面的所有未处理子节点的第一个和 oldChildren 数组里面所有未处理子节点的最后一个做对比，如果相同，就直接进入更新子节点的操作，更新完成后再将 oldChildren 数组里的该节点移动到与 newChildren 数组节点相同的位置。</li></ul><p><img src="https://vue-js.com/learn-vue/assets/img/14.18c1c6dd.png" alt="avatar"></p>]]></content>
      
      
      <categories>
          
          <category> Vue.js 源码解读 </category>
          
          <category> 虚拟DOM </category>
          
          <category> 更新子节点 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue.js 源码解读, 模板编译</title>
      <link href="/2023/03/01/vue%E6%BA%90%E7%A0%814/"/>
      <url>/2023/03/01/vue%E6%BA%90%E7%A0%814/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是模板编译"><a href="#什么是模板编译" class="headerlink" title="什么是模板编译"></a>什么是模板编译</h2><p><code>Vue</code> 会把用户在<code>&lt;template&gt;&lt;/template&gt;</code>标签中写的类似于原生 HTML 的内容进行编译，把原生 HTML 的内容找出来，再把非原生 HTML 找出来，经过一系列的逻辑处理生成渲染函数，也就是 render 函数，而 render 函数会将模板内容生成对应的 VNode，而 VNode 再经过前几篇文章介绍的 patch 过程从而得到将要渲染的视图中的 VNode，最后根据 VNode 创建真实的 DOM 节点并插入到视图中， 最终完成视图的渲染更新。<br>而把用户在<template></template>标签中写的类似于原生 HTML 的内容进行编译，把原生 HTML 的内容找出来，再把非原生 HTML 找出来，经过一系列的逻辑处理生成渲染函数，也就是 render 函数的这一段过程称之为模板编译过程。</p><h2 id="整体渲染流程"><a href="#整体渲染流程" class="headerlink" title="整体渲染流程"></a>整体渲染流程</h2><p>渲染流程，就是把用户写的类似于原生 HTML 的模板经过一系列处理最终反应到视图中称之为整个渲染流程。</p><p><img src="https://vue-js.com/learn-vue/assets/img/1.f0570125.png" alt="渲染流程"></p><h2 id="模板编译内部流程"><a href="#模板编译内部流程" class="headerlink" title="模板编译内部流程"></a>模板编译内部流程</h2><h3 id="抽象语法树-AST"><a href="#抽象语法树-AST" class="headerlink" title="抽象语法树 AST"></a>抽象语法树 AST</h3><p>抽象语法树，在计算机科学中，抽象语法树（AbstractSyntaxTree，AST），或简称语法树（Syntax tree），是源代码语法结构的一种抽象表示。它以树状的形式表现编程语言的语法结构，树上的每个节点都表示源代码中的一种结构。之所以说语法是“抽象”的，是因为这里的语法并不会表示出真实语法中出现的每个细节。</p><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p>分为三个阶段:</p><ul><li>模板解析阶段:将一堆模板字符串用正则等方式解析成抽象语法树 AST</li><li>优化阶段: 遍历 AST ,找出其中的静态节点, 并打上标记;</li><li>代码生成阶段：将 AST 转换成渲染函数;</li></ul><p><img src="https://vue-js.com/learn-vue/assets/img/3.15d9566b.png" alt="模板内部流程图"></p>]]></content>
      
      
      <categories>
          
          <category> Vue.js 源码解读 </category>
          
          <category> 模板编译 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue.js 源码解读,</title>
      <link href="/2023/03/01/vue%E6%BA%90%E7%A0%816/"/>
      <url>/2023/03/01/vue%E6%BA%90%E7%A0%816/</url>
      
        <content type="html"><![CDATA[<h2 id="初始化-initState-函数"><a href="#初始化-initState-函数" class="headerlink" title="初始化 initState 函数"></a>初始化 initState 函数</h2><p>该函数是用来初始化实例状态的，例如：props、 data、 methods 、computed 、watch</p><h3 id="initState-函数分析"><a href="#initState-函数分析" class="headerlink" title="initState 函数分析"></a>initState 函数分析</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">export function initState (vm: Component) &#123;</span><br><span class="line">  vm._watchers = []</span><br><span class="line">  const opts = vm.$options</span><br><span class="line">  if (opts.props) initProps(vm, opts.props)</span><br><span class="line">  if (opts.methods) initMethods(vm, opts.methods)</span><br><span class="line">  if (opts.data) &#123;</span><br><span class="line">    initData(vm)</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    observe(vm._data = &#123;&#125;, true /* asRootData */)</span><br><span class="line">  &#125;</span><br><span class="line">  if (opts.computed) initComputed(vm, opts.computed)</span><br><span class="line">  if (opts.watch &amp;&amp; opts.watch !== nativeWatch) &#123;</span><br><span class="line">    initWatch(vm, opts.watch)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>代码分析</p><ul><li><p>首先给实例增加一个属性 _watchers,用来存储当前实例中所有的 watcher 实例，无论是使用 vm.$watch 注册的 watcher 实例还是使用 watch 选项注册的 watcher 实例，都会保存到该属性中。</p></li><li><p>先判断实例中是否有 props 选项，如果有，就调用 props 选项初始化函数 initProps 去初始化 props 选项。</p></li><li><p>再判断实例中是否有 methods 选项，如果有，就调用 methods 选项初始化函数 initMethods 去初始化 methods 选项；</p></li><li><p>接着再判断实例中是否有 data 选项，如果有，就调用 data 选项初始化函数 initData 去初始化 data 选项；如果没有，就把 data 当作空对象并将其转换成响应式；</p></li><li><p>接着再判断实例中是否有 computed 选项，如果有，就调用 computed 选项初始化函数 initComputed 去初始化 computed 选项；</p></li><li><p>最后判断实例中是否有 watch 选项，如果有，就调用 watch 选项初始化函数 initWatch 去初始化 watch 选项；</p></li></ul></li></ul><h3 id="初始化-props"><a href="#初始化-props" class="headerlink" title="初始化 props"></a>初始化 props</h3><p>props 选项通常是由当前组件的父级组件传入的，当父组件在调用子组件的时候，通常会把 props 属性值作为标签属性添加到子组件的标签上。<br>在模板编译的时候，当解析到组件标签的时会将所有的标签属性都解析出来然后在子组件实例化的时候给子组件。(props 数据包含其中)</p><h4 id="规范化数据"><a href="#规范化数据" class="headerlink" title="规范化数据"></a>规范化数据</h4><p>vue 给用户提供的 props 选项写法非常自由，根据 vue 的惯例，写法虽然有多种但是最终处理的时候肯定只处理一种写法，处理之前先对数据进行规范化，将所有写法都转化成一种写法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">function normalizeProps (options, vm) &#123;</span><br><span class="line">  const props = options.props</span><br><span class="line">  if (!props) return</span><br><span class="line">  const res = &#123;&#125;</span><br><span class="line">  let i, val, name</span><br><span class="line">  if (Array.isArray(props)) &#123;</span><br><span class="line">    i = props.length</span><br><span class="line">    while (i--) &#123;</span><br><span class="line">      val = props[i]</span><br><span class="line">      if (typeof val === &#x27;string&#x27;) &#123;</span><br><span class="line">        name = camelize(val)</span><br><span class="line">        res[name] = &#123; type: null &#125;</span><br><span class="line">      &#125; else if (process.env.NODE_ENV !== &#x27;production&#x27;) &#123;</span><br><span class="line">        warn(&#x27;props must be strings when using array syntax.&#x27;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else if (isPlainObject(props)) &#123;</span><br><span class="line">    for (const key in props) &#123;</span><br><span class="line">      val = props[key]</span><br><span class="line">      name = camelize(key)</span><br><span class="line">      res[name] = isPlainObject(val)</span><br><span class="line">        ? val</span><br><span class="line">        : &#123; type: val &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else if (process.env.NODE_ENV !== &#x27;production&#x27;) &#123;</span><br><span class="line">    warn(</span><br><span class="line">      `Invalid value for option &quot;props&quot;: expected an Array or an Object, ` +</span><br><span class="line">      `but got $&#123;toRawType(props)&#125;.`,</span><br><span class="line">      vm</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">  options.props = res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>代码分析<ul><li>首先拿到实例中的 props 选项，如果不存在，则直接返回。</li><li>判断如果是 props: [‘name’] 这样的写法，则遍历数组中的每一项元素，如果该元素是字符串，将该元素统一转化成驼峰式命名，然后将该元素作为 key，将 {type:null} 作为 value 存入 res 中;如果该元素不是字符串，则抛出异常。</li><li>判断如果不是数组，则判断是不是对象，如果是对象，那就遍历对象中的每一对键值，拿到每一对键值后，将键名统一转化成驼峰式命名，然后判断值是否还是一个对象，如果还是一个对象，那么将该键值对存入 res 中；如果值不是对象，那么就将键名作为 key,将 {type:null} 作为 value 存入 res 中。</li></ul></li></ul><h4 id="initProps-函数分析"><a href="#initProps-函数分析" class="headerlink" title="initProps 函数分析"></a>initProps 函数分析</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">function initProps (vm: Component, propsOptions: Object) &#123;</span><br><span class="line">  const propsData = vm.$options.propsData || &#123;&#125;</span><br><span class="line">  const props = vm._props = &#123;&#125;</span><br><span class="line">  // cache prop keys so that future props updates can iterate using Array</span><br><span class="line">  // instead of dynamic object key enumeration.</span><br><span class="line">  const keys = vm.$options._propKeys = []</span><br><span class="line">  const isRoot = !vm.$parent</span><br><span class="line">  // root instance props should be converted</span><br><span class="line">  if (!isRoot) &#123;</span><br><span class="line">    toggleObserving(false)</span><br><span class="line">  &#125;</span><br><span class="line">  for (const key in propsOptions) &#123;</span><br><span class="line">    keys.push(key)</span><br><span class="line">    const value = validateProp(key, propsOptions, propsData, vm)</span><br><span class="line">    /* istanbul ignore else */</span><br><span class="line">    if (process.env.NODE_ENV !== &#x27;production&#x27;) &#123;</span><br><span class="line">      const hyphenatedKey = hyphenate(key)</span><br><span class="line">      if (isReservedAttribute(hyphenatedKey) ||</span><br><span class="line">          config.isReservedAttr(hyphenatedKey)) &#123;</span><br><span class="line">        warn(</span><br><span class="line">          `&quot;$&#123;hyphenatedKey&#125;&quot; is a reserved attribute and cannot be used as component prop.`,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">      defineReactive(props, key, value, () =&gt; &#123;</span><br><span class="line">        if (vm.$parent &amp;&amp; !isUpdatingChildComponent) &#123;</span><br><span class="line">          warn(</span><br><span class="line">            `Avoid mutating a prop directly since the value will be ` +</span><br><span class="line">            `overwritten whenever the parent component re-renders. ` +</span><br><span class="line">            `Instead, use a data or computed property based on the prop&#x27;s ` +</span><br><span class="line">            `value. Prop being mutated: &quot;$&#123;key&#125;&quot;`,</span><br><span class="line">            vm</span><br><span class="line">          )</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      defineReactive(props, key, value)</span><br><span class="line">    &#125;</span><br><span class="line">    // static props are already proxied on the component&#x27;s prototype</span><br><span class="line">    // during Vue.extend(). We only need to proxy props defined at</span><br><span class="line">    // instantiation here.</span><br><span class="line">    if (!(key in vm)) &#123;</span><br><span class="line">      proxy(vm, `_props`, key)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  toggleObserving(true)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>代码分析<ul><li>该函数接收两个参数：当前 Vue 实例和当前实例规范化后的 props 选项。</li><li>函数内部定义四个变量<ul><li>propsData:父组件传入的真实 props 数据。</li><li>props: 指向 vm._props 的指针，所有设置到 props 变量中的属性都会保存到 vm._props 中。</li><li>keys:指向 vm.$options._propKeys 的指针，缓存 props 对象中的 key,将来更新 props 时只需遍历 vm.$options._propKeys 数组即可得多所有 props 的 key .</li><li>isRoot:当前组件是否为根组件。</li></ul></li><li>判断当前组件是否为根组件，如果不是不需要将 props 数组转换成响应式的，toggleObserving(false) 用来控制是否将数据转换成响应式。</li><li>遍历 props 选项拿到每一对键值，先将键名添加到 keys 中然后调用 validateProp 函数校验父组件传入的 props 数据类型是否匹配并获取到传入的值 value, 然后通过将键名和值通过 defineReactive 函数添加到 props (即 vm._props)中。</li></ul></li></ul><h4 id="validateProp-函数分析"><a href="#validateProp-函数分析" class="headerlink" title="validateProp 函数分析"></a>validateProp 函数分析</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">export function validateProp (key,propOptions,propsData,vm) &#123;</span><br><span class="line">  const prop = propOptions[key]</span><br><span class="line">  const absent = !hasOwn(propsData, key)</span><br><span class="line">  let value = propsData[key]</span><br><span class="line">  // boolean casting</span><br><span class="line">  const booleanIndex = getTypeIndex(Boolean, prop.type)</span><br><span class="line">  if (booleanIndex &gt; -1) &#123;</span><br><span class="line">    if (absent &amp;&amp; !hasOwn(prop, &#x27;default&#x27;)) &#123;</span><br><span class="line">      value = false</span><br><span class="line">    &#125; else if (value === &#x27;&#x27; || value === hyphenate(key)) &#123;</span><br><span class="line">      // only cast empty string / same name to boolean if</span><br><span class="line">      // boolean has higher priority</span><br><span class="line">      const stringIndex = getTypeIndex(String, prop.type)</span><br><span class="line">      if (stringIndex &lt; 0 || booleanIndex &lt; stringIndex) &#123;</span><br><span class="line">        value = true</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // check default value</span><br><span class="line">  if (value === undefined) &#123;</span><br><span class="line">    value = getPropDefaultValue(vm, prop, key)</span><br><span class="line">    // since the default value is a fresh copy,</span><br><span class="line">    // make sure to observe it.</span><br><span class="line">    const prevShouldObserve = shouldObserve</span><br><span class="line">    toggleObserving(true)</span><br><span class="line">    observe(value)</span><br><span class="line">    toggleObserving(prevShouldObserve)</span><br><span class="line">  &#125;</span><br><span class="line">  if (process.env.NODE_ENV !== &#x27;production&#x27;) &#123;</span><br><span class="line">    assertProp(prop, key, value, vm, absent)</span><br><span class="line">  &#125;</span><br><span class="line">  return value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>代码分析</p><ul><li><p>该函数接收四个参数</p><ul><li>key:遍历 propOptions 时拿到的每个属性名。</li><li>propOptions:当前实例规范化后的 props 选项。</li><li>propsData:父组件传入的真实 props 数据。</li><li>vm:当前实例。</li></ul></li><li><p>函数内部定义三个变量</p><ul><li>prop:当前 key 在 propOptions 中对应的值。</li><li>absent:当前 key 是否在 propsData 中存在，即父组件是否传入了该属性。</li><li>value:当前 key 在 propsData 中对应的值，即父组件对于该属性传入的真实值。</li></ul></li><li><p>判断 prop 的 type 属性是否是布尔类型(Boolean), getTypeIndex 函数用于判断 prop 的 type 属性中是否存在某种类型，如果存在则返回在 type 属性中的索引，如果不存在则返回 -1。</p><ul><li><p>如果是布尔类型，有两种情况需要单独处理</p><ul><li>如果 absent 为 true 即父组件没有传入该 prop 属性并且该属性也没有默认值的时候，将该属性设置为 false</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(absent &amp;&amp; !hasOwn(prop,&#x27;default&#x27;))&#123;</span><br><span class="line">  value = false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果父组件传入了该 prop 属性，那么需要满足以下几点，则将该属性值设为 true<ul><li>该属性值为空字符串或者属性值与属性名相等;</li><li>prop 的 type 属性中不存在 String 类型;</li><li>如果 prop 的 type 属性中存在 String 类型，那么 Boolean 类型在 type 属性中的索引必须小于 String 类型的索引，即 Boolean 类型的优先级更高。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if (value === &#x27;&#x27; || value === hyphenate(key)) &#123;</span><br><span class="line">  cosnt stringIndex = getTypeIndex(String, prop.type)</span><br><span class="line">  if (stringIndex &lt; 0 || booleanIndex&lt; stringIndex) &#123;</span><br><span class="line">    value = true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul></li><li><p>如果不是布尔类型，是其他类型则只需判断父组件是否传入该属性即可，如果没有传入，则该属性值为 undefined。</p></li><li><p>如果父组件传入了该属性并且也有对应的真实值，那么在非生产环境下会调用 assertProp 函数，校验该属性值是否与要求类型匹配。</p></li></ul></li></ul><h4 id="getPropDefaultValue-函数分析"><a href="#getPropDefaultValue-函数分析" class="headerlink" title="getPropDefaultValue 函数分析"></a>getPropDefaultValue 函数分析</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">function getPropDefaultValue (vm, prop, key)&#123;</span><br><span class="line">  // no default, return undefined</span><br><span class="line">  if (!hasOwn(prop, &#x27;default&#x27;)) &#123;</span><br><span class="line">    return undefined</span><br><span class="line">  &#125;</span><br><span class="line">  const def = prop.default</span><br><span class="line">  // warn against non-factory defaults for Object &amp; Array</span><br><span class="line">  if (process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; isObject(def)) &#123;</span><br><span class="line">    warn(</span><br><span class="line">      &#x27;Invalid default value for prop &quot;&#x27; + key + &#x27;&quot;: &#x27; +</span><br><span class="line">      &#x27;Props with type Object/Array must use a factory function &#x27; +</span><br><span class="line">      &#x27;to return the default value.&#x27;,</span><br><span class="line">      vm</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">  // the raw prop value was also undefined from previous render,</span><br><span class="line">  // return previous default value to avoid unnecessary watcher trigger</span><br><span class="line">  if (vm &amp;&amp; vm.$options.propsData &amp;&amp;</span><br><span class="line">    vm.$options.propsData[key] === undefined &amp;&amp;</span><br><span class="line">    vm._props[key] !== undefined</span><br><span class="line">  ) &#123;</span><br><span class="line">    return vm._props[key]</span><br><span class="line">  &#125;</span><br><span class="line">  // call factory function for non-Function types</span><br><span class="line">  // a value is Function if its prototype is function even across different execution context</span><br><span class="line">  return typeof def === &#x27;function&#x27; &amp;&amp; getType(prop.type) !== &#x27;Function&#x27;</span><br><span class="line">    ? def.call(vm)</span><br><span class="line">    : def</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>代码分析<ul><li>该函数接收三个参数<ul><li>vm:当前实例；</li><li>prop:子组件 props 选项中的每个 key 对应的值；</li><li>key:子组件 props 选项中的每个 key；<br>作用是根据子组件 props 选项中的 key 获取对应的默认值。</li></ul></li><li>首先判断 prop 中是否有 default 属性，如果没有，则表示没有默认值，直接返回。如果有则取出 default 属性，赋值给变量 def。接着判断在非生产环境下 def 是否是一个对象，如果是，则抛出警告。</li><li>接着判断如果父组件没有传入 props 属性，但是在 vm._props 中有该属性值，这说明 vm._props 中的该属性值就是默认值。</li><li>最后，判断 def 是否为函数并且 prop.type 不为 Function ，如果是的话表明 def 是一个返回对象或数组的工厂函数，那么将函数的返回值作为默认值返回；如果 def 不是函数，则将 def 作为默认值返回。</li></ul></li></ul><h4 id="assertProp-函数分析"><a href="#assertProp-函数分析" class="headerlink" title="assertProp 函数分析"></a>assertProp 函数分析</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">function assertProp (prop,name,value,vm,absent) &#123;</span><br><span class="line">  if (prop.required &amp;&amp; absent) &#123;</span><br><span class="line">    warn(</span><br><span class="line">      &#x27;Missing required prop: &quot;&#x27; + name + &#x27;&quot;&#x27;,</span><br><span class="line">      vm</span><br><span class="line">    )</span><br><span class="line">    return</span><br><span class="line">  &#125;</span><br><span class="line">  if (value == null &amp;&amp; !prop.required) &#123;</span><br><span class="line">    return</span><br><span class="line">  &#125;</span><br><span class="line">  let type = prop.type</span><br><span class="line">  let valid = !type || type === true</span><br><span class="line">  const expectedTypes = []</span><br><span class="line">  if (type) &#123;</span><br><span class="line">    if (!Array.isArray(type)) &#123;</span><br><span class="line">      type = [type]</span><br><span class="line">    &#125;</span><br><span class="line">    for (let i = 0; i &lt; type.length &amp;&amp; !valid; i++) &#123;</span><br><span class="line">      const assertedType = assertType(value, type[i])</span><br><span class="line">      expectedTypes.push(assertedType.expectedType || &#x27;&#x27;)</span><br><span class="line">      valid = assertedType.valid</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  if (!valid) &#123;</span><br><span class="line">    warn(</span><br><span class="line">      `Invalid prop: type check failed for prop &quot;$&#123;name&#125;&quot;.` +</span><br><span class="line">      ` Expected $&#123;expectedTypes.map(capitalize).join(&#x27;, &#x27;)&#125;` +</span><br><span class="line">      `, got $&#123;toRawType(value)&#125;.`,</span><br><span class="line">      vm</span><br><span class="line">    )</span><br><span class="line">    return</span><br><span class="line">  &#125;</span><br><span class="line">  const validator = prop.validator</span><br><span class="line">  if (validator) &#123;</span><br><span class="line">    if (!validator(value)) &#123;</span><br><span class="line">      warn(</span><br><span class="line">        &#x27;Invalid prop: custom validator check failed for prop &quot;&#x27; + name + &#x27;&quot;.&#x27;,</span><br><span class="line">        vm</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>代码分析<ul><li>该函数接收五个参数<ul><li>prop: prop 选项</li><li>name: props 中 prop 选项的 key</li><li>value: 父组件传入的 propsData 中 key 对应的真实数据。</li><li>vm: 当前实例。</li><li>absent: 当前 key 是否在 propsData 中存在，即父组件是否传入了该属性<br>作用：是校验父组件传来的真实值是否与 prop 的 type 类型相匹配，如果不匹配则在非生产环境下抛出警告。</li></ul></li><li>定义 3 个变量<ul><li>type: prop 中的 type 类型。</li><li>valid: 校验是否成功。</li><li>expectedTypes: 保存期望类型的数组，当校验失败抛出警告时，提示用户该属性所期望的类型是什么</li></ul></li></ul></li></ul><h3 id="初始化-methods"><a href="#初始化-methods" class="headerlink" title="初始化 methods"></a>初始化 methods</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">function initMethods (vm, methods) &#123;</span><br><span class="line">  const props = vm.$options.props</span><br><span class="line">  for (const key in methods) &#123;</span><br><span class="line">    if (process.env.NODE_ENV !== &#x27;production&#x27;) &#123;</span><br><span class="line">      if (methods[key] == null) &#123;</span><br><span class="line">        warn(</span><br><span class="line">          `Method &quot;$&#123;key&#125;&quot; has an undefined value in the component definition. ` +</span><br><span class="line">          `Did you reference the function correctly?`,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">      if (props &amp;&amp; hasOwn(props, key)) &#123;</span><br><span class="line">        warn(</span><br><span class="line">          `Method &quot;$&#123;key&#125;&quot; has already been defined as a prop.`,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">      if ((key in vm) &amp;&amp; isReserved(key)) &#123;</span><br><span class="line">        warn(</span><br><span class="line">          `Method &quot;$&#123;key&#125;&quot; conflicts with an existing Vue instance method. ` +</span><br><span class="line">          `Avoid defining component methods that start with _ or $.`</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vm[key] = methods[key] == null ? noop : bind(methods[key], vm)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>代码分析<ul><li>首先遍历 methods 选项中的每一个对象，在非生产环境下判断如果 methods 中某个方法只有 key 而没有 value，即只有方法名没有方法体时，抛出异常：提示用户方法未定义。</li><li>接着判断如果 methods 中某个方法名与 props 中某个属性名重复了，就抛出异常：提示用户方法名重复。</li><li>接着判断如果 methods 中某个方法名如果在实例 vm 中已经存在并且方法名是以 _ 或 $ 开头的，就抛出异常：提示用户方法名命名不规范。</li><li>最后，如果上述判断没有问题，那就 method 绑定到 实例 vm 上，可以通过 this.fun() 来访问 methods 选项中的 fun 方法。<br>总起来：初始化 methods 就做了三件事情，判断 method 有没有，method 的命名符不符合命名规范，method 既有又符合命名规范就把它挂载到 vm 实例上。</li></ul></li></ul><h3 id="初始化-data"><a href="#初始化-data" class="headerlink" title="初始化 data"></a>初始化 data</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">function initData (vm) &#123;</span><br><span class="line">    let data = vm.$options.data</span><br><span class="line">    data = vm._data = typeof data === &#x27;function&#x27;</span><br><span class="line">        ? getData(data, vm)</span><br><span class="line">    : data || &#123;&#125;</span><br><span class="line">    if (!isPlainObject(data)) &#123;</span><br><span class="line">        data = &#123;&#125;</span><br><span class="line">        process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; warn(</span><br><span class="line">            &#x27;data functions should return an object:\n&#x27; +</span><br><span class="line">            &#x27;https://vuejs.org/v2/guide/components.html##data-Must-Be-a-Function&#x27;,</span><br><span class="line">            vm</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">    // proxy data on instance</span><br><span class="line">    const keys = Object.keys(data)</span><br><span class="line">    const props = vm.$options.props</span><br><span class="line">    const methods = vm.$options.methods</span><br><span class="line">    let i = keys.length</span><br><span class="line">    while (i--) &#123;</span><br><span class="line">        const key = keys[i]</span><br><span class="line">        if (process.env.NODE_ENV !== &#x27;production&#x27;) &#123;</span><br><span class="line">            if (methods &amp;&amp; hasOwn(methods, key)) &#123;</span><br><span class="line">                warn(</span><br><span class="line">                    `Method &quot;$&#123;key&#125;&quot; has already been defined as a data property.`,</span><br><span class="line">                    vm</span><br><span class="line">                )</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (props &amp;&amp; hasOwn(props, key)) &#123;</span><br><span class="line">            process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; warn(</span><br><span class="line">                `The data property &quot;$&#123;key&#125;&quot; is already declared as a prop. ` +</span><br><span class="line">                `Use prop default value instead.`,</span><br><span class="line">                vm</span><br><span class="line">            )</span><br><span class="line">        &#125; else if (!isReserved(key)) &#123;</span><br><span class="line">            proxy(vm, `_data`, key)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // observe data</span><br><span class="line">    observe(data, true /* asRootData */)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>代码分析<ul><li>首先获取到用户传入的 data 选项，赋值给变量 data,同时将变量 data 作为指针指向 vm._data, 然后判断 data 是不是一个函数，如果是函数调用 getData 函数获取其返回值，将其保存到 vm._data 中，如果不是，就将其本身保存到 vm._data 中。</li><li>接下来遍历 data 对象中的每一项，在非生产环境下判断 data 对象中是否存在某一项的 key 与 method 中某个属性名重复，如果重复，就抛出警告：提示用户属性名重复。</li><li>接着再判断是否存在某一项的 key 与 prop 中某个属性名重复，如果存在重复，就抛出警告：提示用户属性名重复。<br>如果都没有重复，则调用 proxy 函数将 data 对象中 key 不以_或$开头的属性代理到实例 vm 上，这样，我们就可以通过 this.xxx 来访问 data 选项中的 xxx 数据了</li><li>最后，调用 observe 函数将 data 中的数据转化成响应式。</li></ul></li></ul><h3 id="初始化-computed"><a href="#初始化-computed" class="headerlink" title="初始化 computed"></a>初始化 computed</h3><p>计算属性有一个很大的特点：计算属性的结果会被缓存，除非依赖的响应属性发生变化才会重新计算。</p><h4 id="initComputed-函数分析"><a href="#initComputed-函数分析" class="headerlink" title="initComputed 函数分析"></a>initComputed 函数分析</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">function initComputed (vm: Component, computed: Object) &#123;</span><br><span class="line">    const watchers = vm._computedWatchers = Object.create(null)</span><br><span class="line">    const isSSR = isServerRendering()</span><br><span class="line"></span><br><span class="line">    for (const key in computed) &#123;</span><br><span class="line">        const userDef = computed[key]</span><br><span class="line">        const getter = typeof userDef === &#x27;function&#x27; ? userDef : userDef.get</span><br><span class="line">        if (process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; getter == null) &#123;</span><br><span class="line">            warn(</span><br><span class="line">                `Getter is missing for computed property &quot;$&#123;key&#125;&quot;.`,</span><br><span class="line">                vm</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (!isSSR) &#123;</span><br><span class="line">            // create internal watcher for the computed property.</span><br><span class="line">            watchers[key] = new Watcher(</span><br><span class="line">                vm,</span><br><span class="line">                getter || noop,</span><br><span class="line">                noop,</span><br><span class="line">                computedWatcherOptions</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (!(key in vm)) &#123;</span><br><span class="line">            defineComputed(vm, key, userDef)</span><br><span class="line">        &#125; else if (process.env.NODE_ENV !== &#x27;production&#x27;) &#123;</span><br><span class="line">            if (key in vm.$data) &#123;</span><br><span class="line">                warn(`The computed property &quot;$&#123;key&#125;&quot; is already defined in data.`, vm)</span><br><span class="line">            &#125; else if (vm.$options.props &amp;&amp; key in vm.$options.props) &#123;</span><br><span class="line">                warn(`The computed property &quot;$&#123;key&#125;&quot; is already defined as a prop.`, vm)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>代码分析<ul><li>首先定义一个变量 watchers 并将其赋值为空对象，同时将其作为指针指向 vm.computedWatchers</li><li>接着遍历 computed 选项中的每一项属性，首先获取到每一项的属性值，记作 userDef,然后判断 userDef 是不是一个函数，如果是函数，则该函数默认为取值器 getter,将其赋值给变量 getter; 如果不是函数，则说明是一个对象，则对象中的 get 属性作为取值器赋给变量 getter。</li><li>接着判断在非生产环境下如果上面的两种情况取到的取值器不存在，则抛出警告：提示用户计算属性必须有取值器。</li><li>接着判断如果不是在服务端渲染环境下，则创建一个 watcher 实例，并将当前循环到的属性名作为键，创建的 watcher 实例作为值存入 watcher 对象中。</li><li>最后判断当前循环到的属性名是否存在于当前实例 vm 上，如果存在，则在非生产环境下抛出警告；如果不存在，则调用 defineComputed 函数为实例 vm 上设置计算属性。</li></ul></li></ul><h4 id="defineComputed-函数分析"><a href="#defineComputed-函数分析" class="headerlink" title="defineComputed 函数分析"></a>defineComputed 函数分析</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">const sharedPropertyDefinition = &#123;</span><br><span class="line">  enumerable: true,</span><br><span class="line">  configurable: true,</span><br><span class="line">  get: noop,</span><br><span class="line">  set: noop</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function defineComputed (target,key,userDef) &#123;</span><br><span class="line">  const shouldCache = !isServerRendering()</span><br><span class="line">  if (typeof userDef === &#x27;function&#x27;) &#123;</span><br><span class="line">    sharedPropertyDefinition.get = shouldCache</span><br><span class="line">      ? createComputedGetter(key)</span><br><span class="line">      : userDef</span><br><span class="line">    sharedPropertyDefinition.set = noop</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    sharedPropertyDefinition.get = userDef.get</span><br><span class="line">      ? shouldCache &amp;&amp; userDef.cache !== false</span><br><span class="line">        ? createComputedGetter(key)</span><br><span class="line">        : userDef.get</span><br><span class="line">      : noop</span><br><span class="line">    sharedPropertyDefinition.set = userDef.set</span><br><span class="line">      ? userDef.set</span><br><span class="line">      : noop</span><br><span class="line">  &#125;</span><br><span class="line">  if (process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp;</span><br><span class="line">      sharedPropertyDefinition.set === noop) &#123;</span><br><span class="line">    sharedPropertyDefinition.set = function () &#123;</span><br><span class="line">      warn(</span><br><span class="line">        `Computed property &quot;$&#123;key&#125;&quot; was assigned to but it has no setter.`,</span><br><span class="line">        this</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  Object.defineProperty(target, key, sharedPropertyDefinition)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>-</p>]]></content>
      
      
      <categories>
          
          <category> Vue.js 源码解读 </category>
          
          <category> 生命周期 </category>
          
          <category> 初始化 initState 阶段 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue.js 源码解读,</title>
      <link href="/2023/03/01/vue%E6%BA%90%E7%A0%815/"/>
      <url>/2023/03/01/vue%E6%BA%90%E7%A0%815/</url>
      
        <content type="html"><![CDATA[<h2 id="生命周期是什么"><a href="#生命周期是什么" class="headerlink" title="生命周期是什么"></a>生命周期是什么</h2><p>在 Vue 中，每个 Vue 实例从被创建出来到最终销毁都会经历一个过程，在这一过程里会发生许许多多的事情，如：设置数据监听，编译模板，组件挂载等，在 Vue 中，把 Vue 实例从被创建出来到最终被销毁的这一过程称为 Vue 实例的生命周期。</p><p>生命周期流程图</p><p><img src="https://vue-js.com/learn-vue/assets/img/1.6e1e57be.jpg" alt="生命周期流程图"></p><ul><li><p>Vue 实例的生命周期大致可分为 4 个阶段</p><ul><li>初始阶段：为 Vue 实例上初始化一些属性，事件已经响应式数据；</li><li>模板编译阶段：将模板编译成渲染函数；</li><li>挂载阶段：将实例挂载到指定的 DOM 上，即将模板渲染到真实 DOM 中；</li><li>销毁阶段：将实例自身从父组件中删除，并取消依赖追踪及事件监听器；</li></ul></li></ul><h2 id="初始化阶段"><a href="#初始化阶段" class="headerlink" title="初始化阶段"></a>初始化阶段</h2><p>初始化阶段所做的工作大致分为两部分: 第一部分是 new Vue(),即创建一个 Vue 实例; 第二部分是为创建好的 Vue 实例初始化一些事件、属性、响应式数据等。</p><h3 id="new-Vue-都做了什么事"><a href="#new-Vue-都做了什么事" class="headerlink" title="new Vue() 都做了什么事"></a>new Vue() 都做了什么事</h3><p>new Vue() 实际上是执行了一个 Vue 类的构造函数，构造函数内部执行 <code>_init</code> 方法。<code>_init</code> 方法所作的事情就是 new Vue() 所作的事情。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">export function initMixin (Vue) &#123;</span><br><span class="line">  Vue.prototype._init = function (options) &#123;</span><br><span class="line">    const vm = this</span><br><span class="line">    vm.$options = mergeOptions(</span><br><span class="line">        resolveConstructorOptions(vm.constructor),</span><br><span class="line">        options || &#123;&#125;,</span><br><span class="line">        vm</span><br><span class="line">    )</span><br><span class="line">    vm._self = vm</span><br><span class="line">    initLifecycle(vm)</span><br><span class="line">    initEvents(vm)</span><br><span class="line">    initRender(vm)</span><br><span class="line">    callHook(vm, &#x27;beforeCreate&#x27;)</span><br><span class="line">    initInjections(vm) // resolve injections before data/props</span><br><span class="line">    initState(vm)</span><br><span class="line">    initProvide(vm) // resolve provide after data/props</span><br><span class="line">    callHook(vm, &#x27;created&#x27;)</span><br><span class="line"></span><br><span class="line">    if (vm.$options.el) &#123;</span><br><span class="line">      vm.$mount(vm.$options.el)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>_init</code> 方法都做了些什么事情。</p><ul><li>首先把 Vue 实例赋值给变量 vm,并且把用户传递的 <code>options</code> 选项与当前构造函数的 <code>options</code> 属性及其父级构造函数的 <code>options</code> 属性进行合并，得到一个新的 <code>options</code> 选项赋值给 <code>$options</code> 属性，并将 <code>$options</code> 属性挂载到 <code>Vue</code> 实例上。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vm.$options = mergeOptions(</span><br><span class="line">  resolveConstructorOptions(vm.constructor),</span><br><span class="line">  options || &#123;&#125;,</span><br><span class="line">  vm</span><br><span class="line">)</span><br></pre></td></tr></table></figure><ul><li>接着，通过调用一些初始化函数来为 <code>Vue</code> 实例初始化一些属性，事件，响应是数据等。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">initLifecycle(vm)       // 初始化生命周期</span><br><span class="line">initEvents(vm)        // 初始化事件</span><br><span class="line">initRender(vm)         // 初始化渲染</span><br><span class="line">callHook(vm, &#x27;beforeCreate&#x27;)  // 调用生命周期钩子函数</span><br><span class="line">initInjections(vm)   //初始化injections</span><br><span class="line">initState(vm)    // 初始化props,methods,data,computed,watch</span><br><span class="line">initProvide(vm) // 初始化 provide</span><br><span class="line">callHook(vm, &#x27;created&#x27;)  // 调用生命周期钩子函数</span><br></pre></td></tr></table></figure><p>除了调用初始化函数来进行相关数据的初始化之外，还会再合适的时机调用了 callHook 函数来触发生命周期的钩子。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (vm.$options.el) &#123;</span><br><span class="line">    vm.$mount(vm.$options.el)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，会判断用户是否传入了 el 选项，如果传入了则调用 $mount 函数进入模板编译与挂载阶段，如果没有传入 el 选项，则不进入下一个生命周期阶段，需要用户手动执行 vm.$mount 方法才进入下一个生命周期阶段。</p></li></ul><h3 id="合并属性"><a href="#合并属性" class="headerlink" title="合并属性"></a>合并属性</h3><h2 id="初始化阶段-initLifecycle-函数分析"><a href="#初始化阶段-initLifecycle-函数分析" class="headerlink" title="初始化阶段 initLifecycle 函数分析"></a>初始化阶段 initLifecycle 函数分析</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">export function initLifecycle (vm: Component) &#123;</span><br><span class="line">  const options = vm.$options</span><br><span class="line"></span><br><span class="line">  // locate first non-abstract parent</span><br><span class="line">  let parent = options.parent</span><br><span class="line">  if (parent &amp;&amp; !options.abstract) &#123;</span><br><span class="line">    while (parent.$options.abstract &amp;&amp; parent.$parent) &#123;</span><br><span class="line">      parent = parent.$parent</span><br><span class="line">    &#125;</span><br><span class="line">    parent.$children.push(vm)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  vm.$parent = parent</span><br><span class="line">  vm.$root = parent ? parent.$root : vm</span><br><span class="line"></span><br><span class="line">  vm.$children = []</span><br><span class="line">  vm.$refs = &#123;&#125;</span><br><span class="line"></span><br><span class="line">  vm._watcher = null</span><br><span class="line">  vm._inactive = null</span><br><span class="line">  vm._directInactive = false</span><br><span class="line">  vm._isMounted = false</span><br><span class="line">  vm._isDestroyed = false</span><br><span class="line">  vm._isBeingDestroyed = false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>代码分析<ul><li>首先是给实例上挂载 <code>$parent</code> 属性。<ul><li>逻辑：如果当前组件不是抽象组件并且存在父级，就通过 while 循环来向上循环，如果当前组件的父级是抽象组件并且也存在父级，那就继续向上查找当前组件的父级，直到找到第一个不是抽象类型的父级时，将其赋值 vm.$parent 同时把该实例自身添加进找到的父级的 $children 属性中。</li></ul></li><li>接着是给实例挂载 <code>$root</code> 属性。<ul><li>实例的 $root 属性表示当前实例的根实例，挂载该属性时，首先会判断如果当前实例存在于父级，那么当前实例的根实例 $root 属性就是其父级根实例 $root 属性，如果不存在，那么根实例 $root 属性就是它自己。</li><li>最后，在初始化一些其它属性，</li></ul></li></ul></li></ul><h2 id="初始化阶段-initEvents-函数分析"><a href="#初始化阶段-initEvents-函数分析" class="headerlink" title="初始化阶段 initEvents 函数分析"></a>初始化阶段 initEvents 函数分析</h2><p>initEvents 是生命周期初始化阶段所调用的第二个初始化函数。这个初始化函数是初始化实例的事件系统。在 <code>Vue</code> 中，当我们在父组件中使用子组件时可以给子组件上注册一些事件，即 v-on 或 @ 注册的自定义事件，也包括注册的浏览器原生事件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;child @select=&quot;selectHandler&quot; @click.native=&quot;clickHandler&quot;&gt;&lt;/child&gt;</span><br></pre></td></tr></table></figure><h3 id="解析事件"><a href="#解析事件" class="headerlink" title="解析事件"></a>解析事件</h3><p>模板编译解析中，当遇到开始标签的时候，除了会解析开始标签，会调用 processAttrs 方法解析标签中的属性，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">export const onRE = /^@|^v-on:/</span><br><span class="line">export const dirRE = /^v-|^@|^:/</span><br><span class="line"></span><br><span class="line">function processAttrs (el) &#123;</span><br><span class="line">const list = el.attrsList</span><br><span class="line">let i, l, name, value, modifiers</span><br><span class="line">for (i = 0, l = list.length; i &lt; l; i++) &#123;</span><br><span class="line">  name  = list[i].name</span><br><span class="line">  value = list[i].value</span><br><span class="line">  if (dirRE.test(name)) &#123;</span><br><span class="line">    // 解析修饰符</span><br><span class="line">    modifiers = parseModifiers(name)</span><br><span class="line">    if (modifiers) &#123;</span><br><span class="line">      name = name.replace(modifierRE, &#x27;&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">    if (onRE.test(name)) &#123; // v-on</span><br><span class="line">      name = name.replace(onRE, &#x27;&#x27;)</span><br><span class="line">      addHandler(el, name, value, modifiers, false, warn)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在对标签属性进行解析的时，判断如果属性时指令，首先通过 parseModifiers 解析出属性的修饰符，然后判断如果时事件的指令，则执行 addHandler(el,name,value,modifiers.false,warn) 方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">export function addHandler (el,name,value,modifiers) &#123;</span><br><span class="line"> modifiers = modifiers || emptyObject</span><br><span class="line"></span><br><span class="line"> // check capture modifier 判断是否有capture修饰符</span><br><span class="line"> if (modifiers.capture) &#123;</span><br><span class="line">   delete modifiers.capture</span><br><span class="line">   name = &#x27;!&#x27; + name // 给事件名前加&#x27;!&#x27;用以标记capture修饰符</span><br><span class="line"> &#125;</span><br><span class="line"> // 判断是否有once修饰符</span><br><span class="line"> if (modifiers.once) &#123;</span><br><span class="line">   delete modifiers.once</span><br><span class="line">   name = &#x27;~&#x27; + name // 给事件名前加&#x27;~&#x27;用以标记once修饰符</span><br><span class="line"> &#125;</span><br><span class="line"> // 判断是否有passive修饰符</span><br><span class="line"> if (modifiers.passive) &#123;</span><br><span class="line">   delete modifiers.passive</span><br><span class="line">   name = &#x27;&amp;&#x27; + name // 给事件名前加&#x27;&amp;&#x27;用以标记passive修饰符</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> let events</span><br><span class="line"> if (modifiers.native) &#123;</span><br><span class="line">   delete modifiers.native</span><br><span class="line">   events = el.nativeEvents || (el.nativeEvents = &#123;&#125;)</span><br><span class="line"> &#125; else &#123;</span><br><span class="line">   events = el.events || (el.events = &#123;&#125;)</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> const newHandler: any = &#123;</span><br><span class="line">   value: value.trim()</span><br><span class="line"> &#125;</span><br><span class="line"> if (modifiers !== emptyObject) &#123;</span><br><span class="line">   newHandler.modifiers = modifiers</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> const handlers = events[name]</span><br><span class="line"> if (Array.isArray(handlers)) &#123;</span><br><span class="line">   handlers.push(newHandler)</span><br><span class="line"> &#125; else if (handlers) &#123;</span><br><span class="line">   events[name] = [handlers, newHandler]</span><br><span class="line"> &#125; else &#123;</span><br><span class="line">   events[name] = newHandler</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> el.plain = false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>该方法做了三件事</p><ul><li>根据 modifier 修饰符对事件名 name 做处理。</li><li>根据 modifier.native 判断事件是一个浏览器原生事件还是自定义事件，分别对应 el.nativeEvents 和 el.events。</li><li>按照 name 对事件做归类，并把回调函数的字符串保留到对应的事件中。</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 形成的事件对象</span><br><span class="line">el.events = &#123;</span><br><span class="line">  select: &#123;</span><br><span class="line">    value:&#x27;selectHandler&#x27;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">el.nativeEvents = &#123;</span><br><span class="line">  click: &#123;</span><br><span class="line">    value: &#x27;clickHandler&#x27;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在模板编译的代码生成阶段，会 genData 函数中根据 AST 元素节点上的 events 和 nativeEvents 生成 _c(tagName,data,children) 函数中所需要的 data 数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">export function genData (el state) &#123;</span><br><span class="line">  let data = &#x27;&#123;&#x27;</span><br><span class="line">  // ...</span><br><span class="line">  if (el.events) &#123;</span><br><span class="line">    data += `$&#123;genHandlers(el.events, false,state.warn)&#125;,`</span><br><span class="line">  &#125;</span><br><span class="line">  if (el.nativeEvents) &#123;</span><br><span class="line">    data += `$&#123;genHandlers(el.nativeEvents, true, state.warn)&#125;,`</span><br><span class="line">  &#125;</span><br><span class="line">  // ...</span><br><span class="line">  return data</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面的方法生成的 data 数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  // ...</span><br><span class="line">  on: &#123;&quot;select&quot;: selectHandler&#125;,</span><br><span class="line">  nativeOn: &#123;&quot;click&quot;: function($event) &#123;</span><br><span class="line">      return clickHandler($event)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，最开始的模板中标签上注册的事件最终会被解析成用于创建元素型 VNode 的 _c(tagName,data,children) 函数中 data 数据中的两个对象，自定义事件对象 on，浏览器原生事件 nativeOn。</p><p>模板编译的最终目的是创建 render 函数供挂载的时候调用生成虚拟 DOM, 那么在挂载阶段，如果被挂载的节点是一个组件节点，则通过 createComponent 函数创建一个组件 vnode 源码如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">export function createComponent (</span><br><span class="line">  Ctor: Class&lt;Component&gt; | Function | Object | void,</span><br><span class="line">  data: ?VNodeData,</span><br><span class="line">  context: Component,</span><br><span class="line">  children: ?Array&lt;VNode&gt;,</span><br><span class="line">  tag?: string</span><br><span class="line">): VNode | Array&lt;VNode&gt; | void &#123;</span><br><span class="line">  // ...</span><br><span class="line">  const listeners = data.on</span><br><span class="line"></span><br><span class="line">  data.on = data.nativeOn</span><br><span class="line"></span><br><span class="line">  // ...</span><br><span class="line">  const name = Ctor.options.name || tag</span><br><span class="line">  const vnode = new VNode(</span><br><span class="line">    `vue-component-$&#123;Ctor.cid&#125;$&#123;name ? `-$&#123;name&#125;` : &#x27;&#x27;&#125;`,</span><br><span class="line">    data, undefined, undefined, undefined, context,</span><br><span class="line">    &#123; Ctor, propsData, listeners, tag, children &#125;,</span><br><span class="line">    asyncFactory</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  return vnode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>父组件给子组件的注册事件中，把自定义事件传给子组件，在子组件实例化的时候进行初始化；而浏览器原生事件是在父组件中处理。</code></p><p><code>实例初始化阶段调用的初始化事件函数 initEvents 实际上初始化的是父组件在模板中使用 v-on 或 @ 注册的监听子组件内触发的事件。</code></p><h3 id="initEvents-函数分析"><a href="#initEvents-函数分析" class="headerlink" title="initEvents 函数分析"></a>initEvents 函数分析</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">export function initEvents (vm: Component) &#123;</span><br><span class="line">  vm._events = Object.create(null)</span><br><span class="line">  // init parent attached events</span><br><span class="line">  const listeners = vm.$options._parentListeners</span><br><span class="line">  if (listeners) &#123;</span><br><span class="line">    updateComponentListeners(vm, listeners)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>代码分析<ul><li>在 vm 上新增 <code>_events</code> 属性并将其赋值为空对象，用来存储事件。</li><li>然后、获取父组件注册的事件赋值给 listeners，如果 listeners 不为空，则调用 updataComponentsListeners 函数，将父组件向子组件注册的事件注册到子组件的实例中。</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">export function updateComponentListeners (</span><br><span class="line">  vm: Component,</span><br><span class="line">  listeners: Object,</span><br><span class="line">  oldListeners: ?Object</span><br><span class="line">) &#123;</span><br><span class="line">  target = vm</span><br><span class="line">  updateListeners(listeners, oldListeners || &#123;&#125;, add, remove, vm)</span><br><span class="line">  target = undefined</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function add (event, fn, once) &#123;</span><br><span class="line">  if (once) &#123;</span><br><span class="line">    target.$once(event, fn)</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    target.$on(event, fn)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function remove (event, fn) &#123;</span><br><span class="line">  target.$off(event, fn)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>代码分析<ul><li>内部调用 updataListeners 函数，并把 listeners 以及 add 和 remove 这两个函数传入。</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">export function updateListeners (</span><br><span class="line">  on: Object,</span><br><span class="line">  oldOn: Object,</span><br><span class="line">  add: Function,</span><br><span class="line">  remove: Function,</span><br><span class="line">  vm: Component</span><br><span class="line">) &#123;</span><br><span class="line">  let name, def, cur, old, event</span><br><span class="line">  for (name in on) &#123;</span><br><span class="line">    def = cur = on[name]</span><br><span class="line">    old = oldOn[name]</span><br><span class="line">    event = normalizeEvent(name)</span><br><span class="line">    if (isUndef(cur)) &#123;</span><br><span class="line">      process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; warn(</span><br><span class="line">        `Invalid handler for event &quot;$&#123;event.name&#125;&quot;: got ` + String(cur),</span><br><span class="line">        vm</span><br><span class="line">      )</span><br><span class="line">    &#125; else if (isUndef(old)) &#123;</span><br><span class="line">      if (isUndef(cur.fns)) &#123;</span><br><span class="line">        cur = on[name] = createFnInvoker(cur)</span><br><span class="line">      &#125;</span><br><span class="line">      add(event.name, cur, event.once, event.capture, event.passive, event.params)</span><br><span class="line">    &#125; else if (cur !== old) &#123;</span><br><span class="line">      old.fns = cur</span><br><span class="line">      on[name] = old</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  for (name in oldOn) &#123;</span><br><span class="line">    if (isUndef(on[name])) &#123;</span><br><span class="line">      event = normalizeEvent(name)</span><br><span class="line">      remove(event.name, oldOn[name], event.capture)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>代码分析</p><ul><li>对比 listeners 和 oldListeners 的不同，并调用参数中提供的 add 和 remove 进行相应的注册事件和卸载事件。<br>对比的思想：如果 listeners 对象中存在某个 key 而 oldListeners 中不存在，则说明这个事件是需要新增的；反之，如果 oldListeners 对象中存在某个 key(事件名) 而 listeners 中不存在，则说明这个事件是需要从事件系统中卸载。</li><li>函数接收 5 个参数，分别是 on、oldOn、add、remove、vm,其中 on 对应 listeners, oldOn 对应 oldListeners。</li><li>首先对 on 进行遍历， 获得每一个事件名，然后调用 normalizeEvent 函数（关于该函数下面会介绍）处理， 处理完事件名后， 判断事件名对应的值是否存在，如果不存在则抛出警告，</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">for (name in on) &#123;</span><br><span class="line">  def = cur = on[name]</span><br><span class="line">  old = oldOn[name]</span><br><span class="line">  event = normalizeEvent(name)</span><br><span class="line">  if (isUndef(cur)) &#123;</span><br><span class="line">    process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; warn(</span><br><span class="line">      `Invalid handler for event &quot;$&#123;event.name&#125;&quot;: got ` + String(cur),</span><br><span class="line">      vm</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>如果存在，则继续判断该事件名在 oldOn 中是否存在，如果不存在，则调用 add 注册事件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">if (isUndef(old)) &#123;</span><br><span class="line">  if (isUndef(cur.fns)) &#123;</span><br><span class="line">    cur = on[name] = createFnInvoker(cur)</span><br><span class="line">  &#125;</span><br><span class="line">  add(event.name, cur, event.once, event.capture, event.passive, event.params)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function createFnInvoker (fns) &#123;</span><br><span class="line">  function invoker () &#123;</span><br><span class="line">    const fns = invoker.fns</span><br><span class="line">    if (Array.isArray(fns)) &#123;</span><br><span class="line">      const cloned = fns.slice()</span><br><span class="line">      for (let i = 0; i &lt; cloned.length; i++) &#123;</span><br><span class="line">        cloned[i].apply(null, arguments)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      // return handler return value for single handlers</span><br><span class="line">      return fns.apply(null, arguments)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">invoker.fns = fns</span><br><span class="line">return invoker</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="初始化阶段-initInjections"><a href="#初始化阶段-initInjections" class="headerlink" title="初始化阶段 initInjections"></a>初始化阶段 initInjections</h2><p>该函数是用来初始化实例中的 inject 选项。inject 和 provide 选项，这两个选项都是成对出现，左右是：允许一个祖先组件向其它子孙后代注入一个依赖，不论组件层次有多深，并在起上下游关系成立的时间里始终生效。provide 选项应该返回一个对象或返回一个对象的函数。该对象包含可注入其子孙的属性。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var Parent = &#123;</span><br><span class="line">  provide:&#123;</span><br><span class="line">    foo:&#x27;bar&#x27;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">var Child = &#123;</span><br><span class="line">  inject:[&#x27;foo&#x27;],</span><br><span class="line">  created () &#123;</span><br><span class="line">    console.log(this.foo) // bar</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="initInjections-函数分析"><a href="#initInjections-函数分析" class="headerlink" title="initInjections 函数分析"></a>initInjections 函数分析</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">export function initInjections (vm: Component) &#123;</span><br><span class="line">  const result = resolveInject(vm.$options.inject, vm)</span><br><span class="line">  if (result) &#123;</span><br><span class="line">    toggleObserving(false)</span><br><span class="line">    Object.keys(result).forEach(key =&gt; &#123;</span><br><span class="line">      defineReactive(vm, key, result[key])</span><br><span class="line">    &#125;</span><br><span class="line">    toggleObserving(true)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export let shouldObserve: boolean = true</span><br><span class="line">export function toggleObserving (value: boolean) &#123;</span><br><span class="line">  shouldObserve = value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>代码分析<ul><li>首先调用 resolveInject 把 inject 选项中的数据转化成键值对的形式赋值给 result 。</li><li>遍历 result 中的每一对键值，调用 defineReactive 将数据转换成可观测的数据。</li></ul></li><li>注意点：<br>在把 result 中的键值对添加到当前实例上之前，会先调用 toggleObserving(false),而这个函数内部是把 shouldObserver = false, 是告诉 defineReactive 函数仅仅是把键值添加到当前实例上而不需要将其转换成响应式。</li></ul><h3 id="resolveInject-函数分析"><a href="#resolveInject-函数分析" class="headerlink" title="resolveInject 函数分析"></a>resolveInject 函数分析</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">export function resolveInject (inject: any, vm: Component): ?Object &#123;</span><br><span class="line">  if (inject) &#123;</span><br><span class="line">    const result = Object.create(null)</span><br><span class="line">    const keys =  Object.keys(inject)</span><br><span class="line"></span><br><span class="line">    for (let i = 0; i &lt; keys.length; i++) &#123;</span><br><span class="line">      const key = keys[i]</span><br><span class="line">      const provideKey = inject[key].from</span><br><span class="line">      let source = vm</span><br><span class="line">      while (source) &#123;</span><br><span class="line">        if (source._provided &amp;&amp; hasOwn(source._provided, provideKey)) &#123;</span><br><span class="line">          result[key] = source._provided[provideKey]</span><br><span class="line">          break</span><br><span class="line">        &#125;</span><br><span class="line">        source = source.$parent</span><br><span class="line">      &#125;</span><br><span class="line">      if (!source) &#123;</span><br><span class="line">        if (&#x27;default&#x27; in inject[key]) &#123;</span><br><span class="line">          const provideDefault = inject[key].default</span><br><span class="line">          result[key] = typeof provideDefault === &#x27;function&#x27;</span><br><span class="line">            ? provideDefault.call(vm)</span><br><span class="line">            : provideDefault</span><br><span class="line">        &#125; else if (process.env.NODE_ENV !== &#x27;production&#x27;) &#123;</span><br><span class="line">          warn(`Injection &quot;$&#123;key&#125;&quot; not found`, vm)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>代码分析<ul><li>首先创建一个空对象 result,用来存储 inject 选项中的数据 key 及其对应的值，作为最后的返回结果。</li><li>获取当前 inject 选项中的所有 key，然后遍历每一个 key,拿到每一个 key 的 from 属性记作 provideKey，provideKey 就是上游父级组件提供的源属性，然后开启一个 while 循环，从当前组件起，不断的向上游父级组件的_provided 属性中（父级组件使用 provide 选项注入数据时会将注入的数据存入自己的实例的_provided 属性中）查找，直到查找到源属性的对应的值，将其存入 result 中。如果没有找到，就看 inject 选项中当前数据 key 是否设置了默认值，如果有，则拿这个默认值。如果没有默认值就，就抛出异常。</li><li>最后返回 result</li></ul></li></ul><h2 id><a href="#" class="headerlink" title></a></h2>]]></content>
      
      
      <categories>
          
          <category> Vue.js 源码解读 </category>
          
          <category> 生命周期 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue.js 源码解读, Diff</title>
      <link href="/2023/03/01/vue%E6%BA%90%E7%A0%812/"/>
      <url>/2023/03/01/vue%E6%BA%90%E7%A0%812/</url>
      
        <content type="html"><![CDATA[<h1 id="DOM-Diff"><a href="#DOM-Diff" class="headerlink" title="DOM-Diff"></a>DOM-Diff</h1><p><code>VNode</code> 最大的用途就是在数据变化前后生成真实<code>DOM</code> 对应虚拟<code>DOM</code>节点，然后就可以对比新旧两份<code>VNode</code>，找出差异所在，然后更新有差异的<code>DOM</code> 节点，最终达到以最少操作真实<code>DOM</code>更新视图的目的。新旧<code>DOM</code>树的对比找出差异的过程就是所谓的<code>DOM-Diff</code>过程，该过程是整个虚拟<code>DOM</code>核心所在。</p><h2 id="patch"><a href="#patch" class="headerlink" title="patch"></a>patch</h2><p>在 vue 中，把 DOM-Diff 过程叫做 patch 过程。patch 意为”补丁”,即对旧的 VNode 修补，打补丁从而得到新的 VNode。<br>patch 的过程：<br>旧的 VNode(oldVNode)数据变化之前视图对应的虚拟 DOM 节点， 新的 VNode 是数据变化之后将要渲染的新的视图所对应的虚拟 DOM 节点，所以我们以新的 VNode 为基准，对比旧的 oldVNode ,如果新的 VNode 上有的节点而旧的 oldVNode 上没有，那么就在旧 oldVNode 上加上去；如果新<br>VNode 上没有而 oldVNode 上有，那么就在旧节点上去掉；如果新旧节点上都有，那么以新的 VNode 为基准，更新旧的 oldVNode，从而让新旧相同。</p><p>一句话：以新的 VNode 为基准改造旧的 oldVNode 使之成为跟新的 VNode 一样。</p><h2 id="创建节点"><a href="#创建节点" class="headerlink" title="创建节点"></a>创建节点</h2><p>VNode 类可以描述 6 种类型的节点，但是只有三种类型的节点能够被创建并插入到 DOM 中，即 元素节点、文本节点、注释节点。vue 在创建时会判断这个节点是什么类型，从而调用不同的方法创建并插入到 DOM 中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function createElm(vnode,parentElm,refElm)&#123;</span><br><span class="line">  const data = vnode.data</span><br><span class="line">  const children = vnode.children</span><br><span class="line">  const tag = vnode.tag</span><br><span class="line">  if (isDef(tag)) &#123;</span><br><span class="line">  vnode.elm = nodeOps.createElement(tag, vnode)   // 创建元素节点</span><br><span class="line">    createChildren(vnode, children, insertedVnodeQueue) // 创建元素节点的子节点</span><br><span class="line">    insert(parentElm, vnode.elm, refElm)       // 插入到DOM中</span><br><span class="line">  &#125; else if (isTrue(vnode.isComment)) &#123;</span><br><span class="line">    vnode.elm = nodeOps.createComment(vnode.text)  // 创建注释节点</span><br><span class="line">    insert(parentElm, vnode.elm, refElm)           // 插入到DOM中</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    vnode.elm = nodeOps.createTextNode(vnode.text)  // 创建文本节点</span><br><span class="line">    insert(parentElm, vnode.elm, refElm)           // 插入到DOM中</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>判断是否是元素节点只需要判断 VNode 节点是否有 tag 标签即可。</li><li>判断是否是注释节点，只需要判断 VNode 的 isComment 属性是否为 true 即可。</li><li>如果既不是元素节点又不是注释节点，那就认为是文本节点</li></ul><p>创建节点的流程图</p><p><img src="https://vue-js.com/learn-vue/assets/img/2.02d5c7b1.png" alt="avatar"></p><h2 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h2><p>删除节点，只需要在要删除节点的父元素上调用 removeChild 方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function removeNode (el) &#123;</span><br><span class="line">  cosnt parent = nodeOps.parentNode(el) // 获取父节点</span><br><span class="line">  if (isDef(parent)) &#123;</span><br><span class="line">    nodeOps.removeChild(parent,el) //调用父节点的removeChild 方法</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="更新节点"><a href="#更新节点" class="headerlink" title="更新节点"></a>更新节点</h2><p>更新节点需要在新的 VNode 和 oldVNode 进行细致的比较，找出不一样的地方进行更新。</p><ul><li>静态节点</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;不会变的文字&lt;/p&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面的节点只包含了纯文字，没有绑定变量，所以不管数据怎么变化，这个节点渲染后，那么它永远不会发生变化。 把这种节点称之为静态节点。</p><p>更新节点需要对三种情况进行判断并分别处理</p><ul><li><p>如果 VNode 和 oldVNode 均为静态节点</p><p>两者如果都是静态节点，则直接跳过，无需处理</p></li><li><p>如果 VNode 是文本节点</p><p>如果 VNode 是文本节点，则表示这个节点值包含纯文本，那么只需看 oldVNode 是否也是文本节点，如果是，那就比较两个文本是否不同，如若不同则把 oldVNode 里的文本改成和 VNode 的文本一样。如果 oldVNode 不是文本节点，那么不论是什么，直接调用 setTextNode 方法把它改变成文本节点，内容跟 VNode 相同。</p></li><li><p>如果 VNode 是元素节点</p><p>元素节点又分两种情况</p><ul><li>该节点包含子节点</li></ul><p>如果新的节点内包含子节点，那么此时就要看旧的节点是否包含子节点，如果旧的节点里也包含了子节点，那就需要递归对比更新子节点。如果旧的节点里不包含子节点，那么这个旧节点有可能是空节点或者是文本节点，如果旧的节点是空节点就把新的节点里的子节点创建一份插入到旧的节点里面。如果旧的节点是文本节点，则把文本清空，然后把新的节点里的子节点创建一份然后插入到旧的节点里面。</p><ul><li>该节点不包含子节点</li></ul><p>如果该节点不包含子节点，同时它又不是文本节点，那就说明该节点是个空节点不管旧节点里面有啥，直接清空即可。</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">// 更新节点</span><br><span class="line">function patchVnode (oldVnode, vnode, insertedVnodeQueue, removeOnly) &#123;</span><br><span class="line">  // vnode与oldVnode是否完全一样？若是，退出程序</span><br><span class="line">  if (oldVnode === vnode) &#123;</span><br><span class="line">    return</span><br><span class="line">  &#125;</span><br><span class="line">  const elm = vnode.elm = oldVnode.elm</span><br><span class="line"></span><br><span class="line">  // vnode与oldVnode是否都是静态节点？若是，退出程序</span><br><span class="line">  if (isTrue(vnode.isStatic) &amp;&amp;</span><br><span class="line">    isTrue(oldVnode.isStatic) &amp;&amp;</span><br><span class="line">    vnode.key === oldVnode.key &amp;&amp;</span><br><span class="line">    (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))</span><br><span class="line">  ) &#123;</span><br><span class="line">    return</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  const oldCh = oldVnode.children</span><br><span class="line">  const ch = vnode.children</span><br><span class="line">  // vnode有text属性？若没有：</span><br><span class="line">  if (isUndef(vnode.text)) &#123;</span><br><span class="line">    // vnode的子节点与oldVnode的子节点是否都存在？</span><br><span class="line">    if (isDef(oldCh) &amp;&amp; isDef(ch)) &#123;</span><br><span class="line">      // 若都存在，判断子节点是否相同，不同则更新子节点</span><br><span class="line">      if (oldCh !== ch) updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly)</span><br><span class="line">    &#125;</span><br><span class="line">    // 若只有vnode的子节点存在</span><br><span class="line">    else if (isDef(ch)) &#123;</span><br><span class="line">      /**</span><br><span class="line">       * 判断oldVnode是否有文本？</span><br><span class="line">       * 若没有，则把vnode的子节点添加到真实DOM中</span><br><span class="line">       * 若有，则清空Dom中的文本，再把vnode的子节点添加到真实DOM中</span><br><span class="line">       */</span><br><span class="line">      if (isDef(oldVnode.text)) nodeOps.setTextContent(elm, &#x27;&#x27;)</span><br><span class="line">      addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue)</span><br><span class="line">    &#125;</span><br><span class="line">    // 若只有oldnode的子节点存在</span><br><span class="line">    else if (isDef(oldCh)) &#123;</span><br><span class="line">      // 清空DOM中的子节点</span><br><span class="line">      removeVnodes(elm, oldCh, 0, oldCh.length - 1)</span><br><span class="line">    &#125;</span><br><span class="line">    // 若vnode和oldnode都没有子节点，但是oldnode中有文本</span><br><span class="line">    else if (isDef(oldVnode.text)) &#123;</span><br><span class="line">      // 清空oldnode文本</span><br><span class="line">      nodeOps.setTextContent(elm, &#x27;&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">    // 上面两个判断一句话概括就是，如果vnode中既没有text，也没有子节点，那么对应的oldnode中有什么就清空什么</span><br><span class="line">  &#125;</span><br><span class="line">  // 若有，vnode的text属性与oldVnode的text属性是否相同？</span><br><span class="line">  else if (oldVnode.text !== vnode.text) &#123;</span><br><span class="line">    // 若不相同：则用vnode的text替换真实DOM的文本</span><br><span class="line">    nodeOps.setTextContent(elm, vnode.text)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更新节点的流程</p><p><img src="https://vue-js.com/learn-vue/assets/img/3.7b0442aa.png" alt="avatar"></p>]]></content>
      
      
      <categories>
          
          <category> Vue.js 源码解读 </category>
          
          <category> 虚拟DOM </category>
          
          <category> Diff </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue.js 源码解读, 虚拟Dom</title>
      <link href="/2023/03/01/vue%E6%BA%90%E7%A0%811/"/>
      <url>/2023/03/01/vue%E6%BA%90%E7%A0%811/</url>
      
        <content type="html"><![CDATA[<h1 id="虚拟-Dom"><a href="#虚拟-Dom" class="headerlink" title="虚拟 Dom"></a>虚拟 Dom</h1><ul><li>什么是虚拟 DOM ？<br>虚拟 Dom,就是用一个 <code>JS</code> 对象来描述一个<code>DOM</code>节点。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;a&quot; id=&quot;b&quot;&gt;内容&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  tag: &#x27;div&#x27;,   // 元素标签</span><br><span class="line">  attrs:&#123;       // 属性</span><br><span class="line">    class:&#x27;a&#x27;,</span><br><span class="line">    id:&#x27;b&#x27;</span><br><span class="line">  &#125;,</span><br><span class="line">  text:&#x27;内容&#x27;,  // 文本内容</span><br><span class="line">  children:[]  // 子元素</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把组成一个<code>DOM</code>节点的必要东西通过一个 <code>JS</code> 对象表示出来，那么这个<code>JS</code> 对象就可以用来藐视这个<code>DOM</code>节点，我们把这个<code>JS</code>对象就称为是这个真实<code>DOM</code>节点的虚拟<code>DOM</code>节点。</p><ul><li>为什么要有虚拟 DOM ？<br><code>Vue</code> 是数据驱动视图的，数据发生变化视图就要随之更新，在更新视图的时候难免要操作<code>DOM</code>,操作<code>DOM</code>又是非常耗费性能的。但是我们逃不掉操作<code>DOM</code>,所以只能尽可能的减少操作<code>DOM</code> 。<br>最直观的方法就是不要盲目的去更新视图，而是通过对比数据变化的前后的状态，计算出视图中那些地方需要更新，只更新需要更新的地方。就是用<code>JS</code>的计算性能来换取操作<code>DOM</code>的性能。</li></ul><h2 id="Vue-中的虚拟-DOM"><a href="#Vue-中的虚拟-DOM" class="headerlink" title="Vue 中的虚拟 DOM"></a>Vue 中的虚拟 DOM</h2><h3 id="VNode-类"><a href="#VNode-类" class="headerlink" title="VNode 类"></a>VNode 类</h3><p>在<code>Vue</code>中就存在一个<code>VNode</code>类，通过这个类，我们就可以实例化出不同类型的虚拟<code>DOM</code>节点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">export default class VNode &#123;</span><br><span class="line">  constructor (</span><br><span class="line">    tag?: string,</span><br><span class="line">    data?: VNodeData,</span><br><span class="line">    children?: ?Array&lt;VNode&gt;,</span><br><span class="line">    text?: string,</span><br><span class="line">    elm?: Node,</span><br><span class="line">    context?: Component,</span><br><span class="line">    componentOptions?: VNodeComponentOptions,</span><br><span class="line">    asyncFactory?: Function</span><br><span class="line">  ) &#123;</span><br><span class="line">    this.tag = tag                                /*当前节点的标签名*/</span><br><span class="line">    this.data = data        /*当前节点对应的对象，包含了具体的一些数据信息，是一个VNodeData类型，可以参考VNodeData类型中的数据信息*/</span><br><span class="line">    this.children = children  /*当前节点的子节点，是一个数组*/</span><br><span class="line">    this.text = text     /*当前节点的文本*/</span><br><span class="line">    this.elm = elm       /*当前虚拟节点对应的真实dom节点*/</span><br><span class="line">    this.ns = undefined            /*当前节点的名字空间*/</span><br><span class="line">    this.context = context          /*当前组件节点对应的Vue实例*/</span><br><span class="line">    this.fnContext = undefined       /*函数式组件对应的Vue实例*/</span><br><span class="line">    this.fnOptions = undefined</span><br><span class="line">    this.fnScopeId = undefined</span><br><span class="line">    this.key = data &amp;&amp; data.key           /*节点的key属性，被当作节点的标志，用以优化*/</span><br><span class="line">    this.componentOptions = componentOptions   /*组件的option选项*/</span><br><span class="line">    this.componentInstance = undefined       /*当前节点对应的组件的实例*/</span><br><span class="line">    this.parent = undefined           /*当前节点的父节点*/</span><br><span class="line">    this.raw = false         /*简而言之就是是否为原生HTML或只是普通文本，innerHTML的时候为true，textContent的时候为false*/</span><br><span class="line">    this.isStatic = false         /*静态节点标志*/</span><br><span class="line">    this.isRootInsert = true      /*是否作为跟节点插入*/</span><br><span class="line">    this.isComment = false             /*是否为注释节点*/</span><br><span class="line">    this.isCloned = false           /*是否为克隆节点*/</span><br><span class="line">    this.isOnce = false                /*是否有v-once指令*/</span><br><span class="line">    this.asyncFactory = asyncFactory</span><br><span class="line">    this.asyncMeta = undefined</span><br><span class="line">    this.isAsyncPlaceholder = false</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  get child (): Component | void &#123;</span><br><span class="line">    return this.componentInstance</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="VNode-的类型"><a href="#VNode-的类型" class="headerlink" title="VNode 的类型"></a>VNode 的类型</h3><ul><li>注释节点</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 创建注释节点</span><br><span class="line">export const createEmptyVNode = (text: string = &#x27;&#x27;) =&gt; &#123;</span><br><span class="line">  const node = new VNode()</span><br><span class="line">  node.text = text          // 表示具体的注释信息，</span><br><span class="line">  node.isComment = true     // 是一个标志，用来标识一个节点是否是注释节点。</span><br><span class="line">  return node</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>文本节点</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 创建文本节点</span><br><span class="line"> export function createTextVNode (val: string | number)&#123;</span><br><span class="line">   return new VNode(undefined,undefined,undefined,String(val))</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ul><li>克隆节点</li></ul><p>克隆节点就是把一个已经存在的节点复制一份，主要是为了做模板编译优化时使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 创建克隆节点</span><br><span class="line">export function cloneVNode (vnode: VNode): VNode &#123;</span><br><span class="line">  const cloned = new VNode(</span><br><span class="line">    vnode.tag,</span><br><span class="line">    vnode.data,</span><br><span class="line">    vnode.children,</span><br><span class="line">    vnode.text,</span><br><span class="line">    vnode.elm,</span><br><span class="line">    vnode.context,</span><br><span class="line">    vnode.componentOptions,</span><br><span class="line">    vnode.asyncFactory</span><br><span class="line">  )</span><br><span class="line">  cloned.ns = vnode.ns</span><br><span class="line">  cloned.isStatic = vnode.isStatic</span><br><span class="line">  cloned.key = vnode.key</span><br><span class="line">  cloned.isComment = vnode.isComment</span><br><span class="line">  cloned.fnContext = vnode.fnContext</span><br><span class="line">  cloned.fnOptions = vnode.fnOptions</span><br><span class="line">  cloned.fnScopeId = vnode.fnScopeId</span><br><span class="line">  cloned.asyncMeta = vnode.asyncMeta</span><br><span class="line">  cloned.isCloned = true</span><br><span class="line">  return cloned</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>克隆节点就是把已有节点的属性全部复制到新节点中，而现有节点和新克隆得到的节点之间唯一的不同就是克隆得到的节点<code>isCloned</code> 为 <code>true</code>。</p><ul><li>元素节点</li></ul><p>元素节点更贴近我们通常看到的真实<code>DOM</code> 节点，有描述节点标签名词的<code>tag</code> 属性，描述节点属性<code>class</code>、<code>attributes</code>、等的<code>Data</code> 属性，有描述子节点信息的<code>children</code> 属性。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 真实Dom节点</span><br><span class="line">&lt;div id=&#x27;a&#x27;&gt;&lt;span&gt;难凉热血&lt;/span&gt;&lt;/div&gt;</span><br><span class="line">//VNode节点</span><br><span class="line">&#123;</span><br><span class="line">  tag:&#x27;div&#x27;,</span><br><span class="line">  data:&#123;&#125;,</span><br><span class="line">  children:[</span><br><span class="line">    &#123;</span><br><span class="line">      tag:&#x27;span&#x27;,</span><br><span class="line">      text:&#x27;难凉热血&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>组件节点</li></ul><p>组件节点除了有元素节点的属性之外，还有两个特有属性:<br>componentOptions:组件的 option 选项，如组件的 <code>props</code> 等<br>componentInstance:当前组件节点对应的<code>vue</code> 实例</p><ul><li>函数式组件节点</li></ul><p>函数式节点相较于组件节点，它又有两个特有的属性：<br>fnContext:函数组件对应的 Vue 实例<br>fnOptions:组件的 options 选项</p><h3 id="VNode-的作用"><a href="#VNode-的作用" class="headerlink" title="VNode 的作用"></a>VNode 的作用</h3><p>我们在视图渲染之前，把写好的<code>template</code> 模板先编译成<code>VNode</code> 并缓存下来，等到数据发生变化页面需要重新渲染的时候，我们把数据发生变化后生成的<code>VNode</code>与前一次缓存下来的<code>VNode</code>进行对比,找出差异，然后有差异的<code>VNode</code>对应的真实<code>DOM</code>节点就是需要重新渲染的节点，然后根据有差异的<code>VNode</code> 创建出真实的<code>DOM</code>节点再插入到视图中，最终完成一次视图更新。</p><p>总结：就是以<code>JS</code>的计算性能来换取操作真实<code>DOM</code>所消耗的性能。从源码角度我们知道了在 Vue 中是通过 VNode 类来实例化出不同类型的虚拟 DOM 节点，并且学习了不同类型节点生成的属性的不同，所谓不同类型的节点其本质还是一样的，都是 VNode 类的实例，只是在实例化时传入的属性参数不同罢了。最后探究了 VNode 的作用，有了数据变化前后的 VNode，我们才能进行后续的 DOM-Diff 找出差异，最终做到只更新有差异的视图，从而达到尽可能少的操作真实 DOM 的目的，以节省性能。</p>]]></content>
      
      
      <categories>
          
          <category> Vue.js 源码解读 </category>
          
          <category> 虚拟DOM </category>
          
          <category> Vue中的虚拟Dom </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue.js 源码解读,数据的变化侦听</title>
      <link href="/2023/03/01/vue%E6%BA%90%E7%A0%81/"/>
      <url>/2023/03/01/vue%E6%BA%90%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h1 id="变化侦听"><a href="#变化侦听" class="headerlink" title="变化侦听"></a>变化侦听</h1><p>数据驱动视图的关键在于怎么知道数据发生了变化。<code>js</code> 为我们提供了 <code>Object.defineProperty</code> 方法。该方法可以知道数据在什么时候发生变化。</p><h2 id="使-Object-数据变得可观测"><a href="#使-Object-数据变得可观测" class="headerlink" title="使 Object 数据变得可观测"></a>使 Object 数据变得可观测</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">let car = &#123;&#125;</span><br><span class="line">let val = 3000</span><br><span class="line">Object.defineProperty(car,&#x27;price&#x27;,&#123;</span><br><span class="line">  enumber: true,</span><br><span class="line">  configurable: true,</span><br><span class="line">  get()&#123;</span><br><span class="line">    console.log(&#x27;price 属性被读取&#x27;)</span><br><span class="line">    return val</span><br><span class="line">  &#125;,</span><br><span class="line">  set(newVal)&#123;</span><br><span class="line">    console.log(&#x27;price 属性值被修改)</span><br><span class="line">    val = newVal</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">car.price</span><br><span class="line">  // price属性被读取了</span><br><span class="line">  // 3000</span><br><span class="line">car.price = 4000</span><br><span class="line">  // price属性值被修改了</span><br><span class="line">  // 4000</span><br></pre></td></tr></table></figure><p>经过上面的方法，car 数据对象已经是 <code>可观测</code> 的了。<br>为了把 car 对象所有的属性都变得可观测</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Observer类会通过递归的方式把一个对象的所有属性都转化成可观测对象</span><br><span class="line"> */</span><br><span class="line">export class Observer &#123;</span><br><span class="line">  constructor (value) &#123;</span><br><span class="line">    this.value = value</span><br><span class="line">    // 给value新增一个__ob__属性，值为该value的Observer实例</span><br><span class="line">    // 相当于为value打上标记，表示它已经被转化成响应式了，避免重复操作</span><br><span class="line">    def(value,&#x27;__ob__&#x27;,this)</span><br><span class="line">    if (Array.isArray(value)) &#123;</span><br><span class="line">      // 当value为数组时的逻辑</span><br><span class="line">      // ...</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      this.walk(value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  walk (obj: Object) &#123;</span><br><span class="line">    const keys = Object.keys(obj)</span><br><span class="line">    for (let i = 0; i &lt; keys.length; i++) &#123;</span><br><span class="line">      defineReactive(obj, keys[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 使一个对象转化成可观测对象</span><br><span class="line"> * @param &#123; Object &#125; obj 对象</span><br><span class="line"> * @param &#123; String &#125; key 对象的key</span><br><span class="line"> * @param &#123; Any &#125; val 对象的某个key的值</span><br><span class="line"> */</span><br><span class="line">function defineReactive (obj,key,val) &#123;</span><br><span class="line">  // 如果只传了obj和key，那么val = obj[key]</span><br><span class="line">  if (arguments.length === 2) &#123;</span><br><span class="line">    val = obj[key]</span><br><span class="line">  &#125;</span><br><span class="line">  if(typeof val === &#x27;object&#x27;)&#123;</span><br><span class="line">      new Observer(val)</span><br><span class="line">  &#125;</span><br><span class="line">  Object.defineProperty(obj, key, &#123;</span><br><span class="line">    enumerable: true,</span><br><span class="line">    configurable: true,</span><br><span class="line">    get()&#123;</span><br><span class="line">      console.log(`$&#123;key&#125;属性被读取了`);</span><br><span class="line">      return val;</span><br><span class="line">    &#125;,</span><br><span class="line">    set(newVal)&#123;</span><br><span class="line">      if(val === newVal)&#123;</span><br><span class="line">          return</span><br><span class="line">      &#125;</span><br><span class="line">      console.log(`$&#123;key&#125;属性被修改了`);</span><br><span class="line">      val = newVal;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="依赖收集"><a href="#依赖收集" class="headerlink" title="依赖收集"></a>依赖收集</h2><h3 id="什么是依赖收集"><a href="#什么是依赖收集" class="headerlink" title="什么是依赖收集"></a>什么是依赖收集</h3><p>通过上面的方法，让<code>object</code>变的可观测，我们知道数据什么时候发生了变化，我们去通知视图更新，我们到底通知那个模块发生变化？ 不能一个数据发生变化，整个视图就发生更新，因此我们只更新视图中用到这个数据就发生更新。也就是 <code>谁依赖了这个数据</code>，我们为每个数据都建一个依赖数组，谁依赖这个数据，我们就将谁放入这个依赖数组中，那么当该数据发生变化时我们就去它对应的依赖数组中，把每个依赖都通知一遍，发生更新。</p><h3 id="什么时候收集依赖，什么时候通知以此来更新"><a href="#什么时候收集依赖，什么时候通知以此来更新" class="headerlink" title="什么时候收集依赖，什么时候通知以此来更新"></a>什么时候收集依赖，什么时候通知以此来更新</h3><p>在 getter 中收集依赖，在 setter 中通知依赖更新</p><h3 id="依赖收集到哪里"><a href="#依赖收集到哪里" class="headerlink" title="依赖收集到哪里"></a>依赖收集到哪里</h3><p>我们给每个数据都建一个依赖数组，蛋蛋用一个数组的来存放依赖的话，功能欠缺并且代码过于耦合。更好的做法是我们为每一个依赖数据都建立一个依赖管理器，将该数据的依赖都管理起来。 依赖管理器 <code>Dep</code>类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">// 源码位置：src/core/observer/dep.js</span><br><span class="line">export default class Dep &#123;</span><br><span class="line">  constructor () &#123;</span><br><span class="line">    this.subs = []</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  addSub (sub) &#123;</span><br><span class="line">    this.subs.push(sub)</span><br><span class="line">  &#125;</span><br><span class="line">  // 删除一个依赖</span><br><span class="line">  removeSub (sub) &#123;</span><br><span class="line">    remove(this.subs, sub)</span><br><span class="line">  &#125;</span><br><span class="line">  // 添加一个依赖</span><br><span class="line">  depend () &#123;</span><br><span class="line">    if (window.target) &#123;</span><br><span class="line">      this.addSub(window.target)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // 通知所有依赖更新</span><br><span class="line">  notify () &#123;</span><br><span class="line">    const subs = this.subs.slice()</span><br><span class="line">    for (let i = 0, l = subs.length; i &lt; l; i++) &#123;</span><br><span class="line">      subs[i].update()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Remove an item from an array</span><br><span class="line"> */</span><br><span class="line">export function remove (arr, item) &#123;</span><br><span class="line">  if (arr.length) &#123;</span><br><span class="line">    const index = arr.indexOf(item)</span><br><span class="line">    if (index &gt; -1) &#123;</span><br><span class="line">      return arr.splice(index, 1)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了依赖管理器后，在 getter 中收集依赖，在 setter 中通知依赖更新，代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">function defineReactive (obj,key,val)&#123;</span><br><span class="line">  if (arguments.length === 2) &#123;</span><br><span class="line">    val = obj[key]</span><br><span class="line">  &#125;</span><br><span class="line">  if (typeof val === &#x27;Object&#x27;) &#123;</span><br><span class="line">    new Observer(val)</span><br><span class="line">  &#125;</span><br><span class="line">  cosnt dep = new Dep() // 实例化一个依赖管理器，生成一个依赖管理数组 dep</span><br><span class="line">  Object.defineProperty(obj,key,&#123;</span><br><span class="line">    enumberable:true,</span><br><span class="line">    configurable:true,</span><br><span class="line">    get () &#123;</span><br><span class="line">      dep.depend() // 在getter中收集依赖</span><br><span class="line">      return val</span><br><span class="line">    &#125;,</span><br><span class="line">    set (newVal) &#123;</span><br><span class="line">      if(val == newVal) &#123;</span><br><span class="line">        return</span><br><span class="line">      &#125;</span><br><span class="line">      val = newVal</span><br><span class="line">      dep.notify()  // 在setter中通知依赖更新</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="依赖到底是-Who"><a href="#依赖到底是-Who" class="headerlink" title="依赖到底是 Who"></a>依赖到底是 Who</h4><p>一直在说 <code>谁用到了这个数据谁就是依赖</code>，在代码层面上该如何来描述这个<code>谁</code>。<br>在 <code>Vue</code> 中有一个叫 <code>Watcher</code> 的类，该类的实例就是我们上面说的那个<code>谁</code>，也就是谁用到了数据，谁就是依赖，我们为谁创建一个<code>Watcher</code>实例，在之后数据发生变化时，我们不直接通知依赖更新，而是通知依赖对应的 <code>watch</code> 实例，由 <code>Watchr</code>实例去通知真正的视图。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">export default class Watcher &#123;</span><br><span class="line">  constructor (vm,expOrFn,cb) &#123;</span><br><span class="line">    this.vm = vm;</span><br><span class="line">    this.cb = cb;</span><br><span class="line">    this.getter = parsePath(expOrFn)</span><br><span class="line">    this.value = this.get()</span><br><span class="line">  &#125;</span><br><span class="line">  get () &#123;</span><br><span class="line">    window.target = this;</span><br><span class="line">    const vm = this.vm</span><br><span class="line">    let value = this.getter.call(vm,vm)</span><br><span class="line">    window.target = undefined;</span><br><span class="line">    return value</span><br><span class="line">  &#125;</span><br><span class="line">  update () &#123;</span><br><span class="line">    const oldVlaue = this.value</span><br><span class="line">    this.value = this.get()</span><br><span class="line">    this.cb.call(this.vm,this.value,oldValue)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">const bailRE = /[^\w.$]/</span><br><span class="line">export function parsePath (path) &#123;</span><br><span class="line">  if (bailRE.test(path)) &#123;</span><br><span class="line">    return</span><br><span class="line">  &#125;</span><br><span class="line">  const segments = path.split(&#x27;.&#x27;)</span><br><span class="line">  return function (obj) &#123;</span><br><span class="line">    for (let i = 0; i &lt; segments.length; i++) &#123;</span><br><span class="line">      if (!obj) return</span><br><span class="line">      obj = obj[segments[i]]</span><br><span class="line">    &#125;</span><br><span class="line">    return obj</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Watcher</code>类代码实现逻辑</p><ul><li><p>当实例化<code>Watcher</code>类时，会先执行其构造函数；</p></li><li><p>在构造函数中调用了<code>this.get()</code>实例方法</p></li><li><p>在<code>get()</code>方法中，首先通过 <code>window.target = this</code> 把实例自身赋值给了一个全局<br>的一个唯一对象<code>window.target</code> 上，然后通过 <code>let value = this.getter.call(vm,vm)</code> 获取一下被依赖的数据，获取被依赖数据的目的是触发该数据上面的<code>getter</code>,在<code>getter</code> 里会调用<code>dep.depend()</code> 收集依赖，而在<code>dep.depend()</code>中取到挂<code>window.target</code> 上的值并将其存入依赖数组中，在<code>get()</code>方法最后将<code>window.target</code>释放掉。</p></li><li><p>当数据变化时，会触发数据的<code>setter</code>，在<code>setter</code>中调用<code>dep.notify()</code>方法，在<code>dep.notify()</code> 方法中，遍历所有依赖(即 watcher 实例)，执行依赖的<code>update()</code>方法，也就时 <code>Watcher</code>类中的<code>update()</code>实例方法，在<code>update()</code> 方法中调用数据变化的更新回调函数，从而更新视图。</p><p><img src="https://vue-js.com/learn-vue/assets/img/3.0b99330d.jpg" alt="avatar"></p></li></ul><p>以上的流程是</p><ul><li><p><code>Data</code> 通过 <code>observer</code> 转换成了 <code>getter/setter</code>的形式来追踪变化</p></li><li><p>当外界通过<code>Watcher</code>读取数据时，会触发<code>getter</code>从而将 <code>Watcher</code> 添加到依赖中。</p></li><li><p>当数据发生了变化时，会触发<code>setter</code>, 从而向 <code>Dep</code> 中的依赖(即 Watcher) 发送通知。</p></li><li><p><code>Watcher</code> 接收到通知后，会向外界发送通知，变化通知到外界后可能会触发视图更新，也有可能触发用户的某个回调函数等。</p></li></ul><h2 id="Array-的变化侦测"><a href="#Array-的变化侦测" class="headerlink" title="Array 的变化侦测"></a>Array 的变化侦测</h2><h3 id="收集依赖的地方"><a href="#收集依赖的地方" class="headerlink" title="收集依赖的地方"></a>收集依赖的地方</h3><p><code>Array</code> 型数据的依赖收集方式和 <code>Object</code> 数据的依赖收集方式相同，都是在<code>getter</code>中收集。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data()&#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    arr:[1,2,3]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在组件<code>data</code>中，<code>arr</code>这个数据始终存在于一个<code>Object</code>数据对象中，谁用到了数据谁就是依赖，那么用到<code>arr</code>这个数据，得先从<code>Object</code>数据对象中获取一下，从<code>Object</code>数据对象中获取<code>arr</code>数据自然会触发 <code>arr</code>的 <code>getter</code><br><code>Array型数据还是在getter中收集依赖</code></p><h3 id="使-Array-型数据可观测"><a href="#使-Array-型数据可观测" class="headerlink" title="使 Array 型数据可观测"></a>使 Array 型数据可观测</h3><ul><li>实现思路<br>要想让<code>Array</code> 型数据发生变化，必然是操作了 <code>Array</code> , 而 <code>js</code> 中提供的操作数组的方法是固定的，可以将这些方法都重写一遍，在不改变原有功能的前提下，为其新增一些其他功能，</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let arr = [1,2,3]</span><br><span class="line">arr.push(4)</span><br><span class="line">Array.prototype.newPush = function(val)&#123;</span><br><span class="line">  console.log(&#x27;arr 数组被改变了&#x27;)</span><br><span class="line">  this.push(val)</span><br><span class="line">&#125;</span><br><span class="line">arr.newPush(4) // [1,2,3,4]</span><br></pre></td></tr></table></figure><ul><li>数组方法拦截器</li></ul><p>在<code>Vue</code>中创建一个数组方法拦截器，拦截在数组实例与<code>Array.prototype</code>之间，在拦截器内部重写操作数组的一些方法，当数组实例使用操作数组方法时，其实使用的是拦截器中重写的方法，不再使用<code>Array.prototype</code> 上的原生方法</p><p><img src="https://vue-js.com/learn-vue/assets/img/2.b446ab83.png" alt="avatar"></p><p>源码中的拦截器代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">const arrayProto = Array.prototype</span><br><span class="line">export const arrayMethods = Object.create(arrayProto)</span><br><span class="line"></span><br><span class="line">// 改变数组自身内容的7个方法</span><br><span class="line">const methodsToPatch = [</span><br><span class="line">  &#x27;push&#x27;,</span><br><span class="line">  &#x27;pop&#x27;,</span><br><span class="line">  &#x27;shift&#x27;,</span><br><span class="line">  &#x27;unshift&#x27;,</span><br><span class="line">  &#x27;splice&#x27;,</span><br><span class="line">  &#x27;sort&#x27;,</span><br><span class="line">  &#x27;reverse&#x27;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Intercept mutating methods and emit events</span><br><span class="line"> */</span><br><span class="line">methodsToPatch.forEach(function (method) &#123;</span><br><span class="line">  const original = arrayProto[method]      // 缓存原生方法</span><br><span class="line">  Object.defineProperty(arrayMethods, method, &#123;</span><br><span class="line">    enumerable: false,</span><br><span class="line">    configurable: true,</span><br><span class="line">    writable: true,</span><br><span class="line">    value:function mutator(...args)&#123;</span><br><span class="line">      const result = original.apply(this, args)</span><br><span class="line">      return result</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>拦截器的使用</li></ul><p>源码实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">export default Observer &#123;</span><br><span class="line">  constructor (value) &#123;</span><br><span class="line">    this.value = value</span><br><span class="line">    if (Array.isArray(value)) &#123;</span><br><span class="line">      const augment = hasProto ? protoAugment : copyAugment</span><br><span class="line">      augment(value,arrayMethods,arrayKeys)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      this.walk(value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 能力检测： 判断 __proto__ 是否可用，有浏览器不支持该属性</span><br><span class="line">export const hasProto = &#x27;__proto__&#x27; in &#123;&#125;</span><br><span class="line">const arrayKeys = Object.getOwnPropertyNames(arrayMethods)</span><br><span class="line">/**</span><br><span class="line"> * Augment an target Object or Array by intercepting</span><br><span class="line"> * the prototype chain using __proto__</span><br><span class="line"> */</span><br><span class="line">function protoAugment (target, src: Object, keys: any) &#123;</span><br><span class="line">  target.__proto__ = src</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Augment an target Object or Array by defining</span><br><span class="line"> * hidden properties.</span><br><span class="line"> */</span><br><span class="line">/* istanbul ignore next */</span><br><span class="line">function copyAugment (target: Object, src: Object, keys: Array&lt;string&gt;) &#123;</span><br><span class="line">  for (let i = 0, l = keys.length; i &lt; l; i++) &#123;</span><br><span class="line">    const key = keys[i]</span><br><span class="line">    def(target, key, src[key])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="依赖收集-1"><a href="#依赖收集-1" class="headerlink" title="依赖收集"></a>依赖收集</h3><p>数组的依赖收集也在<code>getter</code> 中收集，而给数组数据添加<code>getter/setter</code> 都是在<code>Observer</code>类中完成的，在<code>Observer</code>类中收集依赖。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">export class Observer &#123;</span><br><span class="line">  constructor (value) &#123;</span><br><span class="line">    this.value = value</span><br><span class="line">    this.dep = new Dep()</span><br><span class="line">    if (Array.isArray(value)) &#123;</span><br><span class="line">      const augment = hasProto</span><br><span class="line">        ? protoAugment</span><br><span class="line">        : copyAugment</span><br><span class="line">      augment(value, arrayMethods, arrayKeys)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      this.walk(value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>怎样收集依赖</li></ul><p>依赖管理器定义在<code>Observer</code> 类中，而我们需要在<code>getter</code>中收集依赖，也就是说我们必须在<code>getter</code>中能够访问到<code>Observer</code>类中的依赖管理器，才能把依赖存进去。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">function defineReactive (obj,key,val) &#123;</span><br><span class="line">  let childOb = observe(val)</span><br><span class="line">  Object.defineProperty(obj, key, &#123;</span><br><span class="line">    enumerable: true,</span><br><span class="line">    configurable: true,</span><br><span class="line">    get()&#123;</span><br><span class="line">      if (childOb) &#123;</span><br><span class="line">        childOb.dep.depend()</span><br><span class="line">      &#125;</span><br><span class="line">      return val;</span><br><span class="line">    &#125;,</span><br><span class="line">    set(newVal)&#123;</span><br><span class="line">      if(val === newVal)&#123;</span><br><span class="line">        return</span><br><span class="line">      &#125;</span><br><span class="line">      val = newVal;</span><br><span class="line">      dep.notify()   // 在setter中通知依赖更新</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Attempt to create an observer instance for a value,</span><br><span class="line"> * returns the new observer if successfully observed,</span><br><span class="line"> * or the existing observer if the value already has one.</span><br><span class="line"> * 尝试为value创建一个0bserver实例，如果创建成功，直接返回新创建的Observer实例。</span><br><span class="line"> * 如果 Value 已经存在一个Observer实例，则直接返回它</span><br><span class="line"> */</span><br><span class="line">export function observe (value, asRootData)&#123;</span><br><span class="line">  if (!isObject(value) || value instanceof VNode) &#123;</span><br><span class="line">    return</span><br><span class="line">  &#125;</span><br><span class="line">  let ob</span><br><span class="line">  if (hasOwn(value, &#x27;__ob__&#x27;) &amp;&amp; value.__ob__ instanceof Observer) &#123;</span><br><span class="line">    ob = value.__ob__</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    ob = new Observer(value)</span><br><span class="line">  &#125;</span><br><span class="line">  return ob</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>怎样通知依赖</li></ul><p>要想通知依赖，首先能访问到依赖，即只要能访问到被转化成响应式的数据 <code>value</code> 即可，因为<code>value</code> 上的 <code>__ob__</code>就是其对应的<code>Observer</code> 类实例，有了该实例我们就能访问到它上面的依赖管理器，然后只需要调用依赖管理的 <code>dep.notify()</code> 方法，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 源码</span><br><span class="line">methodsToPatch.forEach(function (method) &#123;</span><br><span class="line">  const original = arrayProto[method]</span><br><span class="line">  def(arrayMethods, method, function mutator (...args) &#123;</span><br><span class="line">    const result = original.apply(this, args)</span><br><span class="line">    const ob = this.__ob__</span><br><span class="line">    // notify change</span><br><span class="line">    ob.dep.notify()</span><br><span class="line">    return result</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="深度侦测"><a href="#深度侦测" class="headerlink" title="深度侦测"></a>深度侦测</h3><p>在前文所有讲的 Array 型数据的变化侦测都仅仅说的是数组自身变化的侦测，比如给数组新增一个元素或删除数组中一个元素，而在 Vue 中，不论是 Object 型数据还是 Array 型数据所实现的数据变化侦测都是深度侦测，所谓深度侦测就是不但要侦测数据自身的变化，还要侦测数据中所有子数据的变化。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let arr = [</span><br><span class="line">  &#123;</span><br><span class="line">    name:&#x27;NLRX&#x27;，</span><br><span class="line">    age:&#x27;18&#x27;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>数组中包含一个对象，如果该对象的某个属性发生了变化也应该被侦测到，就是深度侦测。<br>实现逻辑</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">export class Observer &#123;</span><br><span class="line">  value: any;</span><br><span class="line">  dep: Dep;</span><br><span class="line"></span><br><span class="line">  constructor (value: any) &#123;</span><br><span class="line">    this.value = value</span><br><span class="line">    this.dep = new Dep()</span><br><span class="line">    def(value, &#x27;__ob__&#x27;, this)</span><br><span class="line">    if (Array.isArray(value)) &#123;</span><br><span class="line">      const augment = hasProto</span><br><span class="line">        ? protoAugment</span><br><span class="line">        : copyAugment</span><br><span class="line">      augment(value, arrayMethods, arrayKeys)</span><br><span class="line">      this.observeArray(value)   // 将数组中的所有元素都转化为可被侦测的响应式</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      this.walk(value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * Observe a list of Array items.</span><br><span class="line">   */</span><br><span class="line">  observeArray (items: Array&lt;any&gt;) &#123;</span><br><span class="line">    for (let i = 0, l = items.length; i &lt; l; i++) &#123;</span><br><span class="line">      observe(items[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function observe (value, asRootData)&#123;</span><br><span class="line">  if (!isObject(value) || value instanceof VNode) &#123;</span><br><span class="line">    return</span><br><span class="line">  &#125;</span><br><span class="line">  let ob</span><br><span class="line">  if (hasOwn(value, &#x27;__ob__&#x27;) &amp;&amp; value.__ob__ instanceof Observer) &#123;</span><br><span class="line">    ob = value.__ob__</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    ob = new Observer(value)</span><br><span class="line">  &#125;</span><br><span class="line">  return ob</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组新增元素的侦测"><a href="#数组新增元素的侦测" class="headerlink" title="数组新增元素的侦测"></a>数组新增元素的侦测</h3><p>向数组内新增的方法有 3 个，分别是：push、unshift、splice。我们只需对这 3 中方法分别处理，拿到新增的元素，再将其转化即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Intercept mutating methods and emit events</span><br><span class="line"> */</span><br><span class="line">methodsToPatch.forEach(function (method) &#123;</span><br><span class="line">  // cache original method</span><br><span class="line">  const original = arrayProto[method]</span><br><span class="line">  def(arrayMethods, method, function mutator (...args) &#123;</span><br><span class="line">    const result = original.apply(this, args)</span><br><span class="line">    const ob = this.__ob__</span><br><span class="line">    let inserted</span><br><span class="line">    switch (method) &#123;</span><br><span class="line">      case &#x27;push&#x27;:</span><br><span class="line">      case &#x27;unshift&#x27;:</span><br><span class="line">        inserted = args   // 如果是push或unshift方法，那么传入参数就是新增的元素</span><br><span class="line">        break</span><br><span class="line">      case &#x27;splice&#x27;:</span><br><span class="line">        inserted = args.slice(2) // 如果是splice方法，那么传入参数列表中下标为2的就是新增的元素</span><br><span class="line">        break</span><br><span class="line">    &#125;</span><br><span class="line">    if (inserted) ob.observeArray(inserted) // 调用observe函数将新增的元素转化成响应式</span><br><span class="line">    // notify change</span><br><span class="line">    ob.dep.notify()</span><br><span class="line">    return result</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Vue.js 源码解读 </category>
          
          <category> 变化侦测 </category>
          
          <category> 数据的变化侦听 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue.js 源码解读, 虚拟Dom</title>
      <link href="/2023/03/01/props%E4%B8%8EData%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2023/03/01/props%E4%B8%8EData%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h1 id="Vue-中的Props-与-Data-细微差别。"><a href="#Vue-中的Props-与-Data-细微差别。" class="headerlink" title="Vue 中的Props 与 Data 细微差别。"></a>Vue 中的Props 与 Data 细微差别。</h1><p>Vue 提供了两种不同的存储变量: <code>props</code> 和 <code>data</code>。</p><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p><code>data</code> 是每个组件的私有内存，可以在其中存储需要的任何变量。<code>props</code>是将数据从父组件传递到子组件的方式。</p><h2 id="什么是-props"><a href="#什么是-props" class="headerlink" title="什么是 props"></a>什么是 props</h2><p>在 <code>Vue</code> 中 <code>props</code> 是我们将数据从父组件向下传递到其子组件的方式。<br>当我们从组件内部访问<code>props</code>时，我们并不拥有他们，我们不能更改他们。</p><h2 id="什么是-Data"><a href="#什么是-Data" class="headerlink" title="什么是 Data"></a>什么是 Data</h2><p><code>data</code> 是每个组件的内存，这就是存储数据和希望跟踪的任何其他变量的地方。</p><h2 id="props-和-data-都是响应式的"><a href="#props-和-data-都是响应式的" class="headerlink" title="props 和 data 都是响应式的"></a>props 和 data 都是响应式的</h2>]]></content>
      
      
      <categories>
          
          <category> Vue.js </category>
          
          <category> Props与Data的区别 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>vue2 VS vue3,</title>
      <link href="/2023/03/01/vue2vsvue3/beagin/"/>
      <url>/2023/03/01/vue2vsvue3/beagin/</url>
      
        <content type="html"><![CDATA[<h1 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h1><h2 id="组合API"><a href="#组合API" class="headerlink" title="组合API"></a>组合API</h2><p>vue2 是 <code>选项式API(Option API)</code>，一个逻辑会散落在文件的不同位置(data、props、computed、watch、生命周期函数等)，导致代码的可读性变差，需要上下来回滚动跳转文件位置。Vue3 <code>组合式 API(Composition API)</code>则很好地解决这个问题，可将同一逻辑的内容写到一起。增强了代码的可读性、内聚性，还提供了较为完美的逻辑复用方案，<br>例子🌰<br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">   &lt;span&gt; mouse position &#123;&#123;x&#125;&#125;  &#123;&#123;y&#125;&#125;&lt;/span&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">  import &#123; ref &#125; from &#x27;vue&#x27;</span><br><span class="line">  import useMousePosition from &#x27;./useMousePosition&#x27;</span><br><span class="line">  const &#123;x,y&#125;  = useMousePosition()</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">  </span><br><span class="line">// useMousePosition.js</span><br><span class="line"></span><br><span class="line">import &#123; ref, onMounted, onUnmounted &#125; from &#x27;vue&#x27;</span><br><span class="line">function useMousePosition() &#123;</span><br><span class="line">  let x = ref(0)</span><br><span class="line">  let y = ref(0)</span><br><span class="line"></span><br><span class="line">   function update(e) &#123;</span><br><span class="line">    x.value = e.pageX</span><br><span class="line">    y.value = e.pageY</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  onMounted(() =&gt; &#123;</span><br><span class="line">    window.addEventListener(&#x27;mousemove&#x27;, update)</span><br><span class="line">  &#125;)</span><br><span class="line">  </span><br><span class="line">  onUnmounted(() =&gt; &#123;</span><br><span class="line">    window.removeEventListener(&#x27;mousemove&#x27;, update)</span><br><span class="line">  &#125;)</span><br><span class="line">  </span><br><span class="line">  return &#123;</span><br><span class="line">    x,</span><br><span class="line">    y</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>  <code>解决vue2 mixin 的存在命名冲突隐患，依赖不明确，不同组件间配置化不够灵活</code></p><h2 id="响应式原理"><a href="#响应式原理" class="headerlink" title="响应式原理"></a>响应式原理</h2><p>vue2 响应式原理基础是 Object.defineProperty; Vue3 响应式原理基础是 Proxy </p><h3 id="Object-defineProperty"><a href="#Object-defineProperty" class="headerlink" title="Object.defineProperty"></a>Object.defineProperty</h3><p>直接在对象上定义一个新的属性或者修改现有的属性，并返回对象。存在的缺陷是：无法监听对象或者数组新增、删除元素。Vue2 方案针对常用数组原型方法 push、pop、shuift、unshift、splice、 sort、reverse进行了封装处理</p>]]></content>
      
      
      <categories>
          
          <category> vue2 与 vue3 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JS 事件</title>
      <link href="/2023/03/01/js%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/%E4%BA%8B%E4%BB%B6/"/>
      <url>/2023/03/01/js%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/%E4%BA%8B%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是事件"><a href="#什么是事件" class="headerlink" title="什么是事件"></a>什么是事件</h2><p>  JavaScript 和 HTML 之间交互是通过事件实现的，事件就是文档或浏览器窗口中发生的一些特定的交互瞬间。事件在浏览器中是以对象的形式存在</p><h2 id="怎样添加事件"><a href="#怎样添加事件" class="headerlink" title="怎样添加事件"></a>怎样添加事件</h2><h3 id="DOM-元素事件属性"><a href="#DOM-元素事件属性" class="headerlink" title="DOM 元素事件属性"></a>DOM 元素事件属性</h3><pre><code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onClick=&quot;clickFun()&quot;&gt;添加事件&lt;/button&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></code></pre><h3 id="脚本添加事件"><a href="#脚本添加事件" class="headerlink" title="脚本添加事件"></a>脚本添加事件</h3>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;button id=&quot;myBtn&quot;&gt;点击这里&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">document.getElementById(&#x27;myBtn&#x27;).onclick = function()&#123;</span><br><span class="line">  clickFun()</span><br><span class="line">&#125;</span><br><span class="line">document.getElementById(&#x27;myBtn&#x27;).addEventListener(&#x27;clcik&#x27;,function()&#123;</span><br><span class="line">  clickFun()</span><br><span class="line">&#125;,false)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h2><pre><code>`事件捕获、事件冒泡、原事件`</code></pre><h3 id="事件捕获"><a href="#事件捕获" class="headerlink" title="事件捕获"></a>事件捕获</h3><p>  事件捕获：事件从最不具体的节点开始接收(document),传递到最具体的节点,事件捕获的本意时当事件到达预定目标前捕获它。</p><p>当我们点击页面代码中id为box的div块，点击事件会按照如下顺序传播<br>document —&gt; html —&gt; body —&gt; div</p><p><img src="https://segmentfault.com/img/bVYi7V?w=394&h=324" alt="事件捕获"></p><h3 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h3><p>  IE 的事件流称为事件冒泡<br>  事件冒泡：事件由最具体的元素接收，逐级向上传播到不具体的节点(document)</p><p>  当我们点击id 为box 的代码块时，点击事件会按照如下顺序传播</p><p>  div —&gt; body —&gt; html —&gt; document</p><p>  <img src="https://segmentfault.com/img/bVYi6Y?w=435&h=368" alt="事件冒泡"></p><h3 id="DOM2-级事件流"><a href="#DOM2-级事件流" class="headerlink" title="DOM2 级事件流"></a>DOM2 级事件流</h3><p>  为了能够兼容上述两种事件模型，又提出了一个 DOM2级事件模型，它规定了事件流包含三个阶段</p><ul><li>事件捕获阶段: 为事件捕获提供机会</li><li>处于目标阶段: 事件的目标接收到事件(但并不会做出响应)</li><li>事件冒泡阶段: 事件响应阶段</li></ul><h3 id="事件流的典型应用-————-事件代理"><a href="#事件流的典型应用-————-事件代理" class="headerlink" title="事件流的典型应用 ———— 事件代理"></a>事件流的典型应用 ———— 事件代理</h3><p> 事件代理的原理就是事件冒泡和目标元素，把事件处理添加到父元素，等待子元素事件冒泡，并且父元素能够通过 target 判断是哪个子元素，从而做相应的处理。</p><ul><li>事件代理的好处<ul><li>将多个事件处理器减少到一个，事件处理器需要驻留在内存，这样提高了性能</li><li>DOM 更新无需重新绑定事件处理器，如果新增子元素，直接修改事件代理的事件处理函数即可，不需要重新绑定处理器，不需要再次循环遍历。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> js知识体系 </category>
          
          <category> 事件 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>js 语言的三大特性</title>
      <link href="/2023/03/01/js%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7/"/>
      <url>/2023/03/01/js%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>  JavaScript 是一种基于对象的语言，我们所遇到的东西几乎都是对象。<br>  在 JS中，封装的过程就是把一些属性和方法放到对象中 “包裹” 起来，<br>  封装：就是把事务封装成类，隐藏事物的属性和方法的实现细节，仅对外公开接口。<br>  封装的好处：使用封装，可以达到代码的复用，使代码更加简洁<br>  <code>将属性和方法组成一个类的过程就是封装</code></p><ul><li><p>通过构造函数添加<br>JavaScript 提供了一个构造函数模式，用来创建对象时初始化对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">functuon Cat(name,color) &#123;</span><br><span class="line">  this.name = name</span><br><span class="line">  this.colot = color</span><br><span class="line">  this.eat = ( () =&gt; &#123;</span><br><span class="line">    console.log(&#x27;🐟&#x27;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">// 生成实例</span><br><span class="line">var cat1 = new Cat(&#x27;tom&#x27;,&#x27;gray&#x27;)</span><br></pre></td></tr></table></figure></li><li><p>通过原型 prototype 封装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function Cat(name,color) &#123;</span><br><span class="line">  this.name = name</span><br><span class="line">  this.color = color</span><br><span class="line">&#125;</span><br><span class="line">Cat.prototype.type = &#x27;英短&#x27;</span><br><span class="line">Cat.prototype.eat = ( () =&gt; &#123;</span><br><span class="line">  alert(&#x27;🐟&#x27;)</span><br><span class="line">&#125;)</span><br><span class="line">// 生成实例</span><br><span class="line">var cat1 = new Cat(&#x27;Tom&#x27;,&#x27;gray&#x27;)</span><br><span class="line">var cat2 = new Cat(&#x27;Kobe&#x27;,&#x27;purple&#x27;)</span><br><span class="line">console.log(cat1.type)</span><br><span class="line">cat2.eat()</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>继承：我们想要一个对象能够访问另一个对象的属性，同时，这个对象还能够添加新的属性或者覆盖可访问的另一个对象的属性。<br>继承就是子类可以使用父类的所有功能，并且对这些功能进行扩展。</p><ul><li><p>类式继承<br>就是使用原型的方式，将方法添加在父类的原型上，然后子类的原型是父类的一个实例化对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">// 声明父类</span><br><span class="line">var SuperClass = function() &#123;</span><br><span class="line">  let id = 1</span><br><span class="line">  this.name = [&#x27;java&#x27;]</span><br><span class="line">  this.superValue = function() &#123;</span><br><span class="line">    console.log(&#x27;this is superValue&#x27;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 为父类添加共有方法</span><br><span class="line">SuperClass.prototype.getSuperVlaue = function() &#123;</span><br><span class="line">  return this.superValue()</span><br><span class="line">&#125;</span><br><span class="line">// 声明子类</span><br><span class="line">var SubClass = function() &#123;</span><br><span class="line">  this.subValue = (() =&gt; &#123;</span><br><span class="line">    console.log(&#x27;this is subValue)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">// 继承父类</span><br><span class="line">SubClass.prototype = new SuperClass()</span><br><span class="line">// 为子类添加共有方法</span><br><span class="line">SubClass.prototype.getSubValue = function()&#123;</span><br><span class="line">  return this.subValue()</span><br><span class="line">&#125;</span><br><span class="line">// 生成实例</span><br><span class="line">var sub1 = new SubClass()</span><br><span class="line">var sub2 = new SubClass()</span><br><span class="line">sub1.getSuperValue() // this is superValue</span><br><span class="line">sub1.getSubValue()   // this is subValue</span><br><span class="line"></span><br><span class="line">console.log(sub1.id)   // undefined</span><br><span class="line">console.log(sub1.name) // [&#x27;java&#x27;]</span><br><span class="line"></span><br><span class="line">sub1.name.push(&#x27;php&#x27;)</span><br><span class="line">console.log(sub1.name) //[&#x27;java&#x27;,&#x27;php&#x27;]</span><br><span class="line">console.log(sub1.name) //[&#x27;java&#x27;,&#x27;php&#x27;]</span><br><span class="line">  </span><br></pre></td></tr></table></figure><p><code>使用类继承的方法缺陷，如果父类的构造函数中有引用数据类型，就会在子类中被所有实例共用，因此一个子类的实例如果更改了这个引用数据类型，就会影响到其他子类的实例</code></p></li><li><p>构造函数继承<br>构造函数继承的核心思想就是 直接改变this的指向，使通过this创建的属性和方法在子类中复制一份，因为是单独复制，所以各个实例的子类互不影响。但是会造成内存浪费的问题。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 声明父类</span><br><span class="line">  function SuperClass(id) &#123;</span><br><span class="line">    var name = &#x27;js&#x27;</span><br><span class="line">    this.languages = [&#x27;JavaScript&#x27;,&#x27;Python&#x27;]</span><br><span class="line">    this.id = id</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">// 声明子类</span><br><span class="line">  function SubClass(id) &#123;</span><br><span class="line">    SuperClass.call(this,id)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">// 生成实例</span><br><span class="line">  var sub1 = new SubClass(1)</span><br><span class="line">  var sub2 = new SubClass(2)</span><br><span class="line"></span><br><span class="line">  console.log(sub2.id)   // 2</span><br><span class="line">  console.log(sub2.name) // undefined</span><br><span class="line"></span><br><span class="line">  sub1.languages.push(&#x27;node&#x27;) </span><br><span class="line">  console.log(sub1.languages)  // [&#x27;JavaScript&#x27;,&#x27;Python&#x27;,&#x27;node&#x27;]</span><br><span class="line">  console.log(sub2.languages)  // [&#x27;JavaScript&#x27;,&#x27;Python&#x27;]</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>组合继承<br>组合继承是汲取了类继承和构造函数继承的优点，即避免了内存浪费，又使得每个实例化的子类互不影响</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// 声明父类</span><br><span class="line"></span><br><span class="line">function SuperClass(name) &#123;</span><br><span class="line">  this.languages = [&#x27;js&#x27;,&#x27;python&#x27;]</span><br><span class="line">  this.name = name</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">// 声明父类原型方法</span><br><span class="line">SuperClass.prototype.showlangs = function ()&#123;</span><br><span class="line">  console.log(this.languages)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 声明子类</span><br><span class="line">function SubClass(name)&#123;</span><br><span class="line">  SuperClass.call(this,name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 子类继承父类(链式继承)</span><br><span class="line">SubClass.prototype = new SuperClass()</span><br><span class="line"></span><br><span class="line">// 生成实例</span><br><span class="line">var sub1 = new SubClass(&#x27;node&#x27;)</span><br><span class="line">var subw = new SubClass(&#x27;go&#x27;)</span><br><span class="line"></span><br><span class="line">sub2.showlangs()  // [&#x27;js&#x27;,&#x27;python&#x27;]</span><br><span class="line">sub1.languages.push(sub1.name)</span><br><span class="line">sub1.languages    // [&#x27;js&#x27;,&#x27;python&#x27;,&#x27;node&#x27;]</span><br><span class="line">sub.languages     // [&#x27;js&#x27;,&#x27;python&#x27;,&#x27;go&#x27;]</span><br></pre></td></tr></table></figure><p><code>组合继承的问题，父类的构造函数会被创建两次，一次是call的时候，一次是new的时候</code></p></li><li><p>寄生组合继承</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">// 原型式继承</span><br><span class="line">  function inheritObject(o)&#123;</span><br><span class="line">    // 声明一个过度函数</span><br><span class="line">    function F() &#123;&#125;</span><br><span class="line">    F.prototype = 0</span><br><span class="line">    return new F()</span><br><span class="line">  &#125;</span><br><span class="line">// 寄生式继承</span><br><span class="line">  function inheritPrototype(subClass,superClass)&#123;</span><br><span class="line">    var p = inheritObject(superClass.prototype)</span><br><span class="line">    p.constructor = subClass</span><br><span class="line">    subClass.prototype = p</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">// 定义父类</span><br><span class="line">  function SuperClass(name) &#123;</span><br><span class="line">    this.name = name</span><br><span class="line">    this.languages = [&#x27;js&#x27;]</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">// 定义父类原型方法</span><br><span class="line">  SuperClass.prototype.showLangs = function() &#123;</span><br><span class="line">    console.log(this.languages)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">// 定义子类</span><br><span class="line">  function SubClass(name) &#123;</span><br><span class="line">    SuperClass.call(this.name)</span><br><span class="line">  &#125;</span><br><span class="line">  inheritPrototype(SubClass, SuperClass);</span><br><span class="line">  var sub1 = new SubClass(&#x27;go&#x27;);</span><br></pre></td></tr></table></figure><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>多态：同一操作作用于不同的对象，可以用不同的解释，产生不同的执行结果。本质上就是将做什么和谁去做以及怎么做分开，就是消除不同对象的耦合关系。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> js知识体系 </category>
          
          <category> js 语言的三大特性 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JS 数据</title>
      <link href="/2023/03/01/js%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/%E6%95%B0%E6%8D%AE/"/>
      <url>/2023/03/01/js%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/%E6%95%B0%E6%8D%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="原始数据"><a href="#原始数据" class="headerlink" title="原始数据"></a>原始数据</h1><p>原始数据类型共有六种：Number 、String 、Boolean 、 Undefined 、 Null 、Symbol</p><h2 id="Number-数据类型"><a href="#Number-数据类型" class="headerlink" title="Number 数据类型"></a>Number 数据类型</h2><p>Number 数据类型包含数字和 NaN</p><h3 id="NaN"><a href="#NaN" class="headerlink" title="NaN"></a>NaN</h3><p><code>NaN</code> 非数字，不是一个数但是隶属于数字类型 NaN 和任何值(包括自己)相比较，不大于、不小于、不等于任何值。</p><p>判断是不是数字类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">isNaN(&#x27;1243&#x27;)   // false 虽然&#x27;123&#x27; 是字符串类型，但是由于是纯数字组成可以转换成一个数字</span><br><span class="line"></span><br><span class="line">isNaN(123)    // false 说明是数字</span><br><span class="line"></span><br><span class="line">isNaN(&#x27;123ffff&#x27;) // true</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="数字不同进制"><a href="#数字不同进制" class="headerlink" title="数字不同进制"></a>数字不同进制</h3><p>Number 可以使用四种数字进制：十进制，二进制，八进制和十六进制<br>二进制：以零为开头，后面接一个小写或大写的拉丁文字母 B(0b 或者 0B)<br>八进制：以零为开头，假如 0 后面的数字不在 0 到 7 的范围内，改数字会被转换成十进制数字<br>十六进制：以零为开头，后面接一个小写或大写的拉丁文字母(0x 或者 0X)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 十进制</span><br><span class="line">1234566</span><br><span class="line">12</span><br><span class="line">// 二进制</span><br><span class="line">0b1100    // 12</span><br><span class="line">0b0001    // 1</span><br><span class="line">// 八进制</span><br><span class="line">0755    // 493</span><br><span class="line">0644    // 420</span><br><span class="line"></span><br><span class="line">// 十六进制</span><br><span class="line">0xA     // 10</span><br></pre></td></tr></table></figure><h3 id="转换成数字方法"><a href="#转换成数字方法" class="headerlink" title="转换成数字方法"></a>转换成数字方法</h3><p>Number()、parseInt()、parseFloat()</p><h4 id="Number"><a href="#Number" class="headerlink" title="Number()"></a>Number()</h4><p>可以用于任何数据类型，</p><ul><li><p>转换规则</p><ul><li><p>Boolean 值，true 转换成 1，false 转换成 0</p></li><li><p>null 值，返回 0。</p></li><li><p>undefined，返回 NaN</p></li><li><p>如果是字符串，遵循的规则</p><ul><li><p>只包含数字(包括带正负号的情况)，则转换为十进制，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Number(&#x27;1&#x27;)   // 1</span><br><span class="line">Number(&#x27;+1&#x27;)  // 1</span><br><span class="line">Number(&#x27;011&#x27;) // 11   前导的零被忽略</span><br></pre></td></tr></table></figure></li><li><p>字符是有效的浮点数格式，则将其转换成相对应的浮点数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Number(&#x27;-1.1&#x27;)   // -1.1</span><br><span class="line">Number(&#x27;01.1&#x27;)   // 1.1</span><br><span class="line">Number(&#x27;-01.12&#x27;) // 1.12</span><br></pre></td></tr></table></figure></li><li><p>字符串包含有效的十六进制或者二进制格式，则将其转换为相同大小的十进制整数值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Number(&#x27;0xF&#x27;)   // 15</span><br><span class="line">Number(&#x27;0b1000&#x27;) // 8</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>如果是空字符串，则将其转换为 0 Number(‘’) // 0</p></li><li><p>如果不符合上面的，将其转换成 NaN Number(‘0www’) // NaN</p></li></ul></li><li><p>如果是对象，则调用 valueOf() 方法，然后依照前面的规则转换返回的值，如果转换的值是 NaN ,则调用对象的 toString() 方法，然后再按照前面的规则转换字符串。</p></li></ul></li></ul><h4 id="parseInt"><a href="#parseInt" class="headerlink" title="parseInt()"></a>parseInt()</h4><p>处理整数的时候，更常用 parseInt()函数<br>在转换字符串时是看其是否符合数值模式，会忽略字符串前面的空格，如果第一个字符不是数字或者符号就会返回 NaN</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">parseInt(&#x27;123456blue&#x27;)   // 123456</span><br><span class="line">parseInt(&#x27;&#x27;)             // NaN</span><br><span class="line">parseInt(&#x27;22.34&#x27;)        // 22</span><br><span class="line">parseInt(&#x27;0xa&#x27;)          // 10  符合十六进制，转换成十进制</span><br><span class="line">parseInt(&#x27;070&#x27;)          // 70  字符串类型会忽略前置零。</span><br><span class="line">parseInt(070)            // 56  符合二进制按二进制转换</span><br><span class="line">parseInt(&#x27;70&#x27;)           // 70</span><br><span class="line">parseInt(&#x27;0b1100&#x27;)       // 0</span><br><span class="line">parseInt(0B1100)         // 12</span><br></pre></td></tr></table></figure><p>在包含进制的时候，parseInt(),可以有第二个参数，说明是几进制</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">parseInt(&#x27;10&#x27;,2) //2 按二进制解析转换为十进制</span><br><span class="line">parseInt(&#x27;10&#x27;,8) //8 按八进制解析转换为十进制</span><br><span class="line">parseInt(&#x27;10&#x27;,10) //10 按八进制解析转换为十进制</span><br><span class="line">parseInt(&#x27;10&#x27;,16) //16 按十六进制解析转换为十进制</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="parseFloat"><a href="#parseFloat" class="headerlink" title="parseFloat()"></a>parseFloat()</h4><p>parseFloat() 与 parseInt() 的解析方法基本一样，对浮点数和进制数不同<br>parseFloat 会忽略前置零</p><p>parseFloat() 对于二进制，十六进制的转换都是 0</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">parseFloat(&#x27;123456blue&#x27;)   // 123456</span><br><span class="line">parseFloat(&#x27;&#x27;)             // NaN</span><br><span class="line">parseFloat(&#x27;22.34&#x27;)        // 22.34</span><br><span class="line">parseFloat(&#x27;0xa&#x27;)          // 0  十六进制字符串始终为零</span><br><span class="line">parseFloat(&#x27;070&#x27;)          // 70</span><br><span class="line">parseFloat(&#x27;70&#x27;)           // 70</span><br><span class="line">parseFloat(&#x27;0b1100&#x27;)       // 0</span><br></pre></td></tr></table></figure><h2 id="String-类型"><a href="#String-类型" class="headerlink" title="String 类型"></a>String 类型</h2><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let strObject = new String(&#x27;hello word&#x27;)</span><br><span class="line">let strs = &#x27;hello word&#x27;</span><br><span class="line"></span><br><span class="line">typeof (strObject)   // object</span><br><span class="line">typeof(strs)  // String</span><br></pre></td></tr></table></figure><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p>string 具有长度属性，字符串长度(空格也占位),可以通过 string[index]来访问对应的字符</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let str = &#x27;today is good day&#x27;</span><br><span class="line">str.length // 17</span><br><span class="line">str[2]     // d</span><br></pre></td></tr></table></figure><h3 id="string-方法"><a href="#string-方法" class="headerlink" title="string 方法"></a>string 方法</h3><ul><li><p>charAt(n)<br>传入数值，返回该位置对应字符</p></li><li><p>charCodeAt(n)<br>传入数值，返回该位置对应字符编码</p></li><li><p>slice(n,m) 字符串截取，接受一个或者两个值<br>从 index 为 n 开始(包括 n),到 index 为 m 结束(不包括 m) 返回一个新的字符串，不改变原字符串。</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var str = &#x27;DaShu.yang&#x27;</span><br><span class="line">str.charAt(2) // 3</span><br><span class="line">str.charCodeAt(2) // 83</span><br><span class="line">str.slice(2)   // Shu.yang</span><br><span class="line">str.slice(2,3) // S</span><br></pre></td></tr></table></figure><ul><li><p>indexOf()<br>搜索给定字符串，然后返回字符串的位置(找到返回该字符串的 index 值，反之返回 -1)，可以接受第二个参数，表示从字符串中的哪个位置开始搜索。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let str = &#x27;qwertyuiop&#x27;;</span><br><span class="line">str.indexOf(&#x27;w&#x27;) // 1</span><br><span class="line">str.indexOf(&#x27;m&#x27;)  // -1</span><br></pre></td></tr></table></figure></li><li><p>match()<br>字符串的模式匹配方法，接收一个正则表达式或者 RegExp 对象，返回一个数组，如果没匹配值返回 null<br>该方法可在字符串内检索指定的值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var str = &#x27;asdfghajk&#x27;</span><br><span class="line">str.match(&#x27;a&#x27;)    // [a] 查找是惰性的只会返回一个a,即查找到了第一个就返回查找结果。</span><br><span class="line">str.amtch(/a/g)   // [ a,a ]</span><br></pre></td></tr></table></figure></li><li><p>replace()<br>字符串替换，接收两个参数，第一个参数为字符串或者正则表达式，第二个参数是字符串或者是一个函数，返回一个字符串。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var text = &#x27;cat,bat,sat,fat&#x27;</span><br><span class="line">var reg = /at/g</span><br><span class="line">str.replace(reg,&#x27;&#x27;)</span><br><span class="line">var str = &#x27;abcdefg&#x27;</span><br><span class="line">var reg = /(c)d/g</span><br><span class="line">str.replace(reg,&#x27;$$d&#x27;) // ab$defg</span><br><span class="line">var reg1 = /(c)d(e)/g</span><br><span class="line">str.replace(reg,&#x27;$2$1&#x27;)  // abedcfg</span><br><span class="line">//这里把匹配的第一个内容和第二个内容替换位置($1匹配第一个位置，$2匹配第二个位置，然后再替换整个匹配到的cde)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>split<br>字符串分割，接收两个参数，第一个字符串或者正则表达式，第二个是返回数组的最大长度，返回一个数组。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var text = &#x27;cat,bat,sat,fat&#x27;</span><br><span class="line">text.split(&#x27;,&#x27;)       // [&#x27;cat&#x27;,&#x27;bat&#x27;,&#x27;sat&#x27;,&#x27;fat&#x27;]</span><br><span class="line">text.split(&#x27;,&#x27;,3)     // [&#x27;cat&#x27;,&#x27;bat&#x27;,&#x27;sat&#x27;]</span><br></pre></td></tr></table></figure></li></ul><h2 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h2><h3 id="创建-1"><a href="#创建-1" class="headerlink" title="创建"></a>创建</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var boo = new Boolean()    // false 未对boo进行赋值，默认值为 false</span><br><span class="line">var boo new Boolean(true)  // true</span><br><span class="line">var boo = true/false</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果逻辑对象无初始值或者其值为 0 -0 null ‘’ false undefined NaN,那么对象的值为 false,否则其值为 true</p><ul><li>! 一个叹号是取反，首先将值转化为布尔类型的，然后再取反</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">!3 // false -&gt;先把3转化为 boolean 此时为 true,然后再取反为 false</span><br><span class="line">!0 // true -&gt; 先把 0 转化为 boolean 此时为 false,然后再取反为 true</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>!! 将其他的数据类型转化为 boolean 类型，相当于 Boolean()</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Boolean(&#x27;dddd&#x27;) // true</span><br><span class="line">!!&#x27;dddd&#x27;        // true</span><br></pre></td></tr></table></figure><h3 id="不同数据类型的比较"><a href="#不同数据类型的比较" class="headerlink" title="不同数据类型的比较"></a>不同数据类型的比较</h3><ul><li><p>两个不同类型数据比较时隐式转换规则</p><ul><li><p>数字和字符串、布尔类型、数组进行比较时，字符串(或者布尔、或数组)先转换为数字(Number),再进行比较。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">123 == &#x27;1234a&#x27;  // false</span><br><span class="line">123 == &#x27;123&#x27;    // true</span><br><span class="line">123 == false    // false</span><br><span class="line">123 == true     // false</span><br></pre></td></tr></table></figure></li><li><p>字符串和布尔类型比较，进行比较的两个数据同时经过 Number() 的转换后再进行比较，数组和布尔类型的比较也如此</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x27;qwe&#x27; ==  false   // false   Number(&#x27;qwe&#x27;) -&gt; NaN ; Number(false) -&gt; 0</span><br><span class="line">&#x27;qwe&#x27; == true     // false</span><br><span class="line">&#x27;&#x27;  ==  false     // true    Number(&#x27;&#x27;) -&gt; 0 ; Number(false) -&gt; 0</span><br><span class="line">&#x27;&#x27;  ==  true      // false</span><br><span class="line">[]  ==  false     // true    Number([]) -&gt; 0</span><br><span class="line">[0]  ==  false    // true    Number([0]) -&gt; 0</span><br><span class="line">[00]  ==  false   // true    Number([00]) -&gt; 0</span><br><span class="line">[0,0] ==  false   // false   Number([0,0]) -&gt; NaN</span><br></pre></td></tr></table></figure></li><li><p>undefined 除了和 Null 进行非全等比较返回 true，其它均返回 false。</p></li><li><p>null 除了和 undefined 进行非全等比较返回 true，其它均返回 false。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">undefined == null    // true</span><br><span class="line">undefined == 124    // false</span><br><span class="line">undefined == &#x27;123&#x27;  // false</span><br><span class="line">undefined == false  // false</span><br><span class="line">undefined == true   // false</span><br><span class="line"></span><br><span class="line">null == undefined   // true</span><br><span class="line">null == 124         // false</span><br><span class="line">null == &#x27;124&#x27;       // false</span><br><span class="line">null == false       // false</span><br><span class="line">null == true        // false</span><br></pre></td></tr></table></figure></li><li><p>数组(或对象) 和字符串进行比较时，数组(或对象) 会转换成字符串再进行比较</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[] == &#x27;&#x27;   // true</span><br><span class="line">[0] == &#x27;&#x27;  // false</span><br><span class="line">[0] == &#x27;0&#x27; // true</span><br><span class="line"></span><br><span class="line">var obj = &#123;a:0&#125;</span><br><span class="line">obj == &#x27;&#x27;  // false</span><br><span class="line">obj == &#x27;[object Object]&#x27; // true</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="Undefined-和-Null"><a href="#Undefined-和-Null" class="headerlink" title="Undefined 和 Null"></a>Undefined 和 Null</h2><p>undefined 表示 “缺少值”，就是此处应该有一个值，但是还没有定义。<br>用法:</p><ul><li>变量被声明了，但没有赋值时，就等于 undefined。</li><li>调用函数时，应该提供的参数没有提供，该参数等于 undefined。</li><li>对象没有赋值的属性，该属性的值为 undefined。</li><li>函数没有返回值时，默认返回 undefined。<br>null 表示 “没有对象”，即该处不应该有值<br>用法</li><li>作为函数的参数，表示该函数的参数不是对象。</li><li>作为原型链的终点。</li></ul><h2 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h2><p>本质上是一种唯一标识符，可作为对象的唯一属性名，别就不会改写或覆盖你设置的属性值</p><ul><li>创建</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let id = Symbol(&#x27;id&#x27;)</span><br></pre></td></tr></table></figure><ul><li><p>特点</p><ul><li><p>唯一性，即使是用同一个变量生成的值也不相等。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let id1 = Symbol(&#x27;id&#x27;)</span><br><span class="line">let id2 = Symbol(&#x27;id&#x27;)</span><br><span class="line">id1 == id2                // false</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>隐藏性 for in Object.keys() 不能访问</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let id = Symbol(&#x27;id&#x27;)</span><br><span class="line">let obj = &#123;</span><br><span class="line">  [id]:&#x27;symbol&#x27;</span><br><span class="line">&#125;;</span><br><span class="line">for(let option in obj)&#123;</span><br><span class="line">  console.log(obj[option])   // 空</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Symbol.for()，Symbol.keyFor()</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let name1 = Symbol.for(&#x27;name&#x27;)  // 检测到未创建后返回</span><br><span class="line">let name2 = Symbol.for(&#x27;name&#x27;)  // 检测到已创建后返回</span><br><span class="line">name1 === name2</span><br><span class="line">// 访问值</span><br><span class="line">Symbol.keyFor(&#x27;name1&#x27;)  // name</span><br><span class="line">Symbol.keyFor(&#x27;name2&#x27;)  // name</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h1><ul><li>引用数据类型也就是对象数据类型 object (Object，Array,Function, data )</li><li>JavaScript 的引用数据类型是保存在堆内存中的对象，不可以直接访问堆内存空间中的位置和操作堆内存空间，只能操作对象在栈内存中的对象。</li><li>引用数据类型在栈内存中实际上保存的是对象在堆内存中的引用地址，通过该地址可以快速的查找到保存在堆内存中的对象。</li></ul><h2 id="数组-Array"><a href="#数组-Array" class="headerlink" title="数组(Array)"></a>数组(Array)</h2><p>数组是一组数据的集合，在内存中是一段连续的内存空间。<br>数组定义时可以无需指定数组长度<br>存储数据时无需指定具体的数据类型，可以存储任意类型。</p><h2 id="创建-2"><a href="#创建-2" class="headerlink" title="创建"></a>创建</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let arr1 = []</span><br><span class="line">let arr2 = new Array()</span><br><span class="line">let arr3 = new Array(3) // [empty*3]   创建一个数组，长度为三，值都为空。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h2><h3 id="length-属性"><a href="#length-属性" class="headerlink" title="length 属性"></a>length 属性</h3><ul><li>length 属性表示数组的长度，即其中元素的个数。</li><li>当 length 属性被设置得更大时，数组将增大，新的元素将被添加到数组的尾部，他们的值为空(empty)</li><li>当 length 设置的值小于数组的长度时，数组将被截断，其尾部的元素将丢失。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let arr = [1,2,3,4]</span><br><span class="line">arr.length // 4</span><br><span class="line">arr.length = 6 // [1,2,3,4,expty*2]</span><br><span class="line">arr.length = 2 // [1,2]</span><br></pre></td></tr></table></figure></li></ul><h3 id="数组的方法"><a href="#数组的方法" class="headerlink" title="数组的方法"></a>数组的方法</h3><h4 id="改变数组自身内容的方法"><a href="#改变数组自身内容的方法" class="headerlink" title="改变数组自身内容的方法"></a>改变数组自身内容的方法</h4><p><code>push() 、 pop()、 unshift()、 shift()、 reserve()、 splice()、 sort()、 fill()</code></p><ul><li><p>push() 和 pop()<br>push() 将某些值加入到数组的最后一个位置，不限制添加的数量，添加多项内容使用逗号隔开。<br>pop() 会移除数组的最后一个元素。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let a = [1,2,3,4,5]</span><br><span class="line">a.push(6)       // [1,2,3,4,5,6]</span><br><span class="line">a.push(7,8,9)   // [1,2,3,4,5,6,7,8,9]</span><br><span class="line">a.pop()         // [1,2,3,4,5,6,7,8]</span><br></pre></td></tr></table></figure></li><li><p>unshift(),shift()<br>unshift() 会将指定的元素添加到数组的第一个位置。<br>shift() 会移除数组的第一个元素。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let arr = [1,2,3,4,5]</span><br><span class="line">arr.unshift(6)      // [6,1,2,3,4,5]</span><br><span class="line">arr.unshit(7,8,9)   // [7,8,9,6,1,2,3,4,5]</span><br><span class="line">arr.shift()         // [8,9,6,1,2,3,4,5]</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>reverse()<br>将数组反转</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let a = [1,2,3,4,5,6]</span><br><span class="line">a.reverse()   // [6,5,4,3,2,1]</span><br></pre></td></tr></table></figure></li><li><p>splice()<br>该方法可以移除或新增数列的元素，包含三个参数，一个是要移除或要添加的序列号(必填)，第二个是要移除的长度(选填。若不填则从第一个参数位置开始，后面的元素都会被移除，设为 0 表示不会有元素删除，第三个是要替换的内容)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let arr = [1,2,3,4,5,6,7]</span><br><span class="line">arr.splice(1,1) // [1,3,4,5,6,7]</span><br><span class="line">arr.splice(3,1,100) // [1,3,4,100.6,7]</span><br><span class="line">arr.splice(2,0,200) // [1,3,200,4,100,6,7]</span><br></pre></td></tr></table></figure></li><li><p>sort()<br>该方法可以针对数组的元素进行排序，里头包含一个排序的判断函数，函数内必须包含的两个参数，两个参数分别代表数组里第 n 个和第 n+1 个元素，通过比较第 n 个和第 n+1 个元素的大小来进行排序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let a = [3,2,4,5,1,6,7,8]</span><br><span class="line">a.sort((a,b)=&gt;a-b)  // [1,2,3,4,5,6,7,8]</span><br><span class="line">a.sort((a,b)=&gt;b-a)  // [8,7,6,5,4,3,2,1]</span><br></pre></td></tr></table></figure><p>若不使用判断函数，<code>默认会将元素换成字符串，并采用 unicode 来判断，这也会造成某些数字的排序错误</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let a = [1,2,3,4,5,6,7,8,9,10,11,12]</span><br><span class="line">a.sort()  // [1,10,11,12,2,3,4,5,6,7,8,9]</span><br></pre></td></tr></table></figure></li><li><p>fill()<br>该方法会把数组中所有元素，置换为指定的值，fill() 有三个参数，第一个是准备要置换的内容(必填)，第二个是从什么位置开始置换(选填，不设定就全部置换)，第三个是停止置换的元素的前一个位置(选填，默认等于数组长度)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let a = [1,2,3,4,5,6,7,8,9]</span><br><span class="line">a.fill(&#x27;a&#x27;)  // [&#x27;a&#x27;,&#x27;a&#x27;,&#x27;a&#x27;,&#x27;a&#x27;,&#x27;a&#x27;,&#x27;a&#x27;,&#x27;a&#x27;,&#x27;a&#x27;,&#x27;a&#x27;]</span><br><span class="line">let b = [1,2,3,4,5]</span><br><span class="line">b.fill(&#x27;b&#x27;,2,3) // [1,2,&#x27;b&#x27;,4,5]</span><br></pre></td></tr></table></figure></li></ul><h3 id="获取数组属性或索引值"><a href="#获取数组属性或索引值" class="headerlink" title="获取数组属性或索引值"></a>获取数组属性或索引值</h3><p><code>length() 、indexOf() 、lastIndexOf() 、 find()、 findIndex() 、filter()</code></p><ul><li><p>length()<br>可以取得数组的长度。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let a = [1,2,3,4,5,6]</span><br><span class="line">a.length() // 6</span><br></pre></td></tr></table></figure></li><li><p>indexOf()、lastIndexOf()<br>indexOf()会判断数组中是否包含某个值(从左往右)，如果包含就返回这个值在数组中的索引值，若没有找到返回 -1 。有两个参数一个是要找的的值，另外一个是表示数组数组从哪个位置开始判断。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let a = [1,2,3,4,5]</span><br><span class="line">a.indexOf(3)   // 2</span><br><span class="line">a.indexOf(7)   // -1</span><br><span class="line">a.indexOf(3,6) // -1</span><br></pre></td></tr></table></figure><p>lastIndexOf()会判断数组中是否包含某个值(从右往左)，查找方式 indexOf()一样。</p></li><li><p>find()<br>find() 会将数组中的每一个元素带入指定的函数内做判断，并会返回一个符号判断条件的元素，若没有元素符合则会返回 undefined.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let a = [1,2,3,4,5,6]</span><br><span class="line">a.find((e)=&gt;e&gt;3)  // 4</span><br><span class="line">a.find((e)=&gt;e&lt;1)  // undefined</span><br></pre></td></tr></table></figure></li><li><p>findIndex()<br>findIndex() 会将数组中的每一个元素带入指定的函数内做判断，并返回第一个符合条件元素的位置索引。</p></li><li><p>filter()<br>filter() 会将数组中的每一个元素带入指定的函数内部做判断，如果符合条件则会返回，组成一个新的数组。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let a = [1,2,3,4,5,6,7]</span><br><span class="line">a.filter(e =&gt; e&gt;3)  // [4,5,6,7]</span><br><span class="line">a.filter(e = &gt;e%2 == 0)  // [2,4,6]</span><br></pre></td></tr></table></figure></li></ul><h3 id="针对每一项处理"><a href="#针对每一项处理" class="headerlink" title="针对每一项处理"></a>针对每一项处理</h3><ul><li>forEach()<br>该方法会将数组中每一个元素用指定的函数里进行运算，函数有三个参数，第一个参数表示每个元素的值(必填),第二个参数为该元素的索引值(选填)，第三个参数则表示原本的数组(选填)。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let a = [1,2,3,4,5]</span><br><span class="line">a.forEach((item,index,arr)=&gt;&#123;</span><br><span class="line">  arr[index] = item*10</span><br><span class="line">&#125;)</span><br><span class="line">// [10,20,30,40,50]</span><br></pre></td></tr></table></figure></li></ul><h3 id="产生新的数组或新的值"><a href="#产生新的数组或新的值" class="headerlink" title="产生新的数组或新的值"></a>产生新的数组或新的值</h3><p><code>join() concat() slice() map() reduce() reduceRight() flat() flatMap() Array.from() Array.of() toString()</code></p><ul><li><p>join()<br>可以将数组中所有元素，变成由指定的字符串分割合并在一起组成字符串进行呈现，若没有指定字符默认会用逗号合并。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let a = [1,2,3,4,5]</span><br><span class="line">a.join()  // 1,2,3,4,5</span><br><span class="line">a.join(&#x27;&#x27;) // 12345</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>concat() 可以将两个数组合并在一起，可以使用扩展运算符 … 来代替。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let a = [1,2,3,4,5]</span><br><span class="line">let b = [6,7,8,9]</span><br><span class="line">let c = a.concat(b)   // [1,2,3,4,5,6,7,8,9]</span><br><span class="line">let d = [...a,...b]   // [1,2,3,4,5,6,7,8,9]</span><br></pre></td></tr></table></figure></li><li><p>slice()<br>可以截取出数组某部分的元素为一个新的数组，有两个必填的参数，一个是起始位置，一个是结束位置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let a = [1,2,3,4,5,6]</span><br><span class="line">let b = a.slice(2,4)  // [3,4]</span><br></pre></td></tr></table></figure></li><li><p>map()<br>会处理数组中每一个元素，最后返回一个新的数组，里面是一个函数和一个返回函数里的 this 参数，函数包含三个参数，第一个是每一个元素的值(必填)，第二个是当前元素的索引值，第三个是当前的数组。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let a = [1,2,3,4,5,6]</span><br><span class="line">let b = a.map((e)=&gt;&#123;</span><br><span class="line">  return e+2</span><br><span class="line">&#125;)</span><br><span class="line">// [3,4,5,6,7,8]</span><br></pre></td></tr></table></figure></li><li><p>reduce()<br>可以将数组中每一个元素进行计算，每次计算的结果再与下一个元素计算，直到结束为止，里头包含一个函数(必填)和初始计算的数值(选填)，函数内有四个参数，第一个是计算的值(必填)，第二个是取得的元素(必填)，第三个是该元素的索引值(选填)，第四个是原本的数组(选填)。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let a = [1,2,3,4,5,6,7,8]</span><br><span class="line">let b = a.reduce((total,e)=&gt;&#123;</span><br><span class="line">  total + e</span><br><span class="line">&#125;)</span><br><span class="line">// 36 (1+2+3+4+5+6+7+8)</span><br></pre></td></tr></table></figure></li><li><p>flat()<br>可以将一个多维数组的深度转换成一维(扁平化数组或成为降维)，有一个选填的参数代表要转换的深度数字，默认值为 1 ，如果是很多层可以使用 Infinity 来全部展开成一维数组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let a = [1,[2],[3,4,[8,9]]]</span><br><span class="line">let b = a.flat()   // [1,2,3,4,[8,9]]</span><br><span class="line">let c = a.flat(2)  // [1,2,3,4,8,9]</span><br><span class="line">let d = a.flat(Infinity) // [1,2,3,4,8,9]</span><br></pre></td></tr></table></figure></li><li><p>Array.form()<br>会将类数组或是可迭代的对象转换成数组，有两个参数，第一个参数为类数组对象或可迭代的对象(必填)，第二个参数则是改变转换成数组元素的函数。<br>类数组对象具有 length 属性以及索引化 index 的元素，可迭代对象表示具有可以利用迭代的方式取得它自己本身的元素，如 Map 和 Set</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let a = &#x27;abcd&#x27;</span><br><span class="line">Array.from(a) // [&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;]</span><br><span class="line">let obj = &#123;</span><br><span class="line">  &#x27;0&#x27;:12,</span><br><span class="line">  &#x27;2&#x27;:11,</span><br><span class="line">  &#x27;1&#x27;:10,</span><br><span class="line">  length:3</span><br><span class="line">&#125;</span><br><span class="line">let objb = Array.from(obj) // [12,11.10]</span><br></pre></td></tr></table></figure></li><li><p>Array.of()<br>可以快速将数字、字符串等内容，转换成数组。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let a = Array.of(1,&#x27;q&#x27;,3)</span><br><span class="line">a // [1,&#x27;q&#x27;,3]</span><br></pre></td></tr></table></figure></li><li><p>toString()<br>会把整个数组转换成字符串</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let a = [1,2,3,4]</span><br><span class="line">a.toString() // &#x27;1,2,3,4&#x27;</span><br></pre></td></tr></table></figure></li></ul><h3 id="布尔判断"><a href="#布尔判断" class="headerlink" title="布尔判断"></a>布尔判断</h3><p><code>every() some() includes() Array.isArray()</code></p><ul><li><p>every()<br>会将数组中的每一个元素带入指定的函数内部进行判断，只要有一个元素不符合判断条件,会返回 false，如果全部符合，就会返回 true</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let a = [1,2,3,4,5]</span><br><span class="line">a.every((e) =&gt; e &gt; 3)   // false</span><br><span class="line">a.every((e) =&gt; e &gt; 0)   // true</span><br></pre></td></tr></table></figure></li><li><p>some()<br>会将数组中的每一个函数放入指定的函数内部做判断，只要有任何一个符合判断条件，就会返回 true,如果全部不符合，才会返回 false。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let a = [1,2,3,4]</span><br><span class="line">a.some((e) =&gt; e &gt; 3)  // true</span><br><span class="line">a.some((e) =&gt; e &gt; 4)  // false</span><br></pre></td></tr></table></figure></li><li><p>includes()<br>会判断数组中是否包含某个值，如果包含就返回 true 否则返回 false。有两个参数，第一个参数表示要判断的值，第二个参数是表示从数组的哪个位置开始判断。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let a = [1,2,3,4,5,6]</span><br><span class="line">a.includes(2)     // true</span><br><span class="line">a.includes(2,2)   // false</span><br></pre></td></tr></table></figure></li><li><p>Array.isArray()<br>Array.isArray() 能判断一个元素是否为数组，如果是就返回 true,不然就返回 false。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let a = [1,2,3]</span><br><span class="line">Array.isArray(a)  // true</span><br><span class="line">Array.isArray(124) // false</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p><code>valueOf() keys</code></p><ul><li><p>valueOf()<br>会返回数组的原始值，如果数组原本有修改，返回的原始值也会跟着改变(相当于浅复制)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let a = [1,2,3,4,5]</span><br><span class="line">let b = a.valueOf()   // [1,2,3,4,5]</span><br><span class="line">let c = a.valueOf()</span><br><span class="line">a.shift()</span><br><span class="line">b  // [2,3,4,5]</span><br><span class="line">c  // [2,3,4,5]</span><br></pre></td></tr></table></figure></li><li><p>keys<br>keys 会返回数组中的每一个索引值(key) 成一个新的 Array Iterator 对象，可以用 for of 进行迭代</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let a = [1,2,3,4,5,6]</span><br><span class="line">let b = a.keys()</span><br><span class="line">for(let key of b)&#123;</span><br><span class="line">  console.log(key)    // 1,2,3,4,5,6</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="Oject"><a href="#Oject" class="headerlink" title="Oject"></a>Oject</h2><h3 id="创建-3"><a href="#创建-3" class="headerlink" title="创建"></a>创建</h3><ul><li><p>new 构造函数法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var person = new Object()</span><br><span class="line">person.name = &#x27;张三&#x27;;</span><br><span class="line">person.age = 25</span><br></pre></td></tr></table></figure></li><li><p>对象字面量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123;</span><br><span class="line">  name:&#x27;张三&#x27;,</span><br><span class="line">  age: 25</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="属性和方法"><a href="#属性和方法" class="headerlink" title="属性和方法"></a>属性和方法</h3><ul><li><p>constructor<br>constructor 属性是保存当前对象的构造函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var obj1 = new Object()</span><br><span class="line">obj1.id = &#x27;obj1&#x27;</span><br><span class="line">var obj2 = &#123;</span><br><span class="line">  id:&#x27;obj2&#x27;</span><br><span class="line">&#125;</span><br><span class="line">obj1.constructor // function Object()&#123;&#125;</span><br><span class="line">obj2.constructor // function Object()&#123;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>hasOwnProperty(‘属性名字’) 方法<br>该方法接收一个字符串参数(属性名)，用来判断该属性是否是当前对象实例中，而不是来自对象的原型链中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">  name:&#x27;ddd&#x27;</span><br><span class="line">&#125;</span><br><span class="line">obj.hasOwnProperty(&#x27;name&#x27;)      // true</span><br><span class="line">obj.hasOwnProperty(&#x27;toString&#x27;)  // false</span><br></pre></td></tr></table></figure></li><li><p>toLocaleString() 方法<br>该方法返回对象的字符串表示，和代码的执行环境有关。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;&#125;</span><br><span class="line">obj.toLocalString()    // &#x27;[object object]&#x27;</span><br></pre></td></tr></table></figure></li><li><p>toString() 方法<br>返回对象的字符串表示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;&#125;</span><br><span class="line">obj.toString()  // &#x27;[object object]&#x27;</span><br></pre></td></tr></table></figure></li><li><p>valueOf() 方法<br>该方法返回对象的原始值。可能是字符串、数值或者布尔值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">  name:&#x27;obj&#x27;</span><br><span class="line">&#125;</span><br><span class="line">var arr = [1]</span><br><span class="line">var bool = new Boolean(1)</span><br><span class="line">var date = new Date()</span><br><span class="line"></span><br><span class="line">obj.valueOf()     // Object &#123;name:&#x27;obj&#x27;&#125;</span><br><span class="line">arr.valueOf()     // [1]</span><br><span class="line">bool.valueOf()    // true</span><br><span class="line">data.valueOf()    // 145556666666</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h3 id="属性的类型"><a href="#属性的类型" class="headerlink" title="属性的类型"></a>属性的类型</h3><p>在 JavaScript 中，属性有两种类型，分别是数据属性和访问器属性</p><h4 id="数据属性"><a href="#数据属性" class="headerlink" title="数据属性"></a>数据属性</h4><p>数据属性可以理解为我们平时定义对象赋予的属性，可以进行读和写。但在 ES5 中定义了一些特性，这些特性用来描述属性的各种特征，特性是内部值，不能直接访问。需要通过 Object.defineProperty 方法来修改。</p><ul><li><p>[[Configurable]]<br>该特性表示是否可以通过 delete 操作符来删除属性，默认值为 true。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">  name:&#x27;obj&#x27;,</span><br><span class="line">  age:25</span><br><span class="line">&#125;</span><br><span class="line">obj.name         // obj</span><br><span class="line">delete obj.name</span><br><span class="line">obj.name         // undefined</span><br><span class="line">Object.defineProperty(obj,&#x27;age&#x27;,&#123;</span><br><span class="line">  configurable:false</span><br><span class="line">&#125;)</span><br><span class="line">obj.age          // 25</span><br><span class="line">delete obj.age</span><br><span class="line">obj.age          // 25</span><br></pre></td></tr></table></figure><p>通过 configurable 特性设置成 false 之后，delete 就无法删除 age 属性，如果是在严格模式下，使用 delete 去删除就会报错。</p></li><li><p>[[Enumerable]]<br>表示是否能够通过 for in 语句来枚举出属性。默认是 true</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">  name:&#x27;objName&#x27;</span><br><span class="line">&#125;</span><br><span class="line">for( var key in obj)&#123;</span><br><span class="line">  console.log(key)      // name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Object.defineProperty(obj,&#x27;constructor&#x27;,&#123;</span><br><span class="line">  enumerable:true</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">for ( var key in obj)&#123;</span><br><span class="line">  console.log(key)       // name constructor</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>[[Writable]] 和 [[Value]]<br>Writable：表示属性值是否可以修改，默认为 true，若设为 false，修改属性值的时候没有效果，在严格模式下会报错。<br>Value：表示属性的值，默认为 undefined</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">  name:&#x27;name&#x27;</span><br><span class="line">&#125;</span><br><span class="line">obj.name // name</span><br><span class="line">Object.defineProperty(obj,&#x27;name&#x27;,&#123;</span><br><span class="line">  value:&#x27;newVlaue&#x27;,</span><br><span class="line">  writable:false</span><br><span class="line">&#125;)</span><br><span class="line">obj.name  // newValue</span><br><span class="line">obj.name = &#x27;oldValue&#x27;</span><br><span class="line">obj.name // newValue</span><br></pre></td></tr></table></figure></li></ul><h4 id="访问器属性"><a href="#访问器属性" class="headerlink" title="访问器属性"></a>访问器属性</h4><p>[[get]] 读取属性时调用的函数,[[set]] 给属性设置值的时候调用的函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123;</span><br><span class="line">  age:15</span><br><span class="line">&#125;</span><br><span class="line">Object.defineProperty(person,&#x27;type&#x27;,&#123;</span><br><span class="line">  get:function()&#123;</span><br><span class="line">    if(person.age&gt;17)&#123;</span><br><span class="line">      return &#x27;成人&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">    return &#x27;小孩&#x27;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">person.type // 小孩</span><br><span class="line">person.age = 20</span><br><span class="line">person.type // 成人</span><br></pre></td></tr></table></figure><h2 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h2><p>函数的本身就是对象。函数是第一类对象。<br>第一类对象又称第一类公民。具有的的特性</p><ul><li>能够作为参数被传递。</li><li>能够从一个函数结果中返回。</li><li>能够被修改和赋值给变量。<br><code>在js 里函数也是对象，可以拥有自己的属性和方法，而它和一般js对象的区别是：可以被调用，即可以执行。</code></li></ul><h3 id="创建-4"><a href="#创建-4" class="headerlink" title="创建"></a>创建</h3><p>函数创建方法:<code>函数定义表达式、函数声明语句和 new Function()</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 函数声明</span><br><span class="line">function fun() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">// 函数表达式</span><br><span class="line">var  fun = function() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">// new Function</span><br><span class="line">var  fun1 = new Function()</span><br></pre></td></tr></table></figure><ul><li><p>变量提升<br>JavaScript 中由 var 关键字声明的变量存在变量提升：将变量声明提升到作用域的顶部，但赋值仍保留在原处。函数表达式和函数声明有本质的区别。</p><ul><li>函数声明语句<br>将函数声明和函数的赋值都提升到作用域的顶部，在同一个作用域中可以出现调用在函数之前。</li><li>函数表达式<br>与 var 声明的普通变量相同，只是将变量声明提升到作用域顶部，但赋值仍然留在原处，不能在定义前使用</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">fun()                       // 函数声明</span><br><span class="line">fun1()                      // undefined</span><br><span class="line">function fun() &#123;</span><br><span class="line">  var name = &#x27;函数声明&#x27;</span><br><span class="line">  console.log(name)</span><br><span class="line">&#125;</span><br><span class="line">var fun1 = function() &#123;</span><br><span class="line">  var name = &#x27;函数表达式&#x27;</span><br><span class="line">  console.log(name)</span><br><span class="line">&#125;</span><br><span class="line">fun()                     // 函数声明</span><br><span class="line">fun1()                    // 函数表达式</span><br></pre></td></tr></table></figure></li></ul><h3 id="函数的调用"><a href="#函数的调用" class="headerlink" title="函数的调用"></a>函数的调用</h3><p>在定义函数时，函数体中的代码不会执行，只有在调用函数时，才会执行函数体中的语句。函数的调用方式有四种</p><h4 id="作为普通函数"><a href="#作为普通函数" class="headerlink" title="作为普通函数"></a>作为普通函数</h4><p>使用调用表达式来调用普通函数，每个调用表达式由多个函数表达式组成。每个函数表达式包括函数对象、括号和传入的实参组成。</p><ul><li><p>每次调用会拥有本次调用的上下文 this；在 ES5 非严格模式下，普通函数的 this 值是全局对象；在严格模式下是 undefined</p></li><li><p>以函数形式调用的函数通常不使用 this 关键字</p></li><li><p>如果函数没有显式 return 语句返回一个值，默认返回 undefined</p></li><li><p>传入的实参是由逗号分隔的 0 个或多个函数表达式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function printPrps(o) &#123;</span><br><span class="line">  for(var prop in o) &#123;</span><br><span class="line">    console.log(prop + &quot;: &quot; + o[prop] + &quot;\n&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(this)   // window</span><br><span class="line">&#125;</span><br><span class="line">printPrps(&#123;x:1&#125;)      // x:1</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h4 id="作为对象的方法"><a href="#作为对象的方法" class="headerlink" title="作为对象的方法"></a>作为对象的方法</h4><p>方法是保存在 JavaScript 对象中的函数</p><ul><li>对方法调用的参数和返回值处理与函数调用相同</li><li>方法调用由两部分组成：<code>对象.属性名()</code>，其中属性名是值为函数的属性</li><li>方法调用中：调用上下文指调用方法的对象，使用 this 关键字引用<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var obj =&#123;</span><br><span class="line">  num1: 12,</span><br><span class="line">  num2: 11,</span><br><span class="line">  add: function() &#123;</span><br><span class="line">    this.result = this.num1 + this.num2</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.add()   // 调用 add 方法</span><br><span class="line">obj.result  // 23</span><br></pre></td></tr></table></figure></li></ul><h4 id="作为构造器函数"><a href="#作为构造器函数" class="headerlink" title="作为构造器函数"></a>作为构造器函数</h4><p>函数或者方法调用前有关键字 new，函数或者方法便作为构造函数来调用。构造函数会创建一个新对象，新对象继承构造函数的 prototype 属性。<br>作为构造函数的调用，会将新创建的对象作为其调用上下文(this 指向新创建的对象)，在构造函数中使用 this 引用新创建的对象。</p><h4 id="使用函数的-call-和-apply-方法间接调用"><a href="#使用函数的-call-和-apply-方法间接调用" class="headerlink" title="使用函数的 call() 和 apply() 方法间接调用"></a>使用函数的 call() 和 apply() 方法间接调用</h4><p>函数是对象，每个函数都有 call() 和 apply() 两个方法，作用是改变函数运行时的上下文–改变函数体内部 this 的指向。<br>call()和 apply()作用都是动态改变函数体内 this 指向。只是接受参数形式不太一样。<br>call() 需要将参数按顺序传递进函数，并且知道参数的数量。<br>apply() 将参数放在数组中传进函数。(参数数量不确定时使用)</p><h3 id="函数的实参和形参"><a href="#函数的实参和形参" class="headerlink" title="函数的实参和形参"></a>函数的实参和形参</h3><p>实参和形参是相对的概念，在函数定义时指定的参数叫做形参；在函数调用时传入的参数叫做实参。对于需要省略的实参，可以使用 null 或 undefined 作为占位符。</p><h4 id="参数对象"><a href="#参数对象" class="headerlink" title="参数对象"></a>参数对象</h4><p>函数体内，标识符 argument 指向实参对象的引用，实参对象是一个类数组对象，可以通过下标访问每个传入的参数。</p><ul><li>callee 和 caller 属性。<br>callee 是 ECMAScript 规范中 arguments 对象的属性：代表当前正在执行的函数。<br>caller 是非标准的，只是浏览器基本实现了这个属性：代表调用当前函数的函数。<br>在严格模式中，对这个两个属性读写都会产生错误。</li></ul><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>闭包在 JavaScript 中，指内部函数总是可以访问其所在的外部函数中声明的变量和参数，即是外部函数被返回(调用结束)。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var scope = &#x27;global scope&#x27;</span><br><span class="line">function checkScope() &#123;</span><br><span class="line">  var scope = &#x27;local scope&#x27;</span><br><span class="line">  function f() &#123; return scope&#125;</span><br><span class="line">  return f</span><br><span class="line">&#125;</span><br><span class="line">checkScope()()</span><br></pre></td></tr></table></figure><ul><li>在 Js 中，每个函数在定义时会创建一个与之相关的作用域链，并且在程序执行期间一直存在<br>外部函数有自身的作用域链，内部函数有自身单独的作用域链。</li><li>每次调用函数都会创建一个新对象来保存参数和局部变量，并将其添加到作用域链。<ul><li>当函数返回时，将绑定的新对象从作用域链上删除。如果没有其他变量引用该对象、或该对象没有保存在某个对象的属性中，它会被当做垃圾回收。</li><li>如果没有外部变量引用，调用函数时创建的临时对象，函数 return 后便被垃圾回收。</li></ul></li><li>如果 checkScope 定义有嵌套函数 f,并将 f 作为返回值保存在某个对象的属性中。相当于有一个外部引用指向嵌套函数。</li></ul><p>JavaScript 中的函数，通过作用域和词法作用域两者的特性，将该函数定义时所处的作用域中的相关函数进行补货和保存，从而可以在完全不同的上下文中进行引用。</p><h2 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h2><h3 id="时区"><a href="#时区" class="headerlink" title="时区"></a>时区</h3><pre><code>javaScript 中，我们只关心两个，本地时间和协调世界时(UTC)  - 本地时间 是指自己计算机所在的时区  - UTC 实际上是格林威治时间</code></pre><h3 id="创建-5"><a href="#创建-5" class="headerlink" title="创建"></a>创建</h3><pre><code>`new Date()` 来创建日期，传入的参数通常有四种- 使用日期字符串参数- 使用一系列的参数  可以传入七个参数来创建日期和时间  - Year: 四位数年份  - Month: 一年中的某一个月(0-11)  - Day: 每月的某一天(1-31)，如果省略，则默认为 1  - Hour: 一天中的小时(0-23)，如果省略，则默认为 0  - Minutes: 分钟(0-59)，如果省略，则默认为0  - Seconds: 秒(0-59)，默认为0   - Milliseconds: 毫秒(0-999)，默认为零。- 时间戳参数  时间戳是自 1970年1月1日以来经过的毫秒数- 不带参数  会将日期设置为当前时间</code></pre>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 使用日期字符串参数</span><br><span class="line">  new Date(&#x27;2021-10-21&#x27;)</span><br><span class="line">  </span><br><span class="line">// 使用一系列参数来创建</span><br><span class="line">  </span><br><span class="line">  new Date(2020,1,23,5,30,39)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="日期提供的方法"><a href="#日期提供的方法" class="headerlink" title="日期提供的方法"></a>日期提供的方法</h3><ul><li><p>编写自定义日期格式化<br>Date 中获取 年月日时分秒的方法</p><ul><li>getFullYear: 获取当地时间四位数的年份</li><li>getMonth: 获取月份，月份从零开始</li><li>getDate: 获取月中的某一天(1-31)</li><li>getDay: 获取星期几(0-6)，星期日(0)开始，到星期六(6)结束。</li><li>getHours: 获取小时数(0-23)</li><li>getMinutes: 获取分钟数(0-59)</li><li>getSeconds: 获取秒数(0-59)</li><li>getMilliseconds: 获取毫秒数(0-999)</li></ul><p>Date 设置另一个日期特定的日期/时间值</p><ul><li>setFullYear: 设置年份</li><li>setMonth: 设置月份</li><li>setDate: 设置每月中的某一天</li><li>setHours: 设置时</li><li>setMinutes: 设置分</li><li>setSeconds: 设置秒</li><li>setMilliseconds: 设置毫秒<h4 id="日期添加-减去增量"><a href="#日期添加-减去增量" class="headerlink" title="日期添加/减去增量"></a>日期添加/减去增量</h4></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">当前日期 2019年3月28日，获取三天后的日期</span><br><span class="line"></span><br><span class="line">let today = new Date(2019,2,28)</span><br><span class="line">let finalDate = new Date(today)</span><br><span class="line">finalDate.setDate(today.getDate()+3)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h1 id="引用类型与原始类型的区别"><a href="#引用类型与原始类型的区别" class="headerlink" title="引用类型与原始类型的区别"></a>引用类型与原始类型的区别</h1><h3 id="声明变量时不同的内存分配"><a href="#声明变量时不同的内存分配" class="headerlink" title="声明变量时不同的内存分配"></a>声明变量时不同的内存分配</h3><ul><li>原始值：存储在栈内存(stack) 中的简单数据段，即他们的值直接存储在变量访问的位置。</li><li>引用值：存储在堆内存中，栈内存中存储的是该对象的指针，指向存储对象的内存地址<br>为什么引用类型的值不能放在栈中，引用类型的值大小会发生改变，放在栈内存中会降低变量查询的速度。</li></ul><h3 id="访问机制"><a href="#访问机制" class="headerlink" title="访问机制"></a>访问机制</h3><ul><li>原始类型，值是可以直接访问</li><li>引用类型，访问一个对象时，首先得到的是这个对象在内存中的地址，然后再按照这个地址去获得这个对象中的值，即<code>按应用访问</code></li></ul><h3 id="复制变量"><a href="#复制变量" class="headerlink" title="复制变量"></a>复制变量</h3><ul><li>原始类型：将保存原始值的变量复制给另一个变量时，会将原始值的副本赋值给新变量，此后这两个变量是完全独立的。</li><li>引用类型：是将内存地址赋值给新变量，即这两个变量都指向同一个堆内存中的同一个对象，任何一个改变都会反映在另一个身上。</li></ul><h3 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h3><p>ECMAScript 中所有的函数的参数都是<code>按值传递</code>。<br>但是涉及到原始和引用类型的值时是有差异的，因为内存分配时的差异。</p><ul><li>原始值：把变量的值传递给参数，之后参数和这个变量互不影响。</li><li>引用值：传递的值是内存地址，所以在函数内部对参数修改会体现在外部，因为他们指向的是同一个对象。</li></ul>]]></content>
      
      
      <categories>
          
          <category> js知识体系 </category>
          
          <category> 数据 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CommonJS AMD CMD ES6</title>
      <link href="/2023/03/01/js%E6%A8%A1%E5%9D%97%E5%8C%96%E5%8F%91%E5%B1%95/%E5%90%84%E7%A7%8D%E6%A8%A1%E5%9D%97%E5%8C%96%E6%96%B9%E6%A1%88%E8%A7%84%E8%8C%83/"/>
      <url>/2023/03/01/js%E6%A8%A1%E5%9D%97%E5%8C%96%E5%8F%91%E5%B1%95/%E5%90%84%E7%A7%8D%E6%A8%A1%E5%9D%97%E5%8C%96%E6%96%B9%E6%A1%88%E8%A7%84%E8%8C%83/</url>
      
        <content type="html"><![CDATA[<h2 id="CommonJS-规范"><a href="#CommonJS-规范" class="headerlink" title="CommonJS 规范"></a>CommonJS 规范</h2><h3 id="模块的定义"><a href="#模块的定义" class="headerlink" title="模块的定义"></a>模块的定义</h3><pre><code>1、 `每个文件就是一个模块`，有自己的作用域。在一个文件里面定义的变量、函数、类、都是私有的，对其他文件不可见。2、在模块中使用global定义全局变量，不需要导出，在别的文件中可以访问到。3、在每个模块内部，module 变量代表当前模块。这个变量是一个对象，它的exports 属性(module.exports) 是`对外的接口`。4、通过require 加载模块，读取并执行一个 js 文件，然后 `返回该模块的exports对象`5、所有代码都运行在模块作用域，不会污染全局作用域。6、模块可以加载多次，但是`只会在第一次加载时运行一次，然后运行结果就被缓存了`，以后再加载马，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。7、模块的加载顺序，按照其`在代码中出现的顺序`</code></pre><h3 id="module-对象"><a href="#module-对象" class="headerlink" title="module 对象"></a>module 对象</h3><pre><code>node 内部提供了一个module 构建函数。所有的模块其实都是Module 的实例。每一个模块内部，都有一个Module 对象，代表当前模块。具有的属性：  - module.id 模块的识别符，通常是带有绝对路径的模块文件名。  - module.filename 模块的文件名，带有绝对路径；  - module.loaded 返回一个boolean 值，表示模块是否已经完成加载  - module.parent 返回一个对象，表示调用该模块的模块  - module.children 返回一个数组，表示该模块内用到的其他模块  - module.exports 表示模块对外输出的值。</code></pre><h4 id="module-exports-属性和export-变量"><a href="#module-exports-属性和export-变量" class="headerlink" title="module.exports 属性和export 变量"></a>module.exports 属性和export 变量</h4><pre><code>module.exports 属性表示当前模块对外输出的接口，其他文件加载该模块就是读取module.export 变量。为了方便，node为每一个模块体提供了一个export变量，指向 module.export。者等同在每一个文件头部，有一条这样的命令。 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var exports = module.exports</span><br></pre></td></tr></table></figure>所以我们在对外输出模块接口时，可以向 exports对象中添加方法或者属性<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">module.export.name  = &#x27;module&#x27;</span><br><span class="line">exports.name = &#x27;测试&#x27;</span><br><span class="line">exports.age = 18</span><br><span class="line">//  下面的操作是错误的</span><br><span class="line">exports = &#x27;xx&#x27;</span><br><span class="line">exports = function () &#123;&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>`不可以直接将exports变量指向一个值`，这样等同于切断了 expors 和 module.exports 的联系。这意味着，如果一个模块的对外接口，是一个单一的值，这种情况就不能直接使用exports 输出，只能使用module.exports 输出。</code></pre><h2 id="require"><a href="#require" class="headerlink" title="require"></a>require</h2><pre><code>`require命令` 用于`加载模块文件` 它的基本功能是，读取并执行一个Javascript文件，然后返回该模块的exports 对象。</code></pre><p>  CommonJS 模块的加载机制是，输入的是被输出的值的拷贝。也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。</p><h3 id="require-的内部处理流程"><a href="#require-的内部处理流程" class="headerlink" title="require 的内部处理流程"></a>require 的内部处理流程</h3><pre><code>- 先检查 Module._cache,看里面有没有对应模块的缓存；- 如果有缓存没有的化就创建一个新的moudule 实例，并把它添加到缓存中，缓存的是它 exports导出的值；- 如果缓存中有的话，使用module.load() 这个方法，去加载这个模块，读取文件内容后，使用module.compile()执行文件代码。- 如果解析的过程中，出现异常，就从缓存中删除这个模块；- 如果没有出现异常，最后返回这个模块的module.exports;</code></pre><h3 id="加载规则"><a href="#加载规则" class="headerlink" title="加载规则"></a>加载规则</h3><pre><code>根据参数的不同格式，require 命令去不同路径寻找模块文件。* 如果参数字符串以 &quot;/&quot; 开头 ，表示加载的是一个位于`绝对路径` 的模块文件。* 如果参数字符串以 &quot;./&quot; 开头，表示加载的是位于`相对路径`(跟当前执行脚本的位置相比)的模块文件。* 如果参数字符串不以`&quot;/&quot;` 或者`&quot;./&quot;` 开头，则表示加载的是一个默认提供的`核心模块`(位于Node的系统安装目录中)，或者一个位于各级 node_module目录的`已安装模块`(全局安装或者局部安装)。* 如果参数字符串不以 &quot;/&quot; 或者 &quot;./&quot; 开头，而是一个路径，则会先找到该路径目录，然后再以它为参数找到后续路径。* 如果指定的模块文件没有被发现，Node 会尝试为文件添加.js、.json、.node后，再去搜索。.js 文件会以文本格式的javascript脚本文件解析，.json文件会以JSON格式的文本文件解析，.node文件会以编译后的二进制文件解析。* 如果想得到require 命令加载的确切文件名，使用require.resolve() 方法。</code></pre><h3 id="模块的缓存"><a href="#模块的缓存" class="headerlink" title="模块的缓存"></a>模块的缓存</h3>]]></content>
      
      
      <categories>
          
          <category> JS 模块化 </category>
          
          <category> CommonJS&amp;AMD&amp;CMD&amp;ES6 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JS代码执行过程分析</title>
      <link href="/2023/03/01/js%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/js%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/"/>
      <url>/2023/03/01/js%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/js%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="解释型语言和编译型语言"><a href="#解释型语言和编译型语言" class="headerlink" title="解释型语言和编译型语言"></a>解释型语言和编译型语言</h2><ul><li>编译型语言，编译步骤分为：词法分析、语法分析、语义检查、代码优化和字节生成。</li><li>解释型语言：通过词法分析和语法分析得到抽象语法树后，就开始解释执行，</li></ul><h2 id="js-的解释执行"><a href="#js-的解释执行" class="headerlink" title="js 的解释执行"></a>js 的解释执行</h2><p>js  作为一门解释性语言，其运行过程分为 <code>预解析</code> 和 <code>自上而下逐行解释执行</code> 两个过程。包括的步骤<br>  词法分析、语法分析、预编译、执行</p><h3 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h3><p>  词法分析器的作用，是将一行行的源码拆解成一个个词义单位(token)，词义单位指的是语法上不可能再分的、最小的单个字符或字符组合。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">var a = 2 </span><br><span class="line">function addA()&#123;</span><br><span class="line">  return a </span><br><span class="line">&#125;</span><br><span class="line">// 词法分析后的结果</span><br><span class="line">[</span><br><span class="line">  &#123;&quot;type&quot;:&quot;Keyword&quot;,&quot;value&quot;:&quot;var&quot;&#125;,</span><br><span class="line">  &#123;&quot;type&quot;:&quot;Identifier&quot;,&quot;value&quot;:&quot;a&quot;&#125;,</span><br><span class="line">  &#123;&quot;type&quot;:&quot;Punctuator&quot;,&quot;value&quot;:&quot;=&quot;&#125;,</span><br><span class="line">  &#123;&quot;type&quot;:&quot;Numeric&quot;,&quot;value&quot;:&quot;2&quot;&#125;,</span><br><span class="line">  &#123;&quot;type&quot;:&quot;Punctuator&quot;,&quot;value&quot;:&quot;;&quot;&#125;,</span><br><span class="line">  &#123;&quot;type&quot;:&quot;Keyword&quot;,&quot;value&quot;:&quot;function&quot;&#125;,</span><br><span class="line">  &#123;&quot;type&quot;:&quot;Identifier&quot;,&quot;value&quot;:&quot;addA&quot;&#125;,</span><br><span class="line">  &#123;&quot;type&quot;:&quot;Punctuator&quot;,&quot;value&quot;:&quot;(&quot;&#125;,</span><br><span class="line">  &#123;&quot;type&quot;:&quot;Punctuator&quot;,&quot;value&quot;:&quot;)&quot;&#125;,</span><br><span class="line">  &#123;&quot;type&quot;:&quot;Punctuator&quot;,&quot;value&quot;:&quot;&#123;&quot;&#125;,</span><br><span class="line">  &#123;&quot;type&quot;:&quot;Keyword&quot;,&quot;value&quot;:&quot;return&quot;&#125;,</span><br><span class="line">  &#123;&quot;type&quot;:&quot;Identifier&quot;,&quot;value&quot;:&quot;a&quot;&#125;,</span><br><span class="line">  &#123;&quot;type&quot;:&quot;Punctuator&quot;,&quot;value&quot;:&quot;;&quot;&#125;,</span><br><span class="line">  &#123;&quot;type&quot;:&quot;Punctuator&quot;,&quot;value&quot;:&quot;&#125;&quot;&#125;</span><br><span class="line">] </span><br></pre></td></tr></table></figure><h3 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h3><p>  js引擎要读的是抽象语法树<br>  语法分析将上一步生成的数组，根据语法规则，转为抽象语法树(AST)。如果源码符合语法规则，这一步就会顺利完成，生成一个抽象语法树；如果源码存在语法错误，这一步就会终止，抛出一个”语法错误”，并结束整个代码块的解析。</p><p>这个阶段主要做了两件事情</p><ul><li><p>确定作用域，根据静态作用域的特点，这个时候每个变量的作用域已经很明确了，不会再改变</p></li><li><p>记录每个作用域的所有变量和内嵌函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">  var a = 2</span><br><span class="line">  function addA() &#123;</span><br><span class="line">    return a </span><br><span class="line">  &#125;</span><br><span class="line">  // 生成的抽象语法树</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;type&quot;: &quot;Program&quot;,</span><br><span class="line">  &quot;body&quot;: [</span><br><span class="line">      &#123;</span><br><span class="line">          &quot;type&quot;: &quot;VariableDeclaration&quot;,</span><br><span class="line">          &quot;declarations&quot;: [</span><br><span class="line">              &#123;</span><br><span class="line">                  &quot;type&quot;: &quot;VariableDeclarator&quot;,</span><br><span class="line">                  &quot;id&quot;: &#123;</span><br><span class="line">                      &quot;type&quot;: &quot;Identifier&quot;,</span><br><span class="line">                      &quot;name&quot;: &quot;a&quot;</span><br><span class="line">                  &#125;,</span><br><span class="line">                  &quot;init&quot;: &#123;</span><br><span class="line">                      &quot;type&quot;: &quot;Literal&quot;,</span><br><span class="line">                      &quot;value&quot;: 2,</span><br><span class="line">                      &quot;raw&quot;: &quot;2&quot;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          ],</span><br><span class="line">          &quot;kind&quot;: &quot;var&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">          &quot;type&quot;: &quot;FunctionDeclaration&quot;,</span><br><span class="line">          &quot;id&quot;: &#123;</span><br><span class="line">              &quot;type&quot;: &quot;Identifier&quot;,</span><br><span class="line">              &quot;name&quot;: &quot;addA&quot;</span><br><span class="line">          &#125;,</span><br><span class="line">          &quot;params&quot;: [],</span><br><span class="line">          &quot;body&quot;: &#123;</span><br><span class="line">              &quot;type&quot;: &quot;BlockStatement&quot;,</span><br><span class="line">              &quot;body&quot;: [</span><br><span class="line">                  &#123;</span><br><span class="line">                      &quot;type&quot;: &quot;ReturnStatement&quot;,</span><br><span class="line">                      &quot;argument&quot;: &#123;</span><br><span class="line">                          &quot;type&quot;: &quot;Identifier&quot;,</span><br><span class="line">                          &quot;name&quot;: &quot;a&quot;</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">              ]</span><br><span class="line">          &#125;,</span><br><span class="line">          &quot;generator&quot;: false,</span><br><span class="line">          &quot;expression&quot;: false,</span><br><span class="line">          &quot;async&quot;: false</span><br><span class="line">      &#125;</span><br><span class="line">  ],</span><br><span class="line">  &quot;sourceType&quot;: &quot;scr</span><br></pre></td></tr></table></figure><h3 id="预编译"><a href="#预编译" class="headerlink" title="预编译"></a>预编译</h3><p>预编译是指 JS 引擎再执行一个函数时，会创建对应的 <code>执行上下文</code> ，它根据抽象语法树做的一些’准备工作’。这个过程包括</p><ul><li>创建变量对象<ul><li>创建 arguments 对象，同名的实参，形参和变量之间是 引用 关系。</li><li>从语法分析树中复制作用域内的内嵌函数作为属性，key 为函数name,属性值为函数的内存地址。</li><li>从语法分析树中复制作用域内所有变量 作为属性，key 为变量名称，此时变量值全部为 undefined ，若变量和函数存在同名，则跳过</li></ul></li><li>创建作用域链，根据语法分析树中函数对应的作用域，结合当前环境的变量对象和上层环境的一系列变量对象组成</li><li>确定this 指向。<br>全局上下文的时候，变量对象就是全局对象 window,this也指向 window </li></ul><h3 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h3><p>开始执行后，执行上下文中的变量对象转换为活动对象，可以执行一些列的操作。</p><ul><li>变量赋值，查找规则是先找自身作用域，找不到就在作用域上查找</li><li>函数作用域</li><li>执行其他代码</li><li>执行结束，内存回收<br><code>代码执行结束后，函数内变量的生存周期取决于函数实例是否存在引用，如果没有就销毁活动对象</code></li></ul></li></ul><h3 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h3><p>  执行上下文就是当前 JavaScript 代码被解析和执行时所在环境的抽象概念，JavaScript 中运行任何的代码都是在执行上下文中运行。<br>  每当控制器转到可执行代码的时候，就会进入一个执行上下文。执行上下文可以理解为当前代码的执行环境，它会形成一个作用域。JavaScript 中的运行环境大概包括三种情况<br>    - 全局执行上下文: JavaScript 代码运行起来会首先进入该环境，是最基础的执行上下文。不在任何函数中的代码都位于全局执行上下文中。<br>      做了两件事<br>        - 创建全局对象，在浏览器中这个全局对象就是 window 对象<br>        - 将this指针指向这个全局对象。一个程序中只能存在一个全局执行上下文。<br>    - 函数执行上下文: 每次调用函数时，都会为该函数创建一个新的执行上下文。每个函数都拥有自己的执行上下文，<br>    - eval</p><h4 id="执行上下文的生命周期"><a href="#执行上下文的生命周期" class="headerlink" title="执行上下文的生命周期"></a>执行上下文的生命周期</h4><p>  执行上下文的生命周期包括三个阶段：创建阶段 –&gt; 执行阶段 –&gt; 回收阶段</p><ul><li><p>创建阶段</p><ul><li>创建变量对象：首先初始化函数的参数 arguments，提升函数声明和变量声明。</li><li>创建作用域链：在执行期上下文的创建阶段，作用域链是在变量对象之后创建的。作用域链本身包含变量对象。作用域链拥有解析变量。当被要求解析变量时，JavaScript 始终从代码嵌套的最内层开始，如果最内层没有找到变量，就会跳到上一层父作用域中查找，直到找到该变量。</li><li>确定this指向</li><li>变量对象(Variable Object)<br>在执行上下文创建阶段会生成变量对象，生成变量对象主要有三个过程</li></ul></li><li><p>检索当前上下文中的参数。该过程生成Arguments 对象，并建立以形参变量名为属性名，形参变量值为属性值的属性</p></li><li><p>检索当前上下文中的函数声明，该过程建立以函数名为属性名，函数所在内存地址引用为属性的值的属性</p></li><li><p>检索当前上下文中的变量声明。该过程建立以变量名为属性名，undefined 为属性值的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">VO = &#123;</span><br><span class="line">  Arguments:&#123;&#125;,</span><br><span class="line">  ParamVariable: 具体值  // 形参变量</span><br><span class="line">  Function: &lt;Function reference&gt;,</span><br><span class="line">  Variable: undefined</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当执行上下文进入执行阶段后，变量对象会变为<code>活动对象(Active Object)</code>此时原先声明的变量会被赋值。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> js知识体系 </category>
          
          <category> js 代码执行过程分析 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>import 和 export</title>
      <link href="/2023/03/01/import%E5%92%8Cexport/"/>
      <url>/2023/03/01/import%E5%92%8Cexport/</url>
      
        <content type="html"><![CDATA[<h2 id="模块导出-export"><a href="#模块导出-export" class="headerlink" title="模块导出 export"></a>模块导出 export</h2><ul><li>一个文件定义一个模块，通过 export 语句导出该模块输出的变量</li><li>export语句有两种语法格式: 命名导出、默认导出</li></ul><h3 id="命名导出"><a href="#命名导出" class="headerlink" title="命名导出"></a>命名导出</h3><p>  命名导出就是明确导出的变量名和值</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">  export var PI = 3.14</span><br><span class="line">  export var add = function (x,y)&#123;</span><br><span class="line">    return x + y</span><br><span class="line">  &#125;</span><br><span class="line">  // 导入</span><br><span class="line">  import * as Math from &#x27;路径&#x27;</span><br><span class="line">  Math.PI</span><br><span class="line">  Math.add(1,3)</span><br><span class="line"></span><br><span class="line">// 重命名导出</span><br><span class="line"> var PI = 3.14</span><br><span class="line"> Var add = function(x,y)&#123;</span><br><span class="line">   return x + y</span><br><span class="line">  </span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">  export &#123; PI, add as Add&#125; //把导出的变量add 重命名为Add</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="默认导出"><a href="#默认导出" class="headerlink" title="默认导出"></a>默认导出</h3><p>  通过关键字 default 修饰 export 可以指定一个模块的默认输出变量值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">export default 3.14</span><br><span class="line">var PI = 3.14</span><br><span class="line">export default PI</span><br><span class="line">export default function add2(x,y)&#123;</span><br><span class="line">  return x + y</span><br><span class="line">&#125;</span><br><span class="line">// 一个模块最多只能有一个默认导出</span><br><span class="line">// 默认输出可以视为名字是 default d的模块输出变量</span><br><span class="line">// 默认导出后面可以是表达式</span><br></pre></td></tr></table></figure><h2 id="模块导入"><a href="#模块导入" class="headerlink" title="模块导入"></a>模块导入</h2><p>  通过 import 语句导入外部模块。对应 export 语句的两种导出方式，import也分别存在两种不同的模块导入语法格式。</p><h3 id="导入模块的命名输出"><a href="#导入模块的命名输出" class="headerlink" title="导入模块的命名输出"></a>导入模块的命名输出</h3>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 导出</span><br><span class="line">  export var PI = 3.14</span><br><span class="line">  export var add = function (x,y)&#123;</span><br><span class="line">    return x + y</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">// 导入</span><br><span class="line">  import &#123; PI, add &#125; from &#x27; 路径&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>  <code>导入名称必须要和导出模块的输出变量 一 一 对应，否则就是 undefined</code></p><ul><li><p>重命名导入的变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#123; PI as pi, add as Add&#125; from &#x27;路径&#x27;</span><br></pre></td></tr></table></figure><ul><li>通配符 *<br>如果导入一个模块所有命名输出，可采用</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import * as tool from &#x27;路径&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>表示导入模块所有命名输出变量，并通过 重新命名的变量(tool)访问所有命名导出的变量</code>   <code>重新命名的变量(tool) 是个特殊的对象，叫  模块对象</code></p></li></ul><h3 id="导入模块的默认输出"><a href="#导入模块的默认输出" class="headerlink" title="导入模块的默认输出"></a>导入模块的默认输出</h3>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 导出</span><br><span class="line">var PI = 3.14;</span><br><span class="line">var add = function (x, y) &#123; </span><br><span class="line"> return x + y;</span><br><span class="line">&#125;</span><br><span class="line">export &#123; PI, add as Add &#125;; // 简写格式，统一列出需要输出的变量</span><br><span class="line">export default function say()&#123;</span><br><span class="line">  console.log(&#x27; I am default export&#x27;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 导入</span><br><span class="line">import say from &#x27;路径&#x27;</span><br><span class="line"></span><br><span class="line">say()</span><br></pre></td></tr></table></figure><ul><li><p>导入模块的默认输出可以用 as 重命名，可以利用重命名方式避免导入模块的变量名和本模块变量命名冲突</p></li><li><p>导入模块默认输出发名字可以任意命名。</p></li><li><p>如果同时导入模块的命名输出和默认输出，可采用格式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import say, * as tool from &#x27;路径&#x27;</span><br><span class="line">import say, &#123; PI, add &#125; from &#x27;路径&#x27;</span><br></pre></td></tr></table></figure><p><code>默认导入一定放在命名导入前面</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import * as tool, say from &#x27;路径&#x27; // 错误</span><br><span class="line">import &#123; PI, add &#125;, say from &#x27;路径&#x27; //错误</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="只导入"><a href="#只导入" class="headerlink" title="只导入"></a>只导入</h3><p>如果只导入一个模块，但不引用模块输出变量，可以简写</p><p><code>import &#39;路径&#39;</code> 此时只会触发模块的执行</p></li></ul><h2 id="修改导入-导出的变量值"><a href="#修改导入-导出的变量值" class="headerlink" title="修改导入/导出的变量值"></a>修改导入/导出的变量值</h2><ul><li><p>修改导入的变量值</p><p><code>import 导入的变量和变量属性都是只读的</code>，不能也不应该修改导入的变量值</p></li></ul><ul><li><p>修改导出的变量值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// 导出</span><br><span class="line"> var Count = 0;</span><br><span class="line"> var increase =  function() &#123;</span><br><span class="line">     Count++;</span><br><span class="line"> &#125;</span><br><span class="line"> var Person = &#123;</span><br><span class="line">     name: &#x27;Bob&#x27;</span><br><span class="line"> &#125;</span><br><span class="line"> var changeName = function() &#123;</span><br><span class="line">     Person.name = &#x27;John&#x27;;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> export &#123; Count, Person, increase, changeName &#125;; </span><br><span class="line"></span><br><span class="line"> // 导入</span><br><span class="line"> import * as Math from &#x27;./math.js&#x27;; </span><br><span class="line"></span><br><span class="line"> console.log(`Person:$&#123;JSON.stringify(Math.Person)&#125;, Count:$&#123;Math.Count&#125;`);// 修改前</span><br><span class="line"> Math.increase();</span><br><span class="line"> Math.changeName();</span><br><span class="line"> console.log(`Person:$&#123;JSON.stringify(Math.Person)&#125;, Count:$&#123;Math.Count&#125;`);//  修改后</span><br><span class="line"> //输出</span><br><span class="line"> Person:&#123;&quot;name&quot;:&quot;Bob&quot;&#125;, Count:0</span><br><span class="line"> Person:&#123;&quot;name&quot;:&quot;John&quot;&#125;, Count:1</span><br></pre></td></tr></table></figure><p>只要修改了到处知就会影响取值。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> import 和 export </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>js 数据类型</title>
      <link href="/2023/03/01/jsType/"/>
      <url>/2023/03/01/jsType/</url>
      
        <content type="html"><![CDATA[<p>ECMAScript 变量有两种不同的数据类型: 基本类型，引用类型。</p><h2 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h2><p>数据类型有 <code>undefined 、Boolean 、Number 、String 、null</code></p><h3 id="基本数据类型的特点"><a href="#基本数据类型的特点" class="headerlink" title="基本数据类型的特点"></a>基本数据类型的特点</h3><p>基本数据类型是按值传递，存储在栈区的数据，无法添加属性，删除属性，直接赋值给另一个变量，两个变量互不影响，修改其中任意一个变量的值，另外一个的值不发生变化。</p><ul><li>、值是不可变的</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let a = &#x27;abc&#x27;</span><br><span class="line">let b = a</span><br><span class="line">b = &#x27;456&#x27;</span><br><span class="line">console.log(a) // abc</span><br><span class="line">console.log(b) // 456</span><br></pre></td></tr></table></figure><ul><li>、基本类型的比较是值的比较</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let num = 1</span><br><span class="line">let boolean = true</span><br><span class="line"></span><br><span class="line">num == boolean  // true</span><br><span class="line"> // ==  比较会进行隐式类型转换   true 转换成 1  false 转换成 0</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>、 基本类型的变量是存放在栈内存</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let name = &#x27;张三&#x27;</span><br><span class="line">let age = &#x27;12&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><p>引用类型有：<code>Object 、Array</code></p><h3 id="引用数据类型的特点"><a href="#引用数据类型的特点" class="headerlink" title="引用数据类型的特点"></a>引用数据类型的特点</h3><p>引用数据类型的赋值，是按引用传递，复制的是指针。是浅拷贝。</p><ul><li>引用类型的值是可变的</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123;&#125;</span><br><span class="line">obj.name = &#x27;张三&#x27;</span><br><span class="line">obj.age = &#x27;12&#x27;</span><br><span class="line">function fun(o)&#123;</span><br><span class="line">  let newObj = o</span><br><span class="line">  newObj.name=&#x27;李四&#x27;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">console.log(obj.name)   // 张三</span><br><span class="line">fun(obj)</span><br><span class="line">console.log(obj.name)  // 李四</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>引用类型的值是同时保存在栈内存和堆内存中的对象</p><p>javaScript 不允许直接访问内存中的位置，也就是不能直接操作对象的内存空间，实际上是操作对象的引用。引用类型的存储需要堆内存，和栈内存，栈内存保存变量标识符和指向堆内存中该对象的指针。</p></li><li><p>引用类型的比较是引用的比较</p></li></ul><p>两个对象的比较是比较两个对象的堆内存中的地址是否相同。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let person1 = &#123;&#125;</span><br><span class="line">let person2 = &#123;&#125;</span><br><span class="line">console.log(person1 == person2 )  // false</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JS模块化发展</title>
      <link href="/2023/03/01/js%E6%A8%A1%E5%9D%97%E5%8C%96%E5%8F%91%E5%B1%95/%E5%89%8D%E8%A8%80/"/>
      <url>/2023/03/01/js%E6%A8%A1%E5%9D%97%E5%8C%96%E5%8F%91%E5%B1%95/%E5%89%8D%E8%A8%80/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是模块化"><a href="#什么是模块化" class="headerlink" title="什么是模块化"></a>什么是模块化</h1><p>  将一个复杂的程序按照一定的规则封装成几个文件，并进行组合在一起。每个模块的内部数据是私有的，只是向外部暴露一些接口(方法)与外部其它模块通信。</p><h2 id="为什么要有模块化"><a href="#为什么要有模块化" class="headerlink" title="为什么要有模块化"></a>为什么要有模块化</h2><p>  技术的诞生是为了解决某个问题，模块化也是，在js模块化诞生历程。</p><ul><li>第一阶段<br>在JavaScript 语言刚刚诞生的时候，它仅仅用于实现页面中的一些小效果，一个页面所用到的JS可能只有区区几百行的代码，在这种情况下语言存在的缺陷被大家有意的忽略，程序的规模实在太小，只要开发人员小心谨慎，往往不会造成什么问题。在这个阶段不存在专业的前端工程师。</li><li>第二个阶段<br>ajax 的出现，逐渐改变了JavaScript 在浏览器中扮演的角色，它不仅可以实现小的效果，还可以和服务器之间进行交互，以更好的体验来改变数据。JS 的代码量逐渐增加，从最初的几百行到后来的几万行，前端的程序变的复杂。<br> 有三个问题阻碍了前端的程序的规模进一步扩大<ul><li>浏览器解释执行JS的速度太慢</li><li>用户的电脑配置不足</li><li>更多的代码带来的全局变量污染，依赖关系混乱等问题。<br>以上问题成为前端开发挥之不去的阴影和原罪。<ul><li>第三个阶段<br>到了2008 年 谷歌的V8 引擎发布，将JS的执行速度推上了一个新的台阶，甚至可以和后端语言媲美。个人电脑的配置开始飞跃，制约前端发展的两大问题得以解决，只剩下一个全局变量污染和依赖管理混乱的问题。<br>在此时Ryan Dahl 需要在服务器端手写一个高性能的web服务，高性能必须尽可能的减少线程，而要减少线程避免不了要使用异步方案，在他一筹莫展的时候谷歌的V8 引擎吸引了他的注意他发现JS就是最好的实现web服务器的语言，它天生是单线程，并且是基于异步的，有了V8 引擎的支撑，它的执行速度完全可以撑起一个服务器他基于V8 引擎 对源码作了一些修改 推出了该web服务项目命名为 nodejs。从此，JS第一次堂堂正正的入主后端，不再是必须附属于浏览器的“玩具”语言了。也是从刻开始，人们开始认识到，JS 是一门真正的语言，它依附于运行环境(运行时)(宿主程序)而执行。nodejs 的诞生，便把JS 中的最后一个问题放到了台前即<code>全局变量污染和依赖混乱</code>问题。<br>经过社区的激烈讨论，最终，形成了一个模块化方案，即CommonJS，该方案彻底解决了全局变量污染和依赖混乱的问题。</li><li>第四个阶段<br>CommonJS(后端模块化方案) 的出现打开了前端开发者的思路。既然后端可以使用模块化的JS，那作为JS 语言的的老东家浏览器为啥不行呢？于是，开始有人想办法把CommonJS 语言运用到浏览器中。但是把CommonJS运用到浏览器里面存在诸多困难</li></ul><ul><li>CommonJS 是同步加载，适用于服务器端的模块加载，因为所用的模块都存放在本地硬盘，可以同步加载完成，等待时间就是硬盘的读取时间，但是对于浏览器，却是一个大问题，因为浏览器都放在服务器端，等待的时间取决于网速的快慢，可能要等很是长时间，浏览器处于“假死”状态。</li><li>浏览器不兼容CommonJS 的根本原因，在于缺少四个Node.js环境的变量。<ul><li>module</li><li>export </li><li>require</li><li>global<br>于是有些开发者就想，既然CommonJS运用到浏览器困难，我们干嘛不自己重新定一个模块化的标准出来，非得用CommonJS 的标准。于是很快AMD 规范出炉，它解决的问题和CommonJS 一样即 解决JS 全局变量污染和依赖混乱的问题，但是可以更好的适应浏览器环境相继的CMD规范出炉，它对AMD 的规范进行了改进。<br>这些行为，都受到了ECMA官方的密切关注，2015年，ES6发布，它提出了官方的模块化解决方案——ES6 模块化。从此以后，模块化成为了JS 本身特有的性质，这门语言有了可以和其他语言较量的资本，成为了可以编写大型应用的正式语言。<br><img src="https://img-blog.csdnimg.cn/ceef233a5b4447ac8782d440ce62445c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Y-25YeM5aSp,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="JS模块化发展时间线"></li></ul></li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> JS 模块化 </category>
          
          <category> JS模块化发展 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>git 命令</title>
      <link href="/2023/03/01/git%E5%91%BD%E4%BB%A4/"/>
      <url>/2023/03/01/git%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="专有名词"><a href="#专有名词" class="headerlink" title="专有名词"></a>专有名词</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Workspance: 工作区</span><br><span class="line">Index / Stage: 暂存区</span><br><span class="line">Repository: 仓库区(本地仓库)</span><br><span class="line">Remote: 远程仓库</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/18087435-2b52aaf65be47442.jpg" alt="git专有名词"></p><h2 id="创建本地代码库"><a href="#创建本地代码库" class="headerlink" title="创建本地代码库"></a>创建本地代码库</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 初始化一个git 代码库</span><br><span class="line"></span><br><span class="line">git init</span><br><span class="line"></span><br><span class="line">// 新建一个目录，将其初始化为Git代码库。</span><br><span class="line"></span><br><span class="line">git init [project-name]</span><br><span class="line"></span><br><span class="line">// 下载一个项目到本地</span><br><span class="line"></span><br><span class="line">git clone</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>git 的设置文件为.gitconfig,它可以在用户主目录下(全局配置)，也可以在项目目录下(项目配置)。</p><p>可以配置忽略文件，</p><h2 id="增加-删除文件"><a href="#增加-删除文件" class="headerlink" title="增加/删除文件"></a>增加/删除文件</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 添加指定文件到暂存区</span><br><span class="line">git add [file1] ...</span><br><span class="line"></span><br><span class="line">// 添加指定目录到暂存区</span><br><span class="line">git add 文件夹名</span><br><span class="line"></span><br><span class="line">// 添加当前目录的所有文件到暂存区</span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line">// 删除工作区文件夹，并且将这次删除放入暂存区</span><br><span class="line">git rm 文件名</span><br></pre></td></tr></table></figure><h2 id="代码提交"><a href="#代码提交" class="headerlink" title="代码提交"></a>代码提交</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 提交暂存区到仓库区</span><br><span class="line">git commit -m &#x27;填写提交的信息&#x27;</span><br><span class="line"></span><br><span class="line">// 提交指定的文件到仓库区</span><br><span class="line">git commit 文件名 -m &#x27;填写提交的信息&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// 列出所有的本地分支</span><br><span class="line">git branch</span><br><span class="line"></span><br><span class="line">// 列出所有远程分支</span><br><span class="line">git branch -r</span><br><span class="line"></span><br><span class="line">// 列出所有本地分支和远程分支</span><br><span class="line">git branch -a</span><br><span class="line"></span><br><span class="line">// 新建一个分支，但依然停留在当前分支</span><br><span class="line">git branch  分支名</span><br><span class="line"></span><br><span class="line">// 新建一个分支，并切换到该分支</span><br><span class="line">git checkout -b 分支名</span><br><span class="line"></span><br><span class="line">// 切换到指定的分支，并更新工作区</span><br><span class="line">git checkout 要切换的分支名</span><br><span class="line"></span><br><span class="line">// 合并分支到当前分支</span><br><span class="line">git merge 要合并的分支名</span><br><span class="line"></span><br><span class="line">// 删除分支</span><br><span class="line">git branch -d 要删除的分支名</span><br><span class="line"></span><br><span class="line">// 删除远程分支名</span><br><span class="line">git branch -dr 要删除的远程分支名</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="查看信息"><a href="#查看信息" class="headerlink" title="查看信息"></a>查看信息</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 显示所有变更的文件</span><br><span class="line">git status</span><br><span class="line"></span><br><span class="line">// 显示当前分支的版本历史</span><br><span class="line">git log</span><br><span class="line"></span><br><span class="line">// 显示 commit 历史，以及每次commit发生变更的文件</span><br><span class="line">git log --stat</span><br><span class="line"></span><br><span class="line">// 显示暂存区和工作区的代码差异</span><br><span class="line">git diff</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="远程同步"><a href="#远程同步" class="headerlink" title="远程同步"></a>远程同步</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 更新远程仓库</span><br><span class="line">git remote update</span><br><span class="line"></span><br><span class="line">// 下载远程仓库的所有变动</span><br><span class="line">git fetch</span><br><span class="line"></span><br><span class="line">// 显示所有远程仓库</span><br><span class="line">git remote -v</span><br><span class="line"></span><br><span class="line">// 取回远程仓库的变化，并于本地分支合并</span><br><span class="line">git pull 远程仓库名 远程仓库的分支名</span><br><span class="line"></span><br><span class="line">// 上传本地指定分支到远程仓库</span><br><span class="line">git push 远程仓库名 远程仓库的分支名</span><br><span class="line"></span><br><span class="line">// 强行推送当前分支到远程仓库，即使有冲突</span><br><span class="line">git push 远程仓库名 -- force</span><br><span class="line"></span><br><span class="line">// 推送所有分支到远程仓库</span><br><span class="line">git push 远程仓库名 --all</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">//  恢复暂存区的指定文件到工作区</span><br><span class="line">git checkout [file]</span><br><span class="line"></span><br><span class="line">// 恢复某个commit的指定文件到暂存区和工作区</span><br><span class="line">git checkout [commit] [file]</span><br><span class="line"></span><br><span class="line">// 恢复暂存区的所有文件到工作区</span><br><span class="line">git checkout .</span><br><span class="line"></span><br><span class="line">// 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</span><br><span class="line">git reset [file]</span><br><span class="line"></span><br><span class="line">// 重置暂存区与工作区，与上一次commit保持一致</span><br><span class="line">git reset --hard</span><br><span class="line"></span><br><span class="line">// 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</span><br><span class="line">git reset [commit]</span><br><span class="line"></span><br><span class="line">// 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致</span><br><span class="line">git reset --hard [commit]</span><br><span class="line"></span><br><span class="line">// 重置当前HEAD为指定commit，但保持暂存区和工作区不变</span><br><span class="line">git reset --keep [commit]</span><br><span class="line"></span><br><span class="line">// 新建一个commit，用来撤销指定commit</span><br><span class="line">// 后者的所有变化都将被前者抵消，并且应用到当前分支</span><br><span class="line">git revert [commit]</span><br><span class="line"></span><br><span class="line">// 暂时将未提交的变化移除，稍后再移入</span><br><span class="line">git stash</span><br><span class="line">git stash pop</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>运算符的扩展,</title>
      <link href="/2023/03/01/es6/%E6%96%B0%E5%A2%9E%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
      <url>/2023/03/01/es6/%E6%96%B0%E5%A2%9E%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<h2 id="指数运算符"><a href="#指数运算符" class="headerlink" title="指数运算符"></a>指数运算符</h2><p>新增了一个指数运算符(**)</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2**2  // 4 </span><br><span class="line">  2*2</span><br><span class="line">2**3  // 8</span><br><span class="line">  2*2*2 </span><br></pre></td></tr></table></figure><ul><li><p>指数运算符可以与等号结合，形成一个新的赋值运算符(**=)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let a = 1.5 </span><br><span class="line">a** = 2</span><br><span class="line">  // 等同于 a = a * a </span><br><span class="line">let b = 4 </span><br><span class="line">b** = 3</span><br><span class="line">  // 等同于 b = b * b * b </span><br></pre></td></tr></table></figure><h2 id="链判断运算符"><a href="#链判断运算符" class="headerlink" title="链判断运算符"></a>链判断运算符</h2><p>编程中，如果要读取对象内部的某个属性，往往需要判断一下，属性的上层对象是否存在。对象嵌套太深，判断会需要很多层，这样很是麻烦。<br>ES2020引入了 <code>链判断运算符</code> <code>?.</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 之前写法</span><br><span class="line"> var firstName = obj &amp;&amp; obj.a &amp;&amp; obj.a.b &amp;&amp; obj.a.b.c || &#x27;default&#x27;</span><br><span class="line"> var fooVlaue = fooInput ? fooInput.value : undefined</span><br><span class="line"> // 现在写法</span><br><span class="line"> var firstName = obj?.a?.b?.c</span><br><span class="line"> var fooVlaue = fooInput?.value</span><br><span class="line">   // 直接链式调用的时候判断，左侧的对象是否为 null 或 undefined。如果是的，就不再往下运算直接返回 null 或者 undefined 。</span><br><span class="line"> iterator.return?.()</span><br><span class="line">   // iterator.return如果有定义，就会调用该方法，否则 iterator.return直接返回undefined，不在执行后面的部分。</span><br></pre></td></tr></table></figure><ul><li>使用 链式判断运算符的注意点<ul><li>短路机制<br>本质上?.运算符相当于一种短路机制，只要不满足条件，就不再往下执行。</li><li>括号的影响<br>如果属性链有圆括号，链判断运算符对圆括号外部没有影响，只对圆括号内部有影响。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(a?.b).c</span><br><span class="line">// 等价于 (a == null ? undefined : a.b).c</span><br><span class="line">不管对象a 是否存在，圆括号后面的.c 总是会执行。</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h2 id="Null-判断运算符"><a href="#Null-判断运算符" class="headerlink" title="Null 判断运算符"></a>Null 判断运算符</h2><p>  在读取对象属性的时候，如果某个属性的值是null 或者 undefined，有时候需要为他们指定默认值，常用的方法是 || ，但是这样写是错误的，我们的意愿是当为null 或者undefined 的时候给定默认值，但是 当值为 空字符串，false 0 的时候默认值也会生效<br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var param = null/undefined</span><br><span class="line">var result = param || &#x27;default&#x27;</span><br><span class="line">  result   //&#x27;default&#x27;</span><br><span class="line"></span><br><span class="line">var param2 =  false/0</span><br><span class="line">var result2 = param || &#x27;default&#x27;</span><br><span class="line">  result2  //&#x27;default&#x27;</span><br></pre></td></tr></table></figure><br>  为了避免上面的情况 ES2020 引入一个新的Null 运算符 <code>??</code>。它的行为类似 || ,但是只有运算符左侧的值为 null 或 undefined时，才会返回右侧的值。<br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var param = null/undefined</span><br><span class="line">var result = param ?? &#x27;default&#x27;</span><br><span class="line">  result   //&#x27;default&#x27;</span><br><span class="line"></span><br><span class="line">var param2 =  false/0</span><br><span class="line">var result2 = param ?? &#x27;default&#x27;</span><br><span class="line">  result2  // false/0 </span><br></pre></td></tr></table></figure><br>  该运算符的一个目的就是跟链判断运算符?.配合使用，为null 或 undefined 的值设置默认值。<br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var result = obj?.a ?? true</span><br></pre></td></tr></table></figure></p><h2 id="逻辑赋值运算符"><a href="#逻辑赋值运算符" class="headerlink" title="逻辑赋值运算符"></a>逻辑赋值运算符</h2><p>ES2021 引入了三个新的逻辑赋值运算符，将逻辑运算符与赋值运算符结合。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> // 或赋值运算符</span><br><span class="line"> x||=y</span><br><span class="line">   // 等同于</span><br><span class="line">     x || (x = y)</span><br><span class="line"> // 与赋值运算符</span><br><span class="line"> x &amp;&amp;= y </span><br><span class="line">   // 等同于</span><br><span class="line">     x &amp;&amp; (x = y)</span><br><span class="line"> x ??= y </span><br><span class="line">   // 先判断x 是否是 null/undefined 是的话 执行 x = y  </span><br><span class="line">var x = 1</span><br><span class="line">var y = &#x27;&#x27;</span><br><span class="line"> x ||= y </span><br><span class="line">   // 1</span><br><span class="line"> x &amp;&amp;= y </span><br><span class="line">   // &#x27;&#x27;</span><br><span class="line"> x ??= y </span><br><span class="line">   // 1</span><br></pre></td></tr></table></figure><p>  他们的用途是，为变量或属性设置默认值<br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 老的写法</span><br><span class="line">user.id = user.id || 1</span><br><span class="line">// 新写法</span><br><span class="line">user.id ||= 1 </span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> es6 </category>
          
          <category> 运算符扩展 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Symbol,</title>
      <link href="/2023/03/01/es6/Symbol/"/>
      <url>/2023/03/01/es6/Symbol/</url>
      
        <content type="html"><![CDATA[<h2 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h2><p>  对象的属性名都是字符串，容易造成属性名冲突。ES6 引入一种新的原始数据类型 Symbol，表示独一无二的值。<br>  Symbol 值通过 Symobl 函数生成。凡是属性名属于 Symbol 类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let s = Symbol()</span><br><span class="line">  typeof s </span><br><span class="line">    // &#x27;symbol&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>  <code>Symbol</code> 函数不能使用 new 命令，否则会报错，new 命令生成的是一个对象，Symbol 值不是对象，是类似字符串的数据类型。</p><ul><li>js 原始类型数据，除了 <code>null, undefined 和 symbol</code>外，其他类型的数据 都可以通过 new 命令初始化值，该命令返回的是一个 typeof 类型为 object的值。</li><li>Symbol 函数可以接收一个字符串作为参数，表示Symbol 实例的描述，主要是为了区分生成的变量。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let s1 = Symbol(&#x27;foo&#x27;)</span><br><span class="line">  // Symbol(foo)</span><br><span class="line">let s2 = Symbol(&#x27;bar&#x27;)</span><br><span class="line">  // Symbol(bar)</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>注意点 Symbol 值不能与其他类型的值进行运算，会报错。但是，Symbol 的值可以转换为字符串。Symbol的值可以转换为布尔值，但是不能转换为数值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var sy = Symbol(&#x27;mySymbol&#x27;)</span><br><span class="line">  &#x27;Your symbol is&#x27; + sy</span><br><span class="line">  `your symbol is $&#123;sy&#125;`</span><br><span class="line">String(sy)</span><br><span class="line">  // &#x27;Symbol(mySymbol)&#x27;</span><br><span class="line">sy.toStirng()</span><br><span class="line">  // &#x27;Symbol(mySymbol)&#x27;</span><br><span class="line">Boolean(sy)</span><br><span class="line">  // true</span><br></pre></td></tr></table></figure><h3 id="作为属性名"><a href="#作为属性名" class="headerlink" title="作为属性名"></a>作为属性名</h3><p>Symbol值都不相等的，用于对象的属性名，就能保证不会出现同名的属性。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var sym = Symbol()</span><br><span class="line">// 第一种写法</span><br><span class="line">  var a = &#123;&#125;</span><br><span class="line">  a[sym] = &#x27;Hello&#x27;</span><br><span class="line">// 第二种写法</span><br><span class="line">  var a = &#123;</span><br><span class="line">    [sym]: &#x27;Hello&#x27; </span><br><span class="line">  &#125;</span><br><span class="line">// 第三种写法 </span><br><span class="line">  var a = &#123;&#125;</span><br><span class="line">  Object.defineProperty(a,sym,&#123;value:&#x27;Hello&#x27;&#125;)</span><br></pre></td></tr></table></figure></li><li><p>注意点：Symbol 值作为对象的属性名的时候，不能通过 点运算赋值，如果是通过点运算赋的值，是和原来的为对象添加属性一样。因为点运算符后面总是字符串，所以不会读取 mySymbol 作为标识所指代的那个值，导致a的属性名实际上是一个字符串，而不是一个Symbol 值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var mySymbol = Symbol()</span><br><span class="line">var a = &#123;&#125;</span><br><span class="line">a.mySymbol = &#x27;Hello&#x27;</span><br><span class="line">a[mySymbol] </span><br><span class="line">  // undefined</span><br><span class="line">a[&#x27;mySymbol&#x27;]</span><br><span class="line">  // Hello</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> es6 </category>
          
          <category> Symbol </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>element使用不常用方法总结</title>
      <link href="/2023/03/01/element%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/element%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/"/>
      <url>/2023/03/01/element%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/element%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="el-table-相同列进行合并"><a href="#el-table-相同列进行合并" class="headerlink" title="el-table  相同列进行合并"></a>el-table  相同列进行合并</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">  &lt;el-table</span><br><span class="line">      :data=&quot;tableDataqingkaung&quot;</span><br><span class="line">      border</span><br><span class="line">      style=&quot;width: 100%&quot;</span><br><span class="line">      :span-method=&quot;objectSpanMethod&quot;</span><br><span class="line">      :row-class-name=&quot;tableRowClassName&quot;</span><br><span class="line">    &gt;</span><br><span class="line">      &lt;el-table-column label=&quot;ID&quot; prop=&quot;date&quot; width=&quot;100&quot; align=&quot;center&quot;&gt;</span><br><span class="line">      &lt;/el-table-column&gt;</span><br><span class="line">      &lt;el-table-column</span><br><span class="line">        label=&quot;供电分区代码/影响区域&quot;</span><br><span class="line">        prop=&quot;options&quot;</span><br><span class="line">        align=&quot;center&quot;</span><br><span class="line">        width=&quot;300&quot;</span><br><span class="line">      &gt;</span><br><span class="line">        &lt;template slot-scope=&quot;scope&quot;&gt;</span><br><span class="line">          &lt;span v-html=&quot;scope.row.options&quot;&gt;&lt;/span&gt;</span><br><span class="line">        &lt;/template&gt;</span><br><span class="line">      &lt;/el-table-column&gt;</span><br><span class="line"></span><br><span class="line">      &lt;el-table-column label=&quot;行车调整原则&quot; prop=&quot;rules&quot;&gt;</span><br><span class="line">        &lt;template slot-scope=&quot;scope&quot;&gt;</span><br><span class="line">          &lt;span v-html=&quot;scope.row.rules&quot;&gt;&lt;/span&gt;</span><br><span class="line">        &lt;/template&gt;</span><br><span class="line">      &lt;/el-table-column&gt;</span><br><span class="line">    &lt;/el-table&gt;</span><br><span class="line">/*</span><br><span class="line">* data 传入的参数</span><br><span class="line">* rules 判断的属性值</span><br><span class="line">*/</span><br><span class="line">  getSpanArr(data) &#123;</span><br><span class="line">      this.spanArr = []</span><br><span class="line">      for (var i = 0; i &lt; data.length; i++) &#123;</span><br><span class="line">        if (i === 0) &#123;</span><br><span class="line">          this.spanArr.push(1);</span><br><span class="line">          this.pos = 0</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          // 判断当前元素与上一个元素是否相同  inAccessCode（批次字段）</span><br><span class="line">          if (data[i].rules == data[i - 1].rules) &#123;</span><br><span class="line">            this.spanArr[this.pos] += 1;</span><br><span class="line">            this.spanArr.push(0);</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            this.spanArr.push(1);</span><br><span class="line">            this.pos = i;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    objectSpanMethod(&#123; row, column, rowIndex, columnIndex &#125;) &#123;</span><br><span class="line">      if (columnIndex === 2) &#123;  // 指定那一列进行合并</span><br><span class="line">        const _row = this.spanArr[rowIndex];</span><br><span class="line">        const _col = _row &gt; 0 ? 1 : 0;</span><br><span class="line">        return &#123;</span><br><span class="line">          rowspan: _row,</span><br><span class="line">          colspan: _col</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> element使用不常用方法总结 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>使用中遇到的问题解决方案</title>
      <link href="/2023/03/01/css/%E4%BD%BF%E7%94%A8%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/2023/03/01/css/%E4%BD%BF%E7%94%A8%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="设置border-有白色边"><a href="#设置border-有白色边" class="headerlink" title="设置border 有白色边"></a>设置border 有白色边</h3><p> 在设置boder后，同时设置背景色，元素周围会有一圈白色的边。</p><p> 解决 使用 outline 来代替border<br>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">outline</span>:solid <span class="number">1px</span> red;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> css 使用遇到的问题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>async await,</title>
      <link href="/2023/03/01/async,await/"/>
      <url>/2023/03/01/async,await/</url>
      
        <content type="html"><![CDATA[<h2 id="async"><a href="#async" class="headerlink" title="async"></a>async</h2><p><code>异步编程的最高境界，就是根本不用关心它是不是异步</code></p><p><code>async 函数是 Generator 函数的语法糖</code></p><p>async 是一个修饰符，async定义的函数会默认返回一个Promise对象resolve的值，因此对async函数可以直接进行then操作，返回的值即为then方法的传入函数</p><p>async 函数(包含函数语句，函数表达式，Lambda表达式) 会返回一个Promise 对象，如果在函数中直接返回一个直接量，async 会把这个直接量通过 Promise.resolve() 封装成Promise对象</p><h2 id="await"><a href="#await" class="headerlink" title="await"></a>await</h2><p>一般来说，await 是在等待一个async 函数完成。await 等待的是一个表达式，这个表达式的计算结果是 Promise 对象或者其它值（换句话说，就是没有特殊限定）。</p><p>async 函数返回的是一个Promise 对象，所以await 可以用于等待一个async 函数的返回值，它等待的实际是一个返回值，await不仅仅用于等待Promise对象它可以等待任意表达式的结果。即await后面是可以接普通函数或者直接量的。</p><ul><li>awit 等到了要等东西，<ul><li>如果等到的是一个promise对象，await会阻塞后面的代码，等着Promise对象resolve ,然后得到resolve的值，作为await表达式的运算结果。</li><li>如果不是promise 对象，那await表达式的运算结果就是它等到的东西。</li><li>await 等待的不是一个Promise 对象的时候，相当于 await Promise.resolve</li></ul></li></ul><h2 id="async-await-的优势"><a href="#async-await-的优势" class="headerlink" title="async await 的优势"></a>async await 的优势</h2><p>优势在于处理then 链</p>]]></content>
      
      
      <categories>
          
          <category> async await </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>TypeScript</title>
      <link href="/2023/03/01/TypeScript/ts/"/>
      <url>/2023/03/01/TypeScript/ts/</url>
      
        <content type="html"><![CDATA[<h2 id="TypeScript-是什么"><a href="#TypeScript-是什么" class="headerlink" title="TypeScript 是什么"></a>TypeScript 是什么</h2><h3 id="TS-简介"><a href="#TS-简介" class="headerlink" title="TS 简介"></a>TS 简介</h3><p> Ts是微软开发的一个开源编程语言，通过在JS的基础上添加静态类型定义构建而成。TS通过TS编译器或者Babel转译为JS代码，可运行在任何浏览器，任何操作系统。</p><h3 id="TS-和-JS的区别"><a href="#TS-和-JS的区别" class="headerlink" title="TS 和 JS的区别"></a>TS 和 JS的区别</h3><p> TS 是JS 的一个超集，之间没有所属关系，ts扩展了js 弱类型语言的限制，增加更多的模块解析方式和语法糖。ts 并不是一个可以独立运行的语言，大多数时候可以被转译成js 运行。 可以认为 ts 相当于功能更丰富的编译型的js。</p><h3 id="为什么要有TS"><a href="#为什么要有TS" class="headerlink" title="为什么要有TS"></a>为什么要有TS</h3><p>传统的js本身已经完全满足应用打开，但是在大型项目或者插件的开发场景中，js 弱类型语言的不足便暴露出来，由于js是解释型语言，在代码编译的过程中无法轻松的实现良好的类型约束和类型推断。若开发者提供了一个解释依赖包给其他开发者来使用，使用依赖的开发者并不能显示观察依赖包的内部组成。这样导致在代码阅读上无法确定该属性的明确类型，会导致代码运行上存在风险。</p><p>  综上所述，js在代码的可维护性上存在一些弱项，所有强类型的ts正好适用于此类型开发场景。<br>   ts 强类型的约束性及其面向接口编程的约束性可以让ts 语言开发的应用有极强的维护性，代价是更大的代码篇幅。<br>   ts适用于插件提供者，依赖库提供者，基于js的服务端项目，已经大型项目的工程化开发使用。</p><h2 id="TypeScript-语法"><a href="#TypeScript-语法" class="headerlink" title="TypeScript 语法"></a>TypeScript 语法</h2><h3 id="基础数据类型"><a href="#基础数据类型" class="headerlink" title="基础数据类型"></a>基础数据类型</h3><h4 id="jS的八种内置类型"><a href="#jS的八种内置类型" class="headerlink" title="jS的八种内置类型"></a>jS的八种内置类型</h4>  <figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">str</span>: <span class="built_in">string</span> = <span class="string">&quot;111&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">num</span>: <span class="built_in">number</span> = <span class="number">123</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">bool</span>: <span class="built_in">boolean</span> = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">u</span>: <span class="literal">undefined</span> = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">nu</span>: <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">obj</span>: <span class="built_in">object</span> = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">big</span>: <span class="built_in">bigint</span> = <span class="number">100n</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">sym</span>: <span class="built_in">symbol</span> = <span class="title class_">Symbol</span>(<span class="string">&quot;me&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="其他类型"><a href="#其他类型" class="headerlink" title="其他类型"></a>其他类型</h3><h4 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h4><ul><li><p>对数组类型的定义有两种方式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">arrStr</span>: string[] = [<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="attr">arrNum</span>: <span class="title class_">Array</span>&lt;string&gt; = [<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>];</span><br></pre></td></tr></table></figure></li><li><p>定义联合类型数组</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">arr2</span>: (<span class="built_in">string</span> | <span class="built_in">number</span>)[] = [<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="attr">arr1</span>: <span class="title class_">Array</span>&lt;<span class="built_in">string</span> | <span class="built_in">number</span>&gt; = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br></pre></td></tr></table></figure></li><li><p>定义指定对象成员的数组</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">ArrayObj</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">arrObj</span>: <span class="title class_">ArrayObj</span>[] = [&#123; <span class="attr">name</span>: <span class="string">&quot;xxx&quot;</span>, <span class="attr">age</span>: <span class="number">12</span> &#125;];</span><br><span class="line"><span class="comment">// 任意类型的数组</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">arrAny</span>: <span class="built_in">any</span>[] = [<span class="number">1</span>,<span class="string">&#x27;string&#x27;</span>,<span class="built_in">boolean</span>,<span class="literal">null</span>,<span class="literal">undefined</span>]</span><br><span class="line"><span class="keyword">let</span> <span class="attr">arrAny1</span>:<span class="title class_">Array</span>&lt;<span class="built_in">any</span>&gt; = [<span class="number">1</span>,<span class="number">2</span>,<span class="literal">true</span>,<span class="string">&#x27;string&#x27;</span>]</span><br></pre></td></tr></table></figure></li></ul><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><ul><li><p>函数声明</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>函数表达式</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">mySum</span>: <span class="function">(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span> = <span class="keyword">function</span> (<span class="params">x: <span class="built_in">number</span> y:<span class="built_in">number</span></span>): <span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>可选参数且函数有返回值</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">joinName</span>(<span class="params">firstName: <span class="built_in">string</span>, lastName?: <span class="built_in">string</span></span>): <span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> firstName + lastName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>参数默认值</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">names</span>(<span class="params">firstName: <span class="built_in">string</span>, lastName: <span class="built_in">string</span> = <span class="string">&quot;Cat&quot;</span></span>): <span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> firstName + lastName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>剩余参数</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">push</span>(<span class="params">arr: <span class="built_in">any</span>[], ...items: <span class="built_in">any</span>[]</span>) &#123;</span><br><span class="line">  items.<span class="title function_">forEach</span>(<span class="function">(<span class="params">element</span>) =&gt;</span> &#123;</span><br><span class="line">    arr.<span class="title function_">push</span>(element);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>带参数无返回值<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params">name:<span class="built_in">string</span>,age:<span class="built_in">number</span></span>):<span class="built_in">void</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul></li><li><p>函数重载<br>js是一个动态语言，我们通常会使用不同类型的参数来调用同一个函数，该函数会根据不同的参数返回不同类型的调用结果;</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">add</span>(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"><span class="title function_">add</span>(<span class="string">&quot;1&quot;</span>,<span class="string">&quot;2&quot;</span>)</span><br></pre></td></tr></table></figure><ul><li><p>定义联合类型 </p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义联合类型同时为该联合类型取一个别名</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Combinable</span> = <span class="built_in">string</span> | <span class="built_in">number</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用联合类型</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a:Combinable,b:Combinable</span>)&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> a === <span class="string">&#x27;string&#x27;</span> || <span class="keyword">typeof</span> b === <span class="string">&#x27;string&#x27;</span>) &#123;    </span><br><span class="line">  <span class="keyword">return</span> a.<span class="title function_">toString</span>() + b.<span class="title function_">toString</span>();   </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Tuple-元组"><a href="#Tuple-元组" class="headerlink" title="Tuple(元组)"></a>Tuple(元组)</h3></li></ul></li><li><p>元组定义<br>元组是TypeSctipt 中特有的类型，其工作方式类似于数组元组最重要的特性是可以限制<code>数组元素的个数和类型</code>,特别适合用来实现多值返回。<br>元组用于保存定长定数据类型的数据。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">x</span>: [<span class="built_in">string</span>,<span class="built_in">number</span>] years</span><br><span class="line"><span class="comment">// 类型必须匹配且个数必须为2</span></span><br><span class="line">x = [<span class="string">&quot;12&quot;</span>,<span class="number">10</span>] <span class="comment">// ok</span></span><br><span class="line">x = [<span class="number">10</span>,<span class="number">10</span>]   <span class="comment">// error</span></span><br><span class="line">  </span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>元组类型的解构赋值</p></li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">employee</span>:[<span class="built_in">number</span>,<span class="built_in">string</span>] = [<span class="number">1</span>,<span class="string">&#x27;string&#x27;</span>]</span><br><span class="line"><span class="keyword">let</span> [id,username] = employee</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`id:<span class="subst">$&#123;id&#125;</span>`</span>)   <span class="comment">// id:1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`username:<span class="subst">$&#123;username&#125;</span>`</span>)  <span class="comment">// username:string</span></span><br></pre></td></tr></table></figure><p>注意点，在解构时，如果解构数组元素的个数不能超过元组中元素的个数，否则也会出现错误。</p><ul><li><p>元组类型的可选元素<br>在定义元组类型时，可以通过 ? 号来声明元组类型的可选元素。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">optionalTuple</span>:[<span class="built_in">string</span>,<span class="built_in">boolean</span>?];</span><br><span class="line">optionalTuple = [<span class="string">&#x27;string&#x27;</span>,<span class="literal">true</span>]</span><br><span class="line">optionalTuple = [<span class="string">&#x27;string&#x27;</span>]</span><br></pre></td></tr></table></figure><h3 id="枚举-interFace"><a href="#枚举-interFace" class="headerlink" title="枚举 interFace"></a>枚举 interFace</h3><p>是一个完全抽象的对象，一个interface 可以对应多个class 对其内部的未实现方法进行实现，ts 中，interface 主要用于类型描述。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">User</span>&#123;</span><br><span class="line">  <span class="attr">name</span>:<span class="built_in">string</span></span><br><span class="line">  <span class="attr">age</span>:<span class="built_in">number</span></span><br><span class="line">  <span class="attr">sex</span>:<span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">obj</span>:<span class="title class_">User</span> =&#123;</span><br><span class="line">  <span class="attr">name</span>:<span class="built_in">string</span></span><br><span class="line">  <span class="attr">age</span>:<span class="built_in">number</span></span><br><span class="line">  <span class="attr">sex</span>:<span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//是强约束 约定该对象必须包含name,age,sex 这几个属性，不能有其他对象</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Us</span>&#123;</span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">name</span>:<span class="built_in">string</span>,  <span class="comment">// 表示该属性只读，不可以修改</span></span><br><span class="line">  <span class="attr">age</span>:<span class="built_in">number</span>,</span><br><span class="line">  [<span class="attr">props</span>:<span class="built_in">string</span>]:<span class="built_in">any</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 可以有约定以外的其他属性</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Func</span>&#123;</span><br><span class="line">  (name):<span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义函数的接口</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">fun</span>:<span class="title class_">Func</span> = <span class="keyword">function</span>(<span class="params">name:<span class="built_in">string</span></span>):<span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">User</span> &#123;</span><br><span class="line">  <span class="attr">name</span>:<span class="built_in">string</span>,</span><br><span class="line">  <span class="attr">age</span>:<span class="built_in">number</span>,</span><br><span class="line">  <span class="attr">sex</span>:<span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Admin</span>&#123;</span><br><span class="line">  <span class="attr">name</span>:<span class="built_in">string</span>,</span><br><span class="line">  <span class="attr">age</span>:<span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Person</span> = <span class="title class_">User</span> | <span class="title class_">Admin</span></span><br><span class="line"><span class="keyword">let</span> userobj =  <span class="title class_">Array</span>&lt;<span class="title class_">Person</span>&gt; = [</span><br><span class="line">  &#123;<span class="attr">name</span>:<span class="string">&#x27;&#x27;</span>,<span class="attr">age</span>:<span class="string">&#x27;&#x27;</span>,<span class="attr">sex</span>:<span class="string">&#x27;&#x27;</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">name</span>:<span class="string">&quot;&quot;</span>,<span class="attr">age</span>:<span class="string">&quot;&quot;</span>&#125;</span><br><span class="line">]</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p> 泛型是静态类型语言的另一灵魂工具，这里体现于静态类型的语言在定义类型时必须明确类型而造成的问题。<br> 当函数的参数和返回类型明确时，相同结构的函数需要根据不同的类型定义多个，这种情况很容易将代码的复杂度提高降低可维护性</p>  <figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> test&lt;T&gt;(<span class="attr">arg</span>:T):T&#123;</span><br><span class="line">  <span class="keyword">return</span> arg</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="类型推断"><a href="#类型推断" class="headerlink" title="类型推断"></a>类型推断</h3><p>在很多情况下，Typescript会根据上下文环境自动推断出变量的类型，无需我们再写明类型注解。<br>  <figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;ss&#x27;</span></span><br><span class="line"><span class="keyword">let</span> num = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> bool = <span class="literal">true</span></span><br></pre></td></tr></table></figure><br>我们把TypeScript 这种基于赋值表达式推断类型的能力称之为 <code>类型推断</code></p><h3 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h3><p>  有时候会遇到这样的情况，你会比ts 更了解某个值的详细信息通常这会发生在你清楚的知道一个实体具有比它现有类型更确切的类型。<br>  通过类型断言这种方式告诉编辑器 ，”相信我，我知道自己在干什么”。类型断言好比其他语言里的类型转换，但是不进行特殊的数据检查和解构。它没有运行时的影响，只是在编译阶段起作用。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 尖括号语法</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">someValue</span>:<span class="built_in">any</span> = <span class="string">&#x27;this is a string&#x27;</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">strLength</span>:<span class="built_in">number</span> = (&lt;<span class="built_in">string</span>&gt;someValue).<span class="property">length</span></span><br><span class="line"><span class="comment">// as 语法</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">someValue</span>:<span class="built_in">any</span> = <span class="string">&#x27;this is a string&#x27;</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">strLength</span>:<span class="built_in">number</span> = (someValue <span class="keyword">as</span> <span class="built_in">string</span>).<span class="property">length</span></span><br></pre></td></tr></table></figure><h3 id="非空断言"><a href="#非空断言" class="headerlink" title="非空断言"></a>非空断言</h3><p>  在上下文中当类型检查器无法判定类型时，一个新的后缀表达式操作符! 可以用于断言操作对象是非 null 和undefined 类型，<code>x! 将从x值域中排除 null 和undefined</code><br>  <figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">value</span>:<span class="literal">null</span> | <span class="literal">undefined</span> | <span class="built_in">string</span> </span><br><span class="line">value!.<span class="title function_">toString</span>() </span><br><span class="line">value.<span class="title function_">toString</span>()  <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure></p><h3 id="确定赋值断言"><a href="#确定赋值断言" class="headerlink" title="确定赋值断言"></a>确定赋值断言</h3><p>  允许实例属性和变量声明后面放置一个! 号，从而告诉 ts 该属性会被明确地赋值。<br>  <figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line"><span class="title function_">initialize</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Variable &#x27;x&#x27; is used before being assigned.(2454)</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span> * x); <span class="comment">// Error</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">initialize</span>(<span class="params"></span>) &#123; </span><br><span class="line">  x = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用确定赋值断言</span></span><br><span class="line"><span class="keyword">let</span> x!:<span class="built_in">number</span></span><br><span class="line"><span class="title function_">initialize</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>*x)</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">initialize</span>(<span class="params"></span>)&#123;</span><br><span class="line">  x=<span class="number">10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>  通过 <code>let x!:number</code> 确定赋值类型断言，ts编辑器就会知道该属性会被明确地赋值。</p><h3 id="字面量类型"><a href="#字面量类型" class="headerlink" title="字面量类型"></a>字面量类型</h3><p>  在ts 中字面量不仅可以表示值，还可以表示类型，即所谓的字面量类型。目前ts支持三种字面量类型：<code>字符串字面量类型、数字字面量类型、布尔字面量类型</code>。<br>  <figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">str</span>: <span class="string">&#x27;1&#x27;</span> =<span class="string">&#x27;string&#x27;</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">num</span>: <span class="number">1</span> = <span class="number">124</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">bool</span>: <span class="literal">true</span> = <span class="literal">false</span></span><br></pre></td></tr></table></figure></p><h3 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h3><p>  联合类型表示取值可以为多种类型中的一种，使用 | 分割每个类型</p>  <figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">strNum</span>: <span class="built_in">string</span> | <span class="built_in">number</span> </span><br><span class="line">strNum = <span class="string">&#x27;ss&#x27;</span></span><br><span class="line">strNum = <span class="number">123</span></span><br></pre></td></tr></table></figure><h3 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h3><p>  类型别名用来给一个类型起一个新名字。类型别名常用于联合类型</p>  <figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Message</span> = <span class="built_in">string</span> | <span class="built_in">string</span>[]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>  注意：类型别名是给类型起一个新的名字，并不是创建一个新的类型。</p><h3 id="交叉类型"><a href="#交叉类型" class="headerlink" title="交叉类型"></a>交叉类型</h3><p>  交叉类型是将多个类型合并为一个类型。我们可以把现有的多种类型叠加到一起成为一种类型，它包含了所需的所有类型的特性，使用<code>&amp;</code> 定义交叉类型。<br>  如果我们仅仅是把原始类型，字面量类型，函数类型等原始类型合并成为交叉类型是没有任何用处的。它的用处是将多个接口类型合并成一个类型，从而实现等同接口继承的效果，也就是所谓的合并接口类型。<br>  <figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span>  <span class="title class_">IntersectionType</span> = &#123;<span class="attr">id</span>:<span class="built_in">number</span>,<span class="attr">name</span>:<span class="built_in">string</span>&#125;&amp;&#123;<span class="attr">age</span>:<span class="built_in">number</span>&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">user</span>:<span class="title class_">IntersectonType</span> = &#123;</span><br><span class="line">  <span class="attr">id</span>:<span class="number">1</span>,</span><br><span class="line">  <span class="attr">name</span>:<span class="string">&#x27;name&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>:<span class="number">18</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>  上面例子，我们通过交叉类型，使得IntersectionType 同时拥有了id name age 所有属性，这里我们可以试着将合并接口类型理解为求并集。</p><h2 id="object-Object-和"><a href="#object-Object-和" class="headerlink" title="object Object 和 {}"></a>object Object 和 {}</h2><p>小 <code>object</code> 代表的是所有非原始类型，也就是我们不能把 <code>number string boolean</code> 等原始类型赋值给<code>object</code> 。在严格模式下 <code>null</code> 和<code>undefined</code> 类型也不能赋给 <code>object</code></p><p>大 <code>Object</code> 代表所有拥有 <code>toString hasOwnProperty</code> 方法的类型，所以所有原始类型、非原始类型都可以赋给 <code>Object</code>。 在严格模式下 <code>null</code> 和<code>undefined</code> 类型也不能赋给 <code>object</code><br>  大 Object 保护你原始类型，小object 仅包含非原始类型，所以大Object 似乎是小 object的父类型。实际上， 大Object 不仅是 小object的父类型，同时也是小object的子类型。<br>  注意点：尽管官方文档说可以使用小object代替 大Object，但是我们仍要明白大Object 并不完全等于小object。</p><p><code>&#123;&#125;</code> 空对象类型和大Object一样，也是表示原始类型和非原始类型的集合，并且在严格模式下，<code>null</code> 和 <code>undefined</code> 也不能赋给 <code>&#123;&#125;</code><br><code>综上结论：&#123;&#125;、大 Object 是比小 object 更宽泛的类型（least specific），&#123;&#125; 和大 Object 可以互相代替，用来表示原始类型（null、undefined 除外）和非原始类型；而小 object 则表示非原始类型。</code></p>]]></content>
      
      
      <categories>
          
          <category> TypeScript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Promise</title>
      <link href="/2023/03/01/Promise/"/>
      <url>/2023/03/01/Promise/</url>
      
        <content type="html"><![CDATA[<h2 id="Promise-是什么"><a href="#Promise-是什么" class="headerlink" title="Promise 是什么"></a>Promise 是什么</h2><ul><li>Promise 是进行异步编程的新的解决方案;</li><li>从语法上来讲: Promise 是一个构造函数;</li><li>从功能上来讲: Promise 对象用来封装一个异步操作并获取结果;</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>请求到达web服务器</title>
      <link href="/2021/07/10/%E8%AF%B7%E6%B1%82%E5%88%B0%E8%BE%BEweb%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
      <url>/2021/07/10/%E8%AF%B7%E6%B1%82%E5%88%B0%E8%BE%BEweb%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="浏览器请求数据包如何到达web-服务器"><a href="#浏览器请求数据包如何到达web-服务器" class="headerlink" title="浏览器请求数据包如何到达web 服务器"></a>浏览器请求数据包如何到达web 服务器</h2><h2 id="第一步激活网页上的连接"><a href="#第一步激活网页上的连接" class="headerlink" title="第一步激活网页上的连接"></a>第一步激活网页上的连接</h2><p>  用户要访问远程网络中的服务器存储的网页，用户首先要激活网页上的链接。</p><p>这里分为两种</p><ul><li>一是有缓存，或者缓存还生效。<br>如果该域名对应的IP地址已经在本地缓存，就之间访问该地址的80端口或者8080 端口</li><li>二 没有缓存，那么浏览器就会发出DNS请求给DNS服务器，获得该域名对应的IP地址。<br>获得地址后，浏览器会通过Socket首先向服务器发送 三次握手，建立起TCP 链接</li></ul><h2 id="浏览器发起HTTP请求。"><a href="#浏览器发起HTTP请求。" class="headerlink" title="浏览器发起HTTP请求。"></a>浏览器发起HTTP请求。</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>TCP</title>
      <link href="/2021/07/06/TCP/"/>
      <url>/2021/07/06/TCP/</url>
      
        <content type="html"><![CDATA[<h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><p>  只要我们知道另一位伙伴B 的 IP 地址，且之间的网络是通的，无论多远，你都可以将一个数据包发送给另外一个人<br>  <img src="/.com//02.png" alt><br>    <code>这是 物理层、数据链路层、网络层这三层所做的事情。</code><br>  站在第四层，可以利用下三层所做的铺垫，可以随心所欲的发送数据。这层是 <code>传输层</code><br>  <img src="/.com//01.gif" alt></p><p>  前三层协议只能把数据包从一个主机搬到另外一台主机，但是到了目的地以后，数据包具体交给哪个<code>程序</code>(进程)<br>  <img src="/.com//03.png" alt><br>  因此需要将通信进程区分开来，于是就给每一个进程分配一个数字编号即 <code>端口号</code>。<br>  <img src="/.com//04.jpg" alt></p><p>  发送的数据包上，增加了传输层的头部，<code>源端口号与目标端口号</code><br>  <img src="/.com//05.png" alt></p><p>  这样原本是主机与主机的通信，升级为了<code>进程和进程之间的通信</code>，<br>  使用 UDP 协议无忧无虑地同 B 进行通信，一直没有问题，但是由于网络不可靠，数据包可能在半路丢失，而 A 和 B 却无法察觉。<br>  <img src="/.com//06.gif" alt><br>  对于丢包，只要解决两个事<br>    - A 怎么知道包丢了 (让 B 告诉 A)<br>    - 丢了包怎么办 (重传)<br>  因此设计了如下方案： A 每发送一个包，都必须收到来自B 的确认(ACK),再发下一个，否则在一定时间内没有收到确认，就<code>重传</code>这个包,这个方案叫 <code>停止等待协议</code> 。按照这个方法虽然A 无法保证B y一定能收到包 但A 一定能够确认B 是否收到了包，收不到就重试，尽最大努力让这个通信过程变得可靠。<br>  <img src="/.com//02.gif" alt></p><p>  但是等待虽然能解决问题，但是效率太低了</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
