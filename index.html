<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>有理想的笛子</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="有理想的笛子">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="有理想的笛子">
<meta property="og:locale" content="zh">
<meta property="article:author" content="sxhMxd">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="有理想的笛子" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">有理想的笛子</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-TypeScript/ts" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/03/14/TypeScript/ts/" class="article-date">
  <time datetime="2022-03-14T02:57:16.897Z" itemprop="datePublished">2022-03-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/TypeScript/">TypeScript</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/03/14/TypeScript/ts/">TypeScript</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="TypeScript-是什么"><a href="#TypeScript-是什么" class="headerlink" title="TypeScript 是什么"></a>TypeScript 是什么</h2><h3 id="TS-简介"><a href="#TS-简介" class="headerlink" title="TS 简介"></a>TS 简介</h3><p> Ts是微软开发的一个开源编程语言，通过在JS的基础上添加静态类型定义构建而成。TS通过TS编译器或者Babel转译为JS代码，可运行在任何浏览器，任何操作系统。</p>
<h3 id="TS-和-JS的区别"><a href="#TS-和-JS的区别" class="headerlink" title="TS 和 JS的区别"></a>TS 和 JS的区别</h3><p> TS 是JS 的一个超集，之间没有所属关系，ts扩展了js 弱类型语言的限制，增加更多的模块解析方式和语法糖。ts 并不是一个可以独立运行的语言，大多数时候可以被转译成js 运行。 可以认为 ts 相当于功能更丰富的编译型的js。</p>
<h3 id="为什么要有TS"><a href="#为什么要有TS" class="headerlink" title="为什么要有TS"></a>为什么要有TS</h3><p>传统的js本身已经完全满足应用打开，但是在大型项目或者插件的开发场景中，js 弱类型语言的不足便暴露出来，由于js是解释型语言，在代码编译的过程中无法轻松的实现良好的类型约束和类型推断。若开发者提供了一个解释依赖包给其他开发者来使用，使用依赖的开发者并不能显示观察依赖包的内部组成。这样导致在代码阅读上无法确定该属性的明确类型，会导致代码运行上存在风险。</p>
<p>  综上所述，js在代码的可维护性上存在一些弱项，所有强类型的ts正好适用于此类型开发场景。<br>   ts 强类型的约束性及其面向接口编程的约束性可以让ts 语言开发的应用有极强的维护性，代价是更大的代码篇幅。<br>   ts适用于插件提供者，依赖库提供者，基于js的服务端项目，已经大型项目的工程化开发使用。</p>
<h2 id="TypeScript-语法"><a href="#TypeScript-语法" class="headerlink" title="TypeScript 语法"></a>TypeScript 语法</h2><h3 id="基础数据类型"><a href="#基础数据类型" class="headerlink" title="基础数据类型"></a>基础数据类型</h3><h4 id="jS的八种内置类型"><a href="#jS的八种内置类型" class="headerlink" title="jS的八种内置类型"></a>jS的八种内置类型</h4>  <figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str: <span class="built_in">string</span> = <span class="string">"111"</span>;</span><br><span class="line"><span class="keyword">let</span> num: <span class="built_in">number</span> = <span class="number">123</span>;</span><br><span class="line"><span class="keyword">let</span> bool: <span class="built_in">boolean</span> = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">let</span> u: <span class="literal">undefined</span> = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">let</span> nu: <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> obj: object = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> big: bigint = <span class="number">100n</span>;</span><br><span class="line"><span class="keyword">let</span> sym: symbol = Symbol(<span class="string">"me"</span>);</span><br></pre></td></tr></table></figure>

<h3 id="其他类型"><a href="#其他类型" class="headerlink" title="其他类型"></a>其他类型</h3><h4 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h4><ul>
<li><p>对数组类型的定义有两种方式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arrStr: string[] = [<span class="string">"1"</span>, <span class="string">"2"</span>];</span><br><span class="line"><span class="keyword">let</span> arrNum: <span class="built_in">Array</span>&lt;string&gt; = [<span class="string">"1"</span>, <span class="string">"2"</span>];</span><br></pre></td></tr></table></figure>
</li>
<li><p>定义联合类型数组</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr2: (<span class="built_in">string</span> | <span class="built_in">number</span>)[] = [<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> arr1: <span class="built_in">Array</span>&lt;<span class="built_in">string</span> | <span class="built_in">number</span>&gt; = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br></pre></td></tr></table></figure>
</li>
<li><p>定义指定对象成员的数组</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> ArrayObj &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> arrObj: ArrayObj[] = [&#123; name: <span class="string">"xxx"</span>, age: <span class="number">12</span> &#125;];</span><br><span class="line"><span class="comment">// 任意类型的数组</span></span><br><span class="line"><span class="keyword">let</span> arrAny: <span class="built_in">any</span>[] = [<span class="number">1</span>,<span class="string">'string'</span>,<span class="built_in">boolean</span>,<span class="literal">null</span>,<span class="literal">undefined</span>]</span><br><span class="line"><span class="keyword">let</span> arrAny1:<span class="built_in">Array</span>&lt;<span class="built_in">any</span>&gt; = [<span class="number">1</span>,<span class="number">2</span>,<span class="literal">true</span>,<span class="string">'string'</span>]</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><ul>
<li><p>函数声明</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>函数表达式</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> mySum: <span class="function">(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span> = <span class="function"><span class="keyword">function</span> (<span class="params">x: <span class="built_in">number</span> y:<span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>可选参数且函数有返回值</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">joinName</span>(<span class="params">firstName: <span class="built_in">string</span>, lastName?: <span class="built_in">string</span></span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> firstName + lastName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数默认值</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">names</span>(<span class="params">firstName: <span class="built_in">string</span>, lastName: <span class="built_in">string</span> = "Cat"</span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> firstName + lastName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>剩余参数</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">push</span>(<span class="params">arr: <span class="built_in">any</span>[], ...items: <span class="built_in">any</span>[]</span>) </span>&#123;</span><br><span class="line">  items.forEach(<span class="function">(<span class="params">element</span>) =&gt;</span> &#123;</span><br><span class="line">    arr.push(element);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>带参数无返回值<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">name:<span class="built_in">string</span>,age:<span class="built_in">number</span></span>):<span class="title">void</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>函数重载<br>js是一个动态语言，我们通常会使用不同类型的参数来调用同一个函数，该函数会根据不同的参数返回不同类型的调用结果;</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line">add(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">add(<span class="string">"1"</span>,<span class="string">"2"</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li><p>定义联合类型 </p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义联合类型同时为该联合类型取一个别名</span></span><br><span class="line"><span class="keyword">type</span> Combinable = <span class="built_in">string</span> | <span class="built_in">number</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用联合类型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a:Combinable,b:Combinable</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> a === <span class="string">'string'</span> || <span class="keyword">typeof</span> b === <span class="string">'string'</span>) &#123;    </span><br><span class="line">  <span class="keyword">return</span> a.toString() + b.toString();   </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Tuple-元组"><a href="#Tuple-元组" class="headerlink" title="Tuple(元组)"></a>Tuple(元组)</h3></li>
</ul>
</li>
<li><p>元组定义<br>元组是TypeSctipt 中特有的类型，其工作方式类似于数组元组最重要的特性是可以限制<code>数组元素的个数和类型</code>,特别适合用来实现多值返回。<br>元组用于保存定长定数据类型的数据。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x: [<span class="built_in">string</span>,<span class="built_in">number</span>] years</span><br><span class="line"><span class="comment">// 类型必须匹配且个数必须为2</span></span><br><span class="line">x = [<span class="string">"12"</span>,<span class="number">10</span>] <span class="comment">// ok</span></span><br><span class="line">x = [<span class="number">10</span>,<span class="number">10</span>]   <span class="comment">// error</span></span><br></pre></td></tr></table></figure></li>
<li><p>元组类型的解构赋值</p>
</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> employee:[<span class="built_in">number</span>,<span class="built_in">string</span>] = [<span class="number">1</span>,<span class="string">'string'</span>]</span><br><span class="line"><span class="keyword">let</span> [id,username] = employee</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`id:<span class="subst">$&#123;id&#125;</span>`</span>)   <span class="comment">// id:1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`username:<span class="subst">$&#123;username&#125;</span>`</span>)  <span class="comment">// username:string</span></span><br></pre></td></tr></table></figure>
<p>注意点，在解构时，如果解构数组元素的个数不能超过元组中元素的个数，否则也会出现错误。</p>
<ul>
<li>元组类型的可选元素<br>在定义元组类型时，可以通过 ? 号来声明元组类型的可选元素。<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> optionalTuple:[<span class="built_in">string</span>,<span class="built_in">boolean</span>?];</span><br><span class="line">optionalTuple = [<span class="string">'string'</span>,<span class="literal">true</span>]</span><br><span class="line">optionalTuple = [<span class="string">'string'</span>]</span><br></pre></td></tr></table></figure>
<h3 id="枚举-interFace"><a href="#枚举-interFace" class="headerlink" title="枚举 interFace"></a>枚举 interFace</h3>是一个完全抽象的对象，一个interface 可以对应多个class 对其内部的未实现方法进行实现，ts 中，interface 主要用于类型描述。</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">interface</span> User&#123;</span><br><span class="line">    name:<span class="built_in">string</span></span><br><span class="line">    age:<span class="built_in">number</span></span><br><span class="line">    sex:<span class="built_in">string</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> obj:User =&#123;</span><br><span class="line">    name:<span class="built_in">string</span></span><br><span class="line">    age:<span class="built_in">number</span></span><br><span class="line">    sex:<span class="built_in">string</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//是强约束 约定该对象必须包含name,age,sex 这几个属性，不能有其他对象</span></span><br><span class="line">  <span class="keyword">interface</span> Us&#123;</span><br><span class="line">    readonly name:<span class="built_in">string</span>,  <span class="comment">// 表示该属性只读，不可以修改</span></span><br><span class="line">    age:<span class="built_in">number</span>,</span><br><span class="line">    [props:<span class="built_in">string</span>]:<span class="built_in">any</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 可以有约定以外的其他属性</span></span><br><span class="line">  <span class="keyword">interface</span> Func&#123;</span><br><span class="line">    (name):<span class="built_in">string</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 定义函数的接口</span></span><br><span class="line">  <span class="keyword">let</span> fun:Func = <span class="function"><span class="keyword">function</span>(<span class="params">name:<span class="built_in">string</span></span>):<span class="title">string</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">interface</span> User &#123;</span><br><span class="line">    name:<span class="built_in">string</span>,</span><br><span class="line">    age:<span class="built_in">number</span>,</span><br><span class="line">    sex:<span class="built_in">string</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">interface</span> Admin&#123;</span><br><span class="line">    name:<span class="built_in">string</span>,</span><br><span class="line">    age:<span class="built_in">number</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">type</span> Person = User | Admin</span><br><span class="line">  <span class="keyword">let</span> userobj =  <span class="built_in">Array</span>&lt;Person&gt; = [</span><br><span class="line">    &#123;name:<span class="string">''</span>,age:<span class="string">''</span>,sex:<span class="string">''</span>&#125;,</span><br><span class="line">    &#123;name:<span class="string">""</span>,age:<span class="string">""</span>&#125;</span><br><span class="line">  ]</span><br><span class="line"></span><br><span class="line"><span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string">### 泛型</span></span><br><span class="line"><span class="string"> 泛型是静态类型语言的另一灵魂工具，这里体现于静态类型的语言在定义类型时必须明确类型而造成的问题。</span></span><br><span class="line"><span class="string"> 当函数的参数和返回类型明确时，相同结构的函数需要根据不同的类型定义多个，这种情况很容易将代码的复杂度提高降低可维护性</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span> ts</span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">test</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg:T</span>):<span class="title">T</span></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> arg</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="类型推断"><a href="#类型推断" class="headerlink" title="类型推断"></a>类型推断</h3><p>在很多情况下，Typescript会根据上下文环境自动推断出变量的类型，无需我们再写明类型注解。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">'ss'</span></span><br><span class="line"><span class="keyword">let</span> num = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> bool = <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>我们把TypeScript 这种基于赋值表达式推断类型的能力称之为 <code>类型推断</code></p>
<h3 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h3><p>  有时候会遇到这样的情况，你会比ts 更了解某个值的详细信息通常这会发生在你清楚的知道一个实体具有比它现有类型更确切的类型。<br>  通过类型断言这种方式告诉编辑器 ，”相信我，我知道自己在干什么”。类型断言好比其他语言里的类型转换，但是不进行特殊的数据检查和解构。它没有运行时的影响，只是在编译阶段起作用。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 尖括号语法</span></span><br><span class="line"><span class="keyword">let</span> someValue:<span class="built_in">any</span> = <span class="string">'this is a string'</span></span><br><span class="line"><span class="keyword">let</span> strLength:<span class="built_in">number</span> = (&lt;<span class="built_in">string</span>&gt;someValue).length</span><br><span class="line"><span class="comment">// as 语法</span></span><br><span class="line"><span class="keyword">let</span> someValue:<span class="built_in">any</span> = <span class="string">'this is a string'</span></span><br><span class="line"><span class="keyword">let</span> strLength:<span class="built_in">number</span> = (someValue <span class="keyword">as</span> <span class="built_in">string</span>).length</span><br></pre></td></tr></table></figure>
<h3 id="非空断言"><a href="#非空断言" class="headerlink" title="非空断言"></a>非空断言</h3><p>  在上下文中当类型检查器无法判定类型时，一个新的后缀表达式操作符! 可以用于断言操作对象是非 null 和undefined 类型，<code>x! 将从x值域中排除 null 和undefined</code><br>  <figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> value:<span class="literal">null</span> | <span class="literal">undefined</span> | <span class="built_in">string</span> </span><br><span class="line">value!.toString() </span><br><span class="line">value.toString()  <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure></p>
<h3 id="确定赋值断言"><a href="#确定赋值断言" class="headerlink" title="确定赋值断言"></a>确定赋值断言</h3><p>  允许实例属性和变量声明后面放置一个! 号，从而告诉 ts 该属性会被明确地赋值。<br>  <figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x: <span class="built_in">number</span>;</span><br><span class="line">initialize();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Variable 'x' is used before being assigned.(2454)</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span> * x); <span class="comment">// Error</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initialize</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">  x = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用确定赋值断言</span></span><br><span class="line"><span class="keyword">let</span> x!:<span class="built_in">number</span></span><br><span class="line">initialize()</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>*x)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initialize</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  x=<span class="number">10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>  通过 <code>let x!:number</code> 确定赋值类型断言，ts编辑器就会知道该属性会被明确地赋值。</p>
<h3 id="字面量类型"><a href="#字面量类型" class="headerlink" title="字面量类型"></a>字面量类型</h3><p>  在ts 中字面量不仅可以表示值，还可以表示类型，即所谓的字面量类型。目前ts支持三种字面量类型：<code>字符串字面量类型、数字字面量类型、布尔字面量类型</code>。<br>  <figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str: <span class="string">'1'</span> =<span class="string">'string'</span></span><br><span class="line"><span class="keyword">let</span> num: <span class="number">1</span> = <span class="number">124</span></span><br><span class="line"><span class="keyword">let</span> bool: <span class="literal">true</span> = <span class="literal">false</span></span><br></pre></td></tr></table></figure></p>
<h3 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h3><p>  联合类型表示取值可以为多种类型中的一种，使用 | 分割每个类型</p>
  <figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> strNum: <span class="built_in">string</span> | <span class="built_in">number</span> </span><br><span class="line">strNum = <span class="string">'ss'</span></span><br><span class="line">strNum = <span class="number">123</span></span><br></pre></td></tr></table></figure>
<h3 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h3><p>  类型别名用来给一个类型起一个新名字。类型别名常用于联合类型</p>
  <figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Message = <span class="built_in">string</span> | <span class="built_in">string</span>[]</span><br></pre></td></tr></table></figure>
<p>  注意：类型别名是给类型起一个新的名字，并不是创建一个新的类型。</p>
<h3 id="交叉类型"><a href="#交叉类型" class="headerlink" title="交叉类型"></a>交叉类型</h3><p>  交叉类型是将多个类型合并为一个类型。我们可以把现有的多种类型叠加到一起成为一种类型，它包含了所需的所有类型的特性，使用<code>&amp;</code> 定义交叉类型。<br>  如果我们仅仅是把原始类型，字面量类型，函数类型等原始类型合并成为交叉类型是没有任何用处的。它的用处是将多个接口类型合并成一个类型，从而实现等同接口继承的效果，也就是所谓的合并接口类型。<br>  <figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span>  IntersectionType = &#123;id:<span class="built_in">number</span>,name:<span class="built_in">string</span>&#125;&amp;&#123;age:<span class="built_in">number</span>&#125;</span><br><span class="line"><span class="keyword">const</span> user:IntersectonType = &#123;</span><br><span class="line">  id:<span class="number">1</span>,</span><br><span class="line">  name:<span class="string">'name'</span>,</span><br><span class="line">  age:<span class="number">18</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>  上面例子，我们通过交叉类型，使得IntersectionType 同时拥有了id name age 所有属性，这里我们可以试着将合并接口类型理解为求并集。</p>
<h2 id="object-Object-和"><a href="#object-Object-和" class="headerlink" title="object Object 和 {}"></a>object Object 和 {}</h2><p>小 <code>object</code> 代表的是所有非原始类型，也就是我们不能把 <code>number string boolean</code> 等原始类型赋值给<code>object</code> 。在严格模式下 <code>null</code> 和<code>undefined</code> 类型也不能赋给 <code>object</code></p>
<p>大 <code>Object</code> 代表所有拥有 <code>toString hasOwnProperty</code> 方法的类型，所以所有原始类型、非原始类型都可以赋给 <code>Object</code>。 在严格模式下 <code>null</code> 和<code>undefined</code> 类型也不能赋给 <code>object</code><br>  大 Object 保护你原始类型，小object 仅包含非原始类型，所以大Object 似乎是小 object的父类型。实际上， 大Object 不仅是 小object的父类型，同时也是小object的子类型。<br>  注意点：尽管官方文档说可以使用小object代替 大Object，但是我们仍要明白大Object 并不完全等于小object。</p>
<p><code>{}</code> 空对象类型和大Object一样，也是表示原始类型和非原始类型的集合，并且在严格模式下，<code>null</code> 和 <code>undefined</code> 也不能赋给 <code>{}</code><br><code>综上结论：{}、大 Object 是比小 object 更宽泛的类型（least specific），{} 和大 Object 可以互相代替，用来表示原始类型（null、undefined 除外）和非原始类型；而小 object 则表示非原始类型。</code></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2022/03/14/TypeScript/ts/" data-id="cl139u3ku001tswdx3frig4ro" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-webpack/webpack" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/02/22/webpack/webpack/" class="article-date">
  <time datetime="2022-02-22T08:16:44.901Z" itemprop="datePublished">2022-02-22</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/webpack/">webpack</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/02/22/webpack/webpack/">webpack</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id><a href="#" class="headerlink" title></a></h3>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2022/02/22/webpack/webpack/" data-id="cl139u3la0025swdx3usa28j9" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-正则/正则知识点" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/12/25/%E6%AD%A3%E5%88%99/%E6%AD%A3%E5%88%99%E7%9F%A5%E8%AF%86%E7%82%B9/" class="article-date">
  <time datetime="2021-12-25T08:02:43.537Z" itemprop="datePublished">2021-12-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/">正则表达式</a>►<a class="article-category-link" href="/categories/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/%E6%AD%A3%E5%88%99%E7%9F%A5%E8%AF%86%E7%82%B9/">正则知识点</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/12/25/%E6%AD%A3%E5%88%99/%E6%AD%A3%E5%88%99%E7%9F%A5%E8%AF%86%E7%82%B9/">正则知识点,</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="正则表达式字符匹配"><a href="#正则表达式字符匹配" class="headerlink" title="正则表达式字符匹配"></a>正则表达式字符匹配</h2><p>正则表达式是匹配模式，要么匹配字符，要么匹配位置。</p>
<h3 id="两种模糊匹配"><a href="#两种模糊匹配" class="headerlink" title="两种模糊匹配"></a>两种模糊匹配</h3><p>  如果正则只有精确匹配是没有多大意义的。正则之所以强大是因为其能实现模糊匹配。<br>  而模糊匹配有两个方向上的模糊：横向模糊和纵向模糊。</p>
<h4 id="横向模糊匹配"><a href="#横向模糊匹配" class="headerlink" title="横向模糊匹配"></a>横向模糊匹配</h4><p>  横向模糊匹配指的是，一个正则可以匹配的字符串的长度是不固定的，可以是多种情况的。<br>  其实现方式是使用量词。例如{m,n}，表示连续出现最少m次，最多n次。<br>  eg: /ab{2,5}c/ 表示匹配这样一个字符串：第一个字符是 ‘a’，接下来是2到5个字符串’b’，最后一个字符串’c’。<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var reg &#x3D; &#x2F;ab&#123;2,5&#125;c&#x2F;g</span><br><span class="line">var string &#x3D; &#39;abc abbc abbbc abbbbc&#39;</span><br><span class="line">string.match(reg)</span><br><span class="line"> &#x2F;&#x2F; [&#39;abbc&#39;,&#39;abbbc&#39;,&#39;abbbbc&#39;]</span><br></pre></td></tr></table></figure><br>   案例中使用的正则后面多了一个g，是正则的修饰符，表示全局匹配，即在目标字符串中按顺序找到满足匹配模式的所有字串，强调的是’所有’，而不只是’第一个’。</p>
<h4 id="纵向模糊匹配"><a href="#纵向模糊匹配" class="headerlink" title="纵向模糊匹配"></a>纵向模糊匹配</h4><p>  纵向模糊匹配指的是，一个正则匹配的字符串，具体到某一个字符时，它可以不是某个确定的字符，可以有很多种可能。<br>  其实现方式是使用字符组。例如[abc]，表示该字符可以是字符’a’、’b’、’c’种任何一个。<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var reg &#x3D; &#x2F;a[123]c&#x2F;g</span><br><span class="line">var string &#x3D; &#39;a0c a1c a2c a3c a4c&#39;</span><br><span class="line">string.match(reg)</span><br><span class="line">&#x2F;&#x2F; [&#39;a1c&#39;,&#39;a2c&#39;,&#39;a3c&#39;]</span><br></pre></td></tr></table></figure></p>
<h3 id="字符组"><a href="#字符组" class="headerlink" title="字符组"></a>字符组</h3><p>  虽然是叫字符组，胆汁酸其中一个字符。</p>
<ul>
<li>范围表示法<br>用连字符 - 来省略和简写<br>eg [123456789]  =&gt; [1-9]</li>
<li>排除字符组<br>用 [^] 来表示除了里面的字符。<br>  eg:[^abc] 表示除了’a’、’b’、’c’之外的任意一个字符。</li>
<li>常见的简写形式。<ul>
<li>\d 就是 [0-9]。表示是一位数字。</li>
<li>\D 就是 [^0-9]。表示除数字以外的任意字符。</li>
<li>\w 就是 [0-9a-zA-Z_]。表示数字、大小写字母和下划线。</li>
<li>\W 就是 [^0-9a-zA-Z_]。 非单词字符。</li>
<li>\s 就是 [\t\v\n\r\f]。表示空白字符，包括空格、水平制表符、垂直制表符、换行符、回车符、换页符。</li>
<li>\S 就是 [^\t\v\n\r\f]。非空白符。</li>
<li>.  就是 [^\n\r\u2028\u2029]。 通配符，表示几乎任意字符。换行符、回车符、行分符和段分割符除外。  </li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2021/12/25/%E6%AD%A3%E5%88%99/%E6%AD%A3%E5%88%99%E7%9F%A5%E8%AF%86%E7%82%B9/" data-id="cl139u3ld0029swdxd6ecaf90" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-es6/Symbol" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/11/26/es6/Symbol/" class="article-date">
  <time datetime="2021-11-26T02:27:52.179Z" itemprop="datePublished">2021-11-26</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/es6/">es6</a>►<a class="article-category-link" href="/categories/es6/Symbol/">Symbol</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/11/26/es6/Symbol/">Symbol,</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h2><p>  对象的属性名都是字符串，容易造成属性名冲突。ES6 引入一种新的原始数据类型 Symbol，表示独一无二的值。<br>  Symbol 值通过 Symobl 函数生成。凡是属性名属于 Symbol 类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let s &#x3D; Symbol()</span><br><span class="line">  typeof s </span><br><span class="line">    &#x2F;&#x2F; &#39;symbol&#39;</span><br></pre></td></tr></table></figure>
<p>  <code>Symbol</code> 函数不能使用 new 命令，否则会报错，new 命令生成的是一个对象，Symbol 值不是对象，是类似字符串的数据类型。</p>
<ul>
<li>js 原始类型数据，除了 <code>null, undefined 和 symbol</code>外，其他类型的数据 都可以通过 new 命令初始化值，该命令返回的是一个 typeof 类型为 object的值。</li>
<li>Symbol 函数可以接收一个字符串作为参数，表示Symbol 实例的描述，主要是为了区分生成的变量。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let s1 &#x3D; Symbol(&#39;foo&#39;)</span><br><span class="line">  &#x2F;&#x2F; Symbol(foo)</span><br><span class="line">let s2 &#x3D; Symbol(&#39;bar&#39;)</span><br><span class="line">  &#x2F;&#x2F; Symbol(bar)</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li><p>注意点 Symbol 值不能与其他类型的值进行运算，会报错。但是，Symbol 的值可以转换为字符串。Symbol的值可以转换为布尔值，但是不能转换为数值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var sy &#x3D; Symbol(&#39;mySymbol&#39;)</span><br><span class="line">  &#39;Your symbol is&#39; + sy</span><br><span class="line">  &#96;your symbol is $&#123;sy&#125;&#96;</span><br><span class="line">String(sy)</span><br><span class="line">  &#x2F;&#x2F; &#39;Symbol(mySymbol)&#39;</span><br><span class="line">sy.toStirng()</span><br><span class="line">  &#x2F;&#x2F; &#39;Symbol(mySymbol)&#39;</span><br><span class="line">Boolean(sy)</span><br><span class="line">  &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>
<h3 id="作为属性名"><a href="#作为属性名" class="headerlink" title="作为属性名"></a>作为属性名</h3><p>Symbol值都不相等的，用于对象的属性名，就能保证不会出现同名的属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var sym &#x3D; Symbol()</span><br><span class="line">&#x2F;&#x2F; 第一种写法</span><br><span class="line">  var a &#x3D; &#123;&#125;</span><br><span class="line">  a[sym] &#x3D; &#39;Hello&#39;</span><br><span class="line">&#x2F;&#x2F; 第二种写法</span><br><span class="line">  var a &#x3D; &#123;</span><br><span class="line">    [sym]: &#39;Hello&#39; </span><br><span class="line">  &#125;</span><br><span class="line">&#x2F;&#x2F; 第三种写法 </span><br><span class="line">  var a &#x3D; &#123;&#125;</span><br><span class="line">  Object.defineProperty(a,sym,&#123;value:&#39;Hello&#39;&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>注意点：Symbol 值作为对象的属性名的时候，不能通过 点运算赋值，如果是通过点运算赋的值，是和原来的为对象添加属性一样。因为点运算符后面总是字符串，所以不会读取 mySymbol 作为标识所指代的那个值，导致a的属性名实际上是一个字符串，而不是一个Symbol 值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var mySymbol &#x3D; Symbol()</span><br><span class="line">var a &#x3D; &#123;&#125;</span><br><span class="line">a.mySymbol &#x3D; &#39;Hello&#39;</span><br><span class="line">a[mySymbol] </span><br><span class="line">  &#x2F;&#x2F; undefined</span><br><span class="line">a[&#39;mySymbol&#39;]</span><br><span class="line">  &#x2F;&#x2F; Hello</span><br></pre></td></tr></table></figure>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2021/11/26/es6/Symbol/" data-id="cl139u3l1001wswdxg0bcf0v3" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-es6/新增运算符" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/11/25/es6/%E6%96%B0%E5%A2%9E%E8%BF%90%E7%AE%97%E7%AC%A6/" class="article-date">
  <time datetime="2021-11-25T05:43:07.420Z" itemprop="datePublished">2021-11-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/es6/">es6</a>►<a class="article-category-link" href="/categories/es6/%E8%BF%90%E7%AE%97%E7%AC%A6%E6%89%A9%E5%B1%95/">运算符扩展</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/11/25/es6/%E6%96%B0%E5%A2%9E%E8%BF%90%E7%AE%97%E7%AC%A6/">运算符的扩展,</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="指数运算符"><a href="#指数运算符" class="headerlink" title="指数运算符"></a>指数运算符</h2><p>新增了一个指数运算符(**)</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2**2  &#x2F;&#x2F; 4 </span><br><span class="line">  2*2</span><br><span class="line">2**3  &#x2F;&#x2F; 8</span><br><span class="line">  2*2*2</span><br></pre></td></tr></table></figure>
<ul>
<li><p>指数运算符可以与等号结合，形成一个新的赋值运算符(**=)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let a &#x3D; 1.5 </span><br><span class="line">a** &#x3D; 2</span><br><span class="line">  &#x2F;&#x2F; 等同于 a &#x3D; a * a </span><br><span class="line">let b &#x3D; 4 </span><br><span class="line">b** &#x3D; 3</span><br><span class="line">  &#x2F;&#x2F; 等同于 b &#x3D; b * b * b</span><br></pre></td></tr></table></figure>
<h2 id="链判断运算符"><a href="#链判断运算符" class="headerlink" title="链判断运算符"></a>链判断运算符</h2><p>编程中，如果要读取对象内部的某个属性，往往需要判断一下，属性的上层对象是否存在。对象嵌套太深，判断会需要很多层，这样很是麻烦。<br>ES2020引入了 <code>链判断运算符</code> <code>?.</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 之前写法</span><br><span class="line"> var firstName &#x3D; obj &amp;&amp; obj.a &amp;&amp; obj.a.b &amp;&amp; obj.a.b.c || &#39;default&#39;</span><br><span class="line"> var fooVlaue &#x3D; fooInput ? fooInput.value : undefined</span><br><span class="line"> &#x2F;&#x2F; 现在写法</span><br><span class="line"> var firstName &#x3D; obj?.a?.b?.c</span><br><span class="line"> var fooVlaue &#x3D; fooInput?.value</span><br><span class="line">   &#x2F;&#x2F; 直接链式调用的时候判断，左侧的对象是否为 null 或 undefined。如果是的，就不再往下运算直接返回 null 或者 undefined 。</span><br><span class="line"> iterator.return?.()</span><br><span class="line">   &#x2F;&#x2F; iterator.return如果有定义，就会调用该方法，否则 iterator.return直接返回undefined，不在执行后面的部分。</span><br></pre></td></tr></table></figure>
<ul>
<li>使用 链式判断运算符的注意点<ul>
<li>短路机制<br>本质上?.运算符相当于一种短路机制，只要不满足条件，就不再往下执行。</li>
<li>括号的影响<br>如果属性链有圆括号，链判断运算符对圆括号外部没有影响，只对圆括号内部有影响。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(a?.b).c</span><br><span class="line">&#x2F;&#x2F; 等价于 (a &#x3D;&#x3D; null ? undefined : a.b).c</span><br><span class="line">不管对象a 是否存在，圆括号后面的.c 总是会执行。</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Null-判断运算符"><a href="#Null-判断运算符" class="headerlink" title="Null 判断运算符"></a>Null 判断运算符</h2><p>  在读取对象属性的时候，如果某个属性的值是null 或者 undefined，有时候需要为他们指定默认值，常用的方法是 || ，但是这样写是错误的，我们的意愿是当为null 或者undefined 的时候给定默认值，但是 当值为 空字符串，false 0 的时候默认值也会生效<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var param &#x3D; null&#x2F;undefined</span><br><span class="line">var result &#x3D; param || &#39;default&#39;</span><br><span class="line">  result   &#x2F;&#x2F;&#39;default&#39;</span><br><span class="line"></span><br><span class="line">var param2 &#x3D;  false&#x2F;0</span><br><span class="line">var result2 &#x3D; param || &#39;default&#39;</span><br><span class="line">  result2  &#x2F;&#x2F;&#39;default&#39;</span><br></pre></td></tr></table></figure><br>  为了避免上面的情况 ES2020 引入一个新的Null 运算符 <code>??</code>。它的行为类似 || ,但是只有运算符左侧的值为 null 或 undefined时，才会返回右侧的值。<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var param &#x3D; null&#x2F;undefined</span><br><span class="line">var result &#x3D; param ?? &#39;default&#39;</span><br><span class="line">  result   &#x2F;&#x2F;&#39;default&#39;</span><br><span class="line"></span><br><span class="line">var param2 &#x3D;  false&#x2F;0</span><br><span class="line">var result2 &#x3D; param ?? &#39;default&#39;</span><br><span class="line">  result2  &#x2F;&#x2F; false&#x2F;0</span><br></pre></td></tr></table></figure><br>  该运算符的一个目的就是跟链判断运算符?.配合使用，为null 或 undefined 的值设置默认值。<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var result &#x3D; obj?.a ?? true</span><br></pre></td></tr></table></figure></p>
<h2 id="逻辑赋值运算符"><a href="#逻辑赋值运算符" class="headerlink" title="逻辑赋值运算符"></a>逻辑赋值运算符</h2><p>ES2021 引入了三个新的逻辑赋值运算符，将逻辑运算符与赋值运算符结合。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> &#x2F;&#x2F; 或赋值运算符</span><br><span class="line"> x||&#x3D;y</span><br><span class="line">   &#x2F;&#x2F; 等同于</span><br><span class="line">     x || (x &#x3D; y)</span><br><span class="line"> &#x2F;&#x2F; 与赋值运算符</span><br><span class="line"> x &amp;&amp;&#x3D; y </span><br><span class="line">   &#x2F;&#x2F; 等同于</span><br><span class="line">     x &amp;&amp; (x &#x3D; y)</span><br><span class="line"> x ??&#x3D; y </span><br><span class="line">   &#x2F;&#x2F; 先判断x 是否是 null&#x2F;undefined 是的话 执行 x &#x3D; y  </span><br><span class="line">var x &#x3D; 1</span><br><span class="line">var y &#x3D; &#39;&#39;</span><br><span class="line"> x ||&#x3D; y </span><br><span class="line">   &#x2F;&#x2F; 1</span><br><span class="line"> x &amp;&amp;&#x3D; y </span><br><span class="line">   &#x2F;&#x2F; &#39;&#39;</span><br><span class="line"> x ??&#x3D; y </span><br><span class="line">   &#x2F;&#x2F; 1</span><br></pre></td></tr></table></figure>
<p>  他们的用途是，为变量或属性设置默认值<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 老的写法</span><br><span class="line">user.id &#x3D; user.id || 1</span><br><span class="line">&#x2F;&#x2F; 新写法</span><br><span class="line">user.id ||&#x3D; 1</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2021/11/25/es6/%E6%96%B0%E5%A2%9E%E8%BF%90%E7%AE%97%E7%AC%A6/" data-id="cl139u3l3001xswdxerxf13q4" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-async,await" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/10/29/async,await/" class="article-date">
  <time datetime="2021-10-29T02:44:38.448Z" itemprop="datePublished">2021-10-29</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/async-await/">async await</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/10/29/async,await/">async await,</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="async"><a href="#async" class="headerlink" title="async"></a>async</h2><p><code>异步编程的最高境界，就是根本不用关心它是不是异步</code></p>
<p><code>async 函数是 Generator 函数的语法糖</code></p>
<p>async 是一个修饰符，async定义的函数会默认返回一个Promise对象resolve的值，因此对async函数可以直接进行then操作，返回的值即为then方法的传入函数</p>
<p>async 函数(包含函数语句，函数表达式，Lambda表达式) 会返回一个Promise 对象，如果在函数中直接返回一个直接量，async 会把这个直接量通过 Promise.resolve() 封装成Promise对象</p>
<h2 id="await"><a href="#await" class="headerlink" title="await"></a>await</h2><p>一般来说，await 是在等待一个async 函数完成。await 等待的是一个表达式，这个表达式的计算结果是 Promise 对象或者其它值（换句话说，就是没有特殊限定）。</p>
<p>async 函数返回的是一个Promise 对象，所以await 可以用于等待一个async 函数的返回值，它等待的实际是一个返回值，await不仅仅用于等待Promise对象它可以等待任意表达式的结果。即await后面是可以接普通函数或者直接量的。</p>
<ul>
<li>awit 等到了要等东西，<ul>
<li>如果等到的是一个promise对象，await会阻塞后面的代码，等着Promise对象resolve ,然后得到resolve的值，作为await表达式的运算结果。</li>
<li>如果不是promise 对象，那await表达式的运算结果就是它等到的东西。</li>
<li>await 等待的不是一个Promise 对象的时候，相当于 await Promise.resolve</li>
</ul>
</li>
</ul>
<h2 id="async-await-的优势"><a href="#async-await-的优势" class="headerlink" title="async await 的优势"></a>async await 的优势</h2><p>优势在于处理then 链</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2021/10/29/async,await/" data-id="cl139u3en0002swdxg50l0ci8" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-项目中用到的js方法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/09/01/%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%94%A8%E5%88%B0%E7%9A%84js%E6%96%B9%E6%B3%95/" class="article-date">
  <time datetime="2021-09-01T03:24:53.467Z" itemprop="datePublished">2021-09-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84js%E6%93%8D%E4%BD%9C/">项目中常用的js操作</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/09/01/%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%94%A8%E5%88%B0%E7%9A%84js%E6%96%B9%E6%B3%95/">项目中常用的js操作,</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="创建tag标签"><a href="#创建tag标签" class="headerlink" title="创建tag标签"></a>创建tag标签</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 创建 script 标签 绑定id 创建新的script 时对比删除之前的。</span><br><span class="line">  function  createScipt(str, id) &#123;</span><br><span class="line">      let getId &#x3D; document.getElementById(id);</span><br><span class="line">      getId ? getId.parentNode.removeChild(getId) : &quot;&quot;;</span><br><span class="line">      let head &#x3D; document.getElementsByTagName(&quot;head&quot;)[0];</span><br><span class="line">      var script &#x3D; document.createElement(&quot;script&quot;);</span><br><span class="line">      script.type &#x3D; &quot;text&#x2F;javascript&quot;;</span><br><span class="line">      script.text &#x3D; str;</span><br><span class="line">      script.id &#x3D; id;</span><br><span class="line">      head.appendChild(script);</span><br><span class="line">      &#x2F;&#x2F; document.getElementsByTagName(&quot;head&quot;)[0].appendChild(script);</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2021/09/01/%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%94%A8%E5%88%B0%E7%9A%84js%E6%96%B9%E6%B3%95/" data-id="cl139u3jn000zswdxaeege1xq" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-正则表达式" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/08/20/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" class="article-date">
  <time datetime="2021-08-20T04:00:37.843Z" itemprop="datePublished">2021-08-20</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/">正则表达式</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/08/20/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/">正则表达式,</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="匹配小括号里面的内容"><a href="#匹配小括号里面的内容" class="headerlink" title="匹配小括号里面的内容"></a>匹配小括号里面的内容</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let reg &#x3D;  &#x2F;[^(][a-zA-Z0-9]+(?&#x3D;\))&#x2F;g</span><br><span class="line">let str &#x3D; &quot;(9001)(9002)(9003)&quot;</span><br><span class="line">str.match(reg)</span><br><span class="line"> &#x2F;&#x2F; [&#39;9001&#39;,&#39;9002&#39;,&#39;9003&#39;]</span><br></pre></td></tr></table></figure>
<h3 id="将中括号替换为点"><a href="#将中括号替换为点" class="headerlink" title="将中括号替换为点"></a>将中括号替换为点</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let str &#x3D; &#39;a[12][334]&#39;</span><br><span class="line">&#x2F;&#x2F; 方法一</span><br><span class="line">  str.replace(&#x2F;\[&#x2F;g, &quot;.&quot;).replace(&#x2F;\]&#x2F;g, &quot;&quot;);</span><br><span class="line">    &#x2F;&#x2F; a.12.334</span><br><span class="line">&#x2F;&#x2F; 方法二</span><br><span class="line">  str.replace(&#x2F;\[([^\[\]]*)\]&#x2F;g, &quot;.$1&quot;);</span><br><span class="line">    &#x2F;&#x2F; a.12.334</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2021/08/20/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" data-id="cl139u3jg000rswdx84nvh8x3" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-请求到达web服务器" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/07/10/%E8%AF%B7%E6%B1%82%E5%88%B0%E8%BE%BEweb%E6%9C%8D%E5%8A%A1%E5%99%A8/" class="article-date">
  <time datetime="2021-07-10T02:37:11.000Z" itemprop="datePublished">2021-07-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/07/10/%E8%AF%B7%E6%B1%82%E5%88%B0%E8%BE%BEweb%E6%9C%8D%E5%8A%A1%E5%99%A8/">请求到达web服务器</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="浏览器请求数据包如何到达web-服务器"><a href="#浏览器请求数据包如何到达web-服务器" class="headerlink" title="浏览器请求数据包如何到达web 服务器"></a>浏览器请求数据包如何到达web 服务器</h2><h2 id="第一步激活网页上的连接"><a href="#第一步激活网页上的连接" class="headerlink" title="第一步激活网页上的连接"></a>第一步激活网页上的连接</h2><p>  用户要访问远程网络中的服务器存储的网页，用户首先要激活网页上的链接。</p>
<p>这里分为两种</p>
<ul>
<li>一是有缓存，或者缓存还生效。<br>如果该域名对应的IP地址已经在本地缓存，就之间访问该地址的80端口或者8080 端口</li>
<li>二 没有缓存，那么浏览器就会发出DNS请求给DNS服务器，获得该域名对应的IP地址。<br>获得地址后，浏览器会通过Socket首先向服务器发送 三次握手，建立起TCP 链接</li>
</ul>
<h2 id="浏览器发起HTTP请求。"><a href="#浏览器发起HTTP请求。" class="headerlink" title="浏览器发起HTTP请求。"></a>浏览器发起HTTP请求。</h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2021/07/10/%E8%AF%B7%E6%B1%82%E5%88%B0%E8%BE%BEweb%E6%9C%8D%E5%8A%A1%E5%99%A8/" data-id="cl139u3jk000wswdx4oirceyg" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-TCP" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/07/06/TCP/" class="article-date">
  <time datetime="2021-07-06T02:47:04.000Z" itemprop="datePublished">2021-07-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/07/06/TCP/">TCP</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><p>  只要我们知道另一位伙伴B 的 IP 地址，且之间的网络是通的，无论多远，你都可以将一个数据包发送给另外一个人<br>  <img src="/2021/07/06/TCP/02.png" alt><br>    <code>这是 物理层、数据链路层、网络层这三层所做的事情。</code><br>  站在第四层，可以利用下三层所做的铺垫，可以随心所欲的发送数据。这层是 <code>传输层</code><br>  <img src="/2021/07/06/TCP/01.gif" alt></p>
<p>  前三层协议只能把数据包从一个主机搬到另外一台主机，但是到了目的地以后，数据包具体交给哪个<code>程序</code>(进程)<br>  <img src="/2021/07/06/TCP/03.png" alt><br>  因此需要将通信进程区分开来，于是就给每一个进程分配一个数字编号即 <code>端口号</code>。<br>  <img src="/2021/07/06/TCP/04.jpg" alt></p>
<p>  发送的数据包上，增加了传输层的头部，<code>源端口号与目标端口号</code><br>  <img src="/2021/07/06/TCP/05.png" alt></p>
<p>  这样原本是主机与主机的通信，升级为了<code>进程和进程之间的通信</code>，<br>  使用 UDP 协议无忧无虑地同 B 进行通信，一直没有问题，但是由于网络不可靠，数据包可能在半路丢失，而 A 和 B 却无法察觉。<br>  <img src="/2021/07/06/TCP/06.gif" alt><br>  对于丢包，只要解决两个事<br>    - A 怎么知道包丢了 (让 B 告诉 A)<br>    - 丢了包怎么办 (重传)<br>  因此设计了如下方案： A 每发送一个包，都必须收到来自B 的确认(ACK),再发下一个，否则在一定时间内没有收到确认，就<code>重传</code>这个包,这个方案叫 <code>停止等待协议</code> 。按照这个方法虽然A 无法保证B y一定能收到包 但A 一定能够确认B 是否收到了包，收不到就重试，尽最大努力让这个通信过程变得可靠。<br>  <img src="/2021/07/06/TCP/02.gif" alt></p>
<p>  但是等待虽然能解决问题，但是效率太低了</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2021/07/06/TCP/" data-id="cl139u3fb0006swdxdmem1q5m" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/JavaScript-%E9%AB%98%E7%BA%A7/">JavaScript 高级</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/TypeScript/">TypeScript</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Vue-js/">Vue.js</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Vue-js/Props%E4%B8%8EData%E7%9A%84%E5%8C%BA%E5%88%AB/">Props与Data的区别</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Vue-js-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/">Vue.js 源码解读</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Vue-js-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E5%8F%98%E5%8C%96%E4%BE%A6%E6%B5%8B/">变化侦测</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Vue-js-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E5%8F%98%E5%8C%96%E4%BE%A6%E6%B5%8B/%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8F%98%E5%8C%96%E4%BE%A6%E5%90%AC/">数据的变化侦听</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Vue-js-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E5%90%8D%E8%AF%8D/">名词</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Vue-js-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E6%A8%A1%E6%9D%BF%E7%BC%96%E8%AF%91/">模板编译</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Vue-js-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/">生命周期</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Vue-js-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/%E5%88%9D%E5%A7%8B%E5%8C%96-initState-%E9%98%B6%E6%AE%B5/">初始化 initState 阶段</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Vue-js-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E8%99%9A%E6%8B%9FDOM/">虚拟DOM</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Vue-js-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E8%99%9A%E6%8B%9FDOM/Diff/">Diff</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Vue-js-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E8%99%9A%E6%8B%9FDOM/Vue%E4%B8%AD%E7%9A%84%E8%99%9A%E6%8B%9FDom/">Vue中的虚拟Dom</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Vue-js-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E8%99%9A%E6%8B%9FDOM/%E6%9B%B4%E6%96%B0%E5%AD%90%E8%8A%82%E7%82%B9/">更新子节点</a></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/async-await/">async await</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/elementUI%E5%A5%87%E6%80%AA%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/">elementUI奇怪问题解决办法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/element%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/">element使用不常用方法总结</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/es6/">es6</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/es6/Symbol/">Symbol</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/es6/%E8%BF%90%E7%AE%97%E7%AC%A6%E6%89%A9%E5%B1%95/">运算符扩展</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/import-%E5%92%8C-export/">import 和 export</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/js%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/">js知识体系</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/js%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/js-%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/">js 代码执行过程分析</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/js%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/js-%E8%AF%AD%E8%A8%80%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7/">js 语言的三大特性</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/js%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/%E4%BA%8B%E4%BB%B6/">事件</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/js%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/%E6%95%B0%E6%8D%AE/">数据</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/webpack/">webpack</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/">正则表达式</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/%E6%AD%A3%E5%88%99%E7%9F%A5%E8%AF%86%E7%82%B9/">正则知识点</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E6%B6%89%E5%8F%8A%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9/">浏览器渲染涉及的知识点</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%99%BB%E5%BD%95%E8%AE%A4%E8%AF%81%E7%9F%A5%E8%AF%86/">登录认证知识</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9D%A2%E8%AF%95/vue%E7%9F%A5%E8%AF%86%E7%82%B9/">vue知识点</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9D%A2%E8%AF%95/vue%E7%9F%A5%E8%AF%86%E7%82%B9/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9F%A5%E8%AF%86/">生命周期知识</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9D%A2%E8%AF%95/vue%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%8CSPA%E5%8D%95%E9%A1%B5%E9%9D%A2/">vue知识点，SPA单页面</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9D%A2%E8%AF%95/vue%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%8C%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86-MVVM/">vue知识点，双向数据绑定原理& MVVM</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9D%A2%E8%AF%95/vue%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%8C%E8%B7%AF%E7%94%B1%E6%A8%A1%E5%BC%8F%E5%8E%9F%E7%90%86/">vue知识点，路由模式原理</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9D%A2%E8%AF%95/%E4%BB%8EURL%E8%BE%93%E5%85%A5%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%8E%B0%E6%B6%89%E5%8F%8A%E7%9A%84%E7%9F%A5%E8%AF%86%E3%80%82/">从URL输入到页面展现涉及的知识。</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9D%A2%E8%AF%95/%E4%BD%9C%E7%94%A8%E5%9F%9F-%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/">作用域-作用域链</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9D%A2%E8%AF%95/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/">浏览器缓存</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84js%E6%93%8D%E4%BD%9C/">项目中常用的js操作</a></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">March 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">February 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/12/">December 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/11/">November 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/10/">October 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/09/">September 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">August 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">July 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">June 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">May 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/03/14/TypeScript/ts/">TypeScript</a>
          </li>
        
          <li>
            <a href="/2022/02/22/webpack/webpack/">webpack</a>
          </li>
        
          <li>
            <a href="/2021/12/25/%E6%AD%A3%E5%88%99/%E6%AD%A3%E5%88%99%E7%9F%A5%E8%AF%86%E7%82%B9/">正则知识点,</a>
          </li>
        
          <li>
            <a href="/2021/11/26/es6/Symbol/">Symbol,</a>
          </li>
        
          <li>
            <a href="/2021/11/25/es6/%E6%96%B0%E5%A2%9E%E8%BF%90%E7%AE%97%E7%AC%A6/">运算符的扩展,</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2022 sxhMxd<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>