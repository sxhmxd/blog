<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>有理想的笛子</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="有理想的笛子">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="有理想的笛子">
<meta property="og:locale" content="zh">
<meta property="article:author" content="sxhMxd">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="有理想的笛子" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">有理想的笛子</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-js模块化发展/各种模块化方案规范" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/09/16/js%E6%A8%A1%E5%9D%97%E5%8C%96%E5%8F%91%E5%B1%95/%E5%90%84%E7%A7%8D%E6%A8%A1%E5%9D%97%E5%8C%96%E6%96%B9%E6%A1%88%E8%A7%84%E8%8C%83/" class="article-date">
  <time datetime="2022-09-16T07:25:52.056Z" itemprop="datePublished">2022-09-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/CommonJS-AMD-CMD-ES6/">CommonJS AMD CMD ES6</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/09/16/js%E6%A8%A1%E5%9D%97%E5%8C%96%E5%8F%91%E5%B1%95/%E5%90%84%E7%A7%8D%E6%A8%A1%E5%9D%97%E5%8C%96%E6%96%B9%E6%A1%88%E8%A7%84%E8%8C%83/">JS 模块化</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2022/09/16/js%E6%A8%A1%E5%9D%97%E5%8C%96%E5%8F%91%E5%B1%95/%E5%90%84%E7%A7%8D%E6%A8%A1%E5%9D%97%E5%8C%96%E6%96%B9%E6%A1%88%E8%A7%84%E8%8C%83/" data-id="cl8473qwe0029w0dx1y7dazmd" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-js模块化发展/前言" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/09/15/js%E6%A8%A1%E5%9D%97%E5%8C%96%E5%8F%91%E5%B1%95/%E5%89%8D%E8%A8%80/" class="article-date">
  <time datetime="2022-09-15T11:57:11.669Z" itemprop="datePublished">2022-09-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/JS%E6%A8%A1%E5%9D%97%E5%8C%96%E5%8F%91%E5%B1%95/">JS模块化发展</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/09/15/js%E6%A8%A1%E5%9D%97%E5%8C%96%E5%8F%91%E5%B1%95/%E5%89%8D%E8%A8%80/">JS 模块化</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="什么是模块化"><a href="#什么是模块化" class="headerlink" title="什么是模块化"></a>什么是模块化</h1><p>  将一个复杂的程序按照一定的规则封装成几个文件，并进行组合在一起。每个模块的内部数据是私有的，只是向外部暴露一些接口(方法)与外部其它模块通信。</p>
<h2 id="为什么要有模块化"><a href="#为什么要有模块化" class="headerlink" title="为什么要有模块化"></a>为什么要有模块化</h2><p>  技术的诞生是为了解决某个问题，模块化也是，在js模块化诞生历程。</p>
<ul>
<li>第一阶段<br>在JavaScript 语言刚刚诞生的时候，它仅仅用于实现页面中的一些小效果，一个页面所用到的JS可能只有区区几百行的代码，在这种情况下语言存在的缺陷被大家有意的忽略，程序的规模实在太小，只要开发人员小心谨慎，往往不会造成什么问题。在这个阶段不存在专业的前端工程师。</li>
<li>第二个阶段<br>ajax 的出现，逐渐改变了JavaScript 在浏览器中扮演的角色，它不仅可以实现小的效果，还可以和服务器之间进行交互，以更好的体验来改变数据。JS 的代码量逐渐增加，从最初的几百行到后来的几万行，前端的程序变的复杂。<br> 有三个问题阻碍了前端的程序的规模进一步扩大<ul>
<li>浏览器解释执行JS的速度太慢</li>
<li>用户的电脑配置不足</li>
<li>更多的代码带来的全局变量污染，依赖关系混乱等问题。<br>以上问题成为前端开发挥之不去的阴影和原罪。<ul>
<li>第三个阶段<br>到了2008 年 谷歌的V8 引擎发布，将JS的执行速度推上了一个新的台阶，甚至可以和后端语言媲美。个人电脑的配置开始飞跃，制约前端发展的两大问题得以解决，只剩下一个全局变量污染和依赖管理混乱的问题。<br>在此时Ryan Dahl 需要在服务器端手写一个高性能的web服务，高性能必须尽可能的减少线程，而要减少线程避免不了要使用异步方案，在他一筹莫展的时候谷歌的V8 引擎吸引了他的注意他发现JS就是最好的实现web服务器的语言，它天生是单线程，并且是基于异步的，有了V8 引擎的支撑，它的执行速度完全可以撑起一个服务器他基于V8 引擎 对源码作了一些修改 推出了该web服务项目命名为 nodejs。从此，JS第一次堂堂正正的入主后端，不再是必须附属于浏览器的“玩具”语言了。也是从刻开始，人们开始认识到，JS 是一门真正的语言，它依附于运行环境(运行时)(宿主程序)而执行。nodejs 的诞生，便把JS 中的最后一个问题放到了台前即<code>全局变量污染和依赖混乱</code>问题。<br>经过社区的激烈讨论，最终，形成了一个模块化方案，即CommonJS，该方案彻底解决了全局变量污染和依赖混乱的问题。</li>
<li>第四个阶段<br>CommonJS(后端模块化方案) 的出现打开了前端开发者的思路。既然后端可以使用模块化的JS，那作为JS 语言的的老东家浏览器为啥不行呢？于是，开始有人想办法把CommonJS 语言运用到浏览器中。但是把CommonJS运用到浏览器里面存在诸多困难</li>
</ul>
<ul>
<li>CommonJS 是同步加载，适用于服务器端的模块加载，因为所用的模块都存放在本地硬盘，可以同步加载完成，等待时间就是硬盘的读取时间，但是对于浏览器，却是一个大问题，因为浏览器都放在服务器端，等待的时间取决于网速的快慢，可能要等很是长时间，浏览器处于“假死”状态。</li>
<li>浏览器不兼容CommonJS 的根本原因，在于缺少四个Node.js环境的变量。<ul>
<li>module</li>
<li>export </li>
<li>require</li>
<li>global<br>于是有些开发者就想，既然CommonJS运用到浏览器困难，我们干嘛不自己重新定一个模块化的标准出来，非得用CommonJS 的标准。于是很快AMD 规范出炉，它解决的问题和CommonJS 一样即 解决JS 全局变量污染和依赖混乱的问题，但是可以更好的适应浏览器环境相继的CMD规范出炉，它对AMD 的规范进行了改进。<br>这些行为，都受到了ECMA官方的密切关注，2015年，ES6发布，它提出了官方的模块化解决方案——ES6 模块化。从此以后，模块化成为了JS 本身特有的性质，这门语言有了可以和其他语言较量的资本，成为了可以编写大型应用的正式语言。<br><img src="https://img-blog.csdnimg.cn/ceef233a5b4447ac8782d440ce62445c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Y-25YeM5aSp,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="JS模块化发展时间线"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2022/09/15/js%E6%A8%A1%E5%9D%97%E5%8C%96%E5%8F%91%E5%B1%95/%E5%89%8D%E8%A8%80/" data-id="cl8473qwe0028w0dx9q0dgi0p" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-前端状态管理/状态管理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/08/12/%E5%89%8D%E7%AB%AF%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/" class="article-date">
  <time datetime="2022-08-12T11:04:54.052Z" itemprop="datePublished">2022-08-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/">状态管理</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/08/12/%E5%89%8D%E7%AB%AF%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/">前端状态管理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="什么是状态"><a href="#什么是状态" class="headerlink" title="什么是状态"></a>什么是状态</h2><p><code>状态是数据的变化</code>,例如颜色是红或是蓝，而颜色从红色变为蓝色这就是状态。<br> 状态的改变对应着视图的渲染或某段逻辑的执行。比如颜色从红色变为蓝色可能就要重新渲染视图，并且执行发送请求到服务端的逻辑。<br> <code>通过视图交互或者其他方式触发状态的变化。状态变化联动视图的渲染和逻辑的执行，这就是前端应用的核心。</code></p>
<h2 id="什么是状态管理"><a href="#什么是状态管理" class="headerlink" title="什么是状态管理"></a>什么是状态管理</h2><p>状态管理具体有两层含义：</p>
<ul>
<li>状态变化之前的逻辑，一般是异步的。</li>
<li>状态变化之后的联动处理，比如渲染视图或执行某段逻辑<br>举一些例子🌰</li>
</ul>
<ul>
<li><p>React 的 setState 不会马上修改状态，而是异步的批量的执行，把状态做一下合并。</p>
</li>
<li><p>Redux 的 action 在修改全局 state 之前也是要经历中间件的处理。<br>这些都是状态变化之前的异步过程的管理，是状态管理的第一层含义。</p>
</li>
<li><p>再例如 React setState修改了状态之后要触发视图的渲染和生命周期函数的执行，hooks 在依赖数组的状态变化之后也会重新执行(vue的data修改之后会重新渲染视图、执行computed和watch逻辑)</p>
</li>
<li><p>Redux 修改了全局状态之后要通知组件做渲染或者做其他逻辑的处理，Vuex、Mobx 等都是。<br>这些状态变化之后联动处理的管理，是状态管理的第二层含义。</p>
<p>那 Vue、React 和全局状态管理的库 Redux、Mobx、Vuex都是怎么实现状态管理的</p>
</li>
</ul>
<h2 id="状态管理的两种实现思路"><a href="#状态管理的两种实现思路" class="headerlink" title="状态管理的两种实现思路"></a>状态管理的两种实现思路</h2><p>  状态不会是一个，多个状态的集合会用对象的key、value 来表示，例如React 的 state 对象 Vue 的 data 对象<br>  如何监听一个对象的变化？</p>
<ul>
<li><p>我们是不是可以提供一个api 来修改，在这个api内做 state变化之前的处理，并且在state变化之后做联动处理。<br>所以这样的方案只能通过提供的api 来触发状态修改，直接修改state的值是触发不了状态管理逻辑。</p>
<p>React 的setState就是这种思路，通过setState修改状态会做状态变化之前的批量异步的状态合并，会触发状态变化之后视图渲染和hooks、生命周期的重新执行。直接修改state是没有用的。</p>
<ul>
<li>那怎么让直接修改状态也能监听到变化？<br>可以对对象做一层代理，代理它的set和get ，当执行get 的时候把依赖改状态的逻辑收集起来，当set修改状态的时候通知所有依赖它的逻辑(视图渲染、逻辑执行)做更新。<br>这种思路叫做响应式，也就是状态变化之后自动响应变化做联动处理的意思。</li>
</ul>
</li>
</ul>
<p><code>监听对象的变化就这两种方式：一 提供api来修改，内部做联动处理。二对对象做一层代理，set的时候做联动处理，通知get时收集的所有依赖。</code></p>
<h2 id="前端框架状态变化的性能优化"><a href="#前端框架状态变化的性能优化" class="headerlink" title="前端框架状态变化的性能优化"></a>前端框架状态变化的性能优化</h2><p>  频繁的修改state不是每一次都要做联动处理，有一些可以合并，所以React的setState是异步，会做批量的state合并(React 的setState传入的不是最终的state,而是state的diff,React内部去把这些diffstate更新到state.)<br>  而Vue是直接修改的是同一个对象，所以没有必要做合并，它的Watcher 执行是异步的，对多次放到队列里的Watcher 做下去重就行。 </p>
<h2 id="组件间的状体管理"><a href="#组件间的状体管理" class="headerlink" title="组件间的状体管理"></a>组件间的状体管理</h2><p> 组件内的状态管理是利用前端框架自带的state机制来管理。<br> 组件之间？一个组件的state变了如何联动其他组件变化。</p>
<h3 id="props"><a href="#props" class="headerlink" title="props"></a>props</h3><p>  通过props，把当前的组件的state作为props 传入其他组件，这样就可以联动变化。但是props只能一层层传递，如果组件和联动变化的组件相隔很层，传递props就很麻烦。<br> React 提供了Context 、Vue 提供了Event Bus。</p>
<h3 id="Context、Event-Bus"><a href="#Context、Event-Bus" class="headerlink" title="Context、Event Bus"></a>Context、Event Bus</h3><p>  React 组件可以在content中存放state,当context 中的state 变化的时候会直接触发相关联组件的渲染。</p>
<h3 id="Redux、Mobx、Vuex"><a href="#Redux、Mobx、Vuex" class="headerlink" title="Redux、Mobx、Vuex"></a>Redux、Mobx、Vuex</h3><pre><code>redux 就提供了中间件的机制，组件里发送action到store 之前会经历层层中间件的处理，在这里可以做一些可复用的逻辑的封装。
redux 就是提供api来修改的方案，通过reducer函数来对传入的action做处理，返回新的state。
mobx 没有提供中间件机制，它的action是执行状态class 的某个方法，可以用class的那套来做封装。mobx是响应式代理的方案，它对全局state做了一层代理(通过Object.defineProperty)，状态的get收集依赖，set的时候触发依赖更新。
vuex则像是两种思路的结合，内部是响应式代理来实现的变化监听，但是暴露出的api却是 redux 的 action 那一套。</code></pre><p>不管是前端框架内置的组件内状态变化管理的方案(react的setState、vue的直接修改data),还是前端框架提供的组件的状态管理方案(props、react的content、vue 的 event bus) 或是第三方的全局状态管理方案(redux、vuex、mobx等)都没有脱离那两种实现状态管理的方式：提供修改状态的api或者对状态对象做一层响应式代理。<br>也没有脱离状态管理的两层含义：对状态变化前的异步过程做管理，状态变化后做联动处理。只不过它们用在了不同的地方(前端框架内、全局状态管理库)，提供了不同的封装形式(对象、函数)，基于不同的思想(函数式、面向对象)结合了不同的异步管理方案。<br><code>状态是数据的变化。前端应用的核心问题就是管理状态，管理状态变化之前的通过视图或者其他方式触发的异步过程，管理状态变化之后的联动渲染和联动的逻辑执行</code></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2022/08/12/%E5%89%8D%E7%AB%AF%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/" data-id="cl8473qwo002lw0dxb2me33r6" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-面试/面试问题" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/07/27/%E9%9D%A2%E8%AF%95/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/" class="article-date">
  <time datetime="2022-07-27T02:09:36.910Z" itemprop="datePublished">2022-07-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/07/27/%E9%9D%A2%E8%AF%95/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/">面试/面试问题</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><h1 id="JS"><a href="#JS" class="headerlink" title="JS"></a>JS</h1><ul>
<li>数据类型有哪些<pre><code>原始类型，引用类型
区别是:原始类型是按值传递，引用类型是按引用传递
   原始类型 基本数据类型：栈内存
   引用数据类型：指针存储在栈，值存储在堆中</code></pre></li>
<li>判断数据类型的方法有哪些</li>
<li>instanceof 的原理</li>
<li></li>
<li>原型，原型链的理解</li>
<li>作用域，作用域链</li>
<li>this 的指向</li>
<li>事件循环机制</li>
<li>普通函数和箭头函数的区别是</li>
<li></li>
</ul>
<h1 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h1><p>mvc 和 mvvm 的区别</p>
<p>vue2 响应式原理<br>   虚拟dom</p>
<p>vue2 和 vue3 的区别<br>   1 双向数据绑定原理发生了改变<br>      vue2 双向数据绑定是利用ES5 的一个API Object.definePropert() 对数据进行劫持，结合发布订阅模式的方式列实现的，<br>      vue3 中使用了es6 Proxy API 对数据代理。<br>      优势：defineProperty 只能监听某个属性，不能对全对象监听。可以直接监听数组，不用再单独的对数组做特异性操作，直接可以检测到数据的变化。<br>   2 vue3 支持碎片化<br>      也就是说在组件可以拥有多个根节点。<br>   3 Composition API (合成型API)<br>      Vue2 与Vue3 最大的区别————Vue 使用选项类型API(options API) 对比Vue3 合成型API (Composition API)<br>      vue2 选项API 在代码里分割了不同的属性，data、computed属性、methods等。Vue3 组合式API 能让我们用方法来分割</p>
<h1 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h1><p>   讲讲对webpack 的理解</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2022/07/27/%E9%9D%A2%E8%AF%95/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/" data-id="cl8473qww0033w0dx19cdf59i" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-vue2vsvue3/beagin" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/07/16/vue2vsvue3/beagin/" class="article-date">
  <time datetime="2022-07-16T03:01:42.069Z" itemprop="datePublished">2022-07-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/vue2-%E4%B8%8E-vue3/">vue2 与 vue3</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/07/16/vue2vsvue3/beagin/">vue2 VS vue3,</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h1><h2 id="组合API"><a href="#组合API" class="headerlink" title="组合API"></a>组合API</h2><p>vue2 是 <code>选项式API(Option API)</code>，一个逻辑会散落在文件的不同位置(data、props、computed、watch、生命周期函数等)，导致代码的可读性变差，需要上下来回滚动跳转文件位置。Vue3 <code>组合式 API(Composition API)</code>则很好地解决这个问题，可将同一逻辑的内容写到一起。增强了代码的可读性、内聚性，还提供了较为完美的逻辑复用方案，<br>例子🌰<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">   &lt;span&gt; mouse position &#123;&#123;x&#125;&#125;  &#123;&#123;y&#125;&#125;&lt;&#x2F;span&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">  import &#123; ref &#125; from &#39;vue&#39;</span><br><span class="line">  import useMousePosition from &#39;.&#x2F;useMousePosition&#39;</span><br><span class="line">  const &#123;x,y&#125;  &#x3D; useMousePosition()</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">  </span><br><span class="line">&#x2F;&#x2F; useMousePosition.js</span><br><span class="line"></span><br><span class="line">import &#123; ref, onMounted, onUnmounted &#125; from &#39;vue&#39;</span><br><span class="line">function useMousePosition() &#123;</span><br><span class="line">  let x &#x3D; ref(0)</span><br><span class="line">  let y &#x3D; ref(0)</span><br><span class="line"></span><br><span class="line">   function update(e) &#123;</span><br><span class="line">    x.value &#x3D; e.pageX</span><br><span class="line">    y.value &#x3D; e.pageY</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  onMounted(() &#x3D;&gt; &#123;</span><br><span class="line">    window.addEventListener(&#39;mousemove&#39;, update)</span><br><span class="line">  &#125;)</span><br><span class="line">  </span><br><span class="line">  onUnmounted(() &#x3D;&gt; &#123;</span><br><span class="line">    window.removeEventListener(&#39;mousemove&#39;, update)</span><br><span class="line">  &#125;)</span><br><span class="line">  </span><br><span class="line">  return &#123;</span><br><span class="line">    x,</span><br><span class="line">    y</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>  <code>解决vue2 mixin 的存在命名冲突隐患，依赖不明确，不同组件间配置化不够灵活</code></p>
<h2 id="响应式原理"><a href="#响应式原理" class="headerlink" title="响应式原理"></a>响应式原理</h2><p>vue2 响应式原理基础是 Object.defineProperty; Vue3 响应式原理基础是 Proxy </p>
<h3 id="Object-defineProperty"><a href="#Object-defineProperty" class="headerlink" title="Object.defineProperty"></a>Object.defineProperty</h3><p>直接在对象上定义一个新的属性或者修改现有的属性，并返回对象。存在的缺陷是：无法监听对象或者数组新增、删除元素。Vue2 方案针对常用数组原型方法 push、pop、shuift、unshift、splice、 sort、reverse进行了封装处理</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2022/07/16/vue2vsvue3/beagin/" data-id="cl8473qwm002iw0dx8n8k6dpp" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-TypeScript/ts" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/04/13/TypeScript/ts/" class="article-date">
  <time datetime="2022-04-13T07:41:56.416Z" itemprop="datePublished">2022-04-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/TypeScript/">TypeScript</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/04/13/TypeScript/ts/">TypeScript</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="TypeScript-是什么"><a href="#TypeScript-是什么" class="headerlink" title="TypeScript 是什么"></a>TypeScript 是什么</h2><h3 id="TS-简介"><a href="#TS-简介" class="headerlink" title="TS 简介"></a>TS 简介</h3><p> Ts是微软开发的一个开源编程语言，通过在JS的基础上添加静态类型定义构建而成。TS通过TS编译器或者Babel转译为JS代码，可运行在任何浏览器，任何操作系统。</p>
<h3 id="TS-和-JS的区别"><a href="#TS-和-JS的区别" class="headerlink" title="TS 和 JS的区别"></a>TS 和 JS的区别</h3><p> TS 是JS 的一个超集，之间没有所属关系，ts扩展了js 弱类型语言的限制，增加更多的模块解析方式和语法糖。ts 并不是一个可以独立运行的语言，大多数时候可以被转译成js 运行。 可以认为 ts 相当于功能更丰富的编译型的js。</p>
<h3 id="为什么要有TS"><a href="#为什么要有TS" class="headerlink" title="为什么要有TS"></a>为什么要有TS</h3><p>传统的js本身已经完全满足应用打开，但是在大型项目或者插件的开发场景中，js 弱类型语言的不足便暴露出来，由于js是解释型语言，在代码编译的过程中无法轻松的实现良好的类型约束和类型推断。若开发者提供了一个解释依赖包给其他开发者来使用，使用依赖的开发者并不能显示观察依赖包的内部组成。这样导致在代码阅读上无法确定该属性的明确类型，会导致代码运行上存在风险。</p>
<p>  综上所述，js在代码的可维护性上存在一些弱项，所有强类型的ts正好适用于此类型开发场景。<br>   ts 强类型的约束性及其面向接口编程的约束性可以让ts 语言开发的应用有极强的维护性，代价是更大的代码篇幅。<br>   ts适用于插件提供者，依赖库提供者，基于js的服务端项目，已经大型项目的工程化开发使用。</p>
<h2 id="TypeScript-语法"><a href="#TypeScript-语法" class="headerlink" title="TypeScript 语法"></a>TypeScript 语法</h2><h3 id="基础数据类型"><a href="#基础数据类型" class="headerlink" title="基础数据类型"></a>基础数据类型</h3><h4 id="jS的八种内置类型"><a href="#jS的八种内置类型" class="headerlink" title="jS的八种内置类型"></a>jS的八种内置类型</h4>  <figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str: <span class="built_in">string</span> = <span class="string">"111"</span>;</span><br><span class="line"><span class="keyword">let</span> num: <span class="built_in">number</span> = <span class="number">123</span>;</span><br><span class="line"><span class="keyword">let</span> bool: <span class="built_in">boolean</span> = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">let</span> u: <span class="literal">undefined</span> = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">let</span> nu: <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> obj: object = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> big: bigint = <span class="number">100n</span>;</span><br><span class="line"><span class="keyword">let</span> sym: symbol = Symbol(<span class="string">"me"</span>);</span><br></pre></td></tr></table></figure>

<h3 id="其他类型"><a href="#其他类型" class="headerlink" title="其他类型"></a>其他类型</h3><h4 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h4><ul>
<li><p>对数组类型的定义有两种方式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arrStr: string[] = [<span class="string">"1"</span>, <span class="string">"2"</span>];</span><br><span class="line"><span class="keyword">let</span> arrNum: <span class="built_in">Array</span>&lt;string&gt; = [<span class="string">"1"</span>, <span class="string">"2"</span>];</span><br></pre></td></tr></table></figure>
</li>
<li><p>定义联合类型数组</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr2: (<span class="built_in">string</span> | <span class="built_in">number</span>)[] = [<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> arr1: <span class="built_in">Array</span>&lt;<span class="built_in">string</span> | <span class="built_in">number</span>&gt; = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br></pre></td></tr></table></figure>
</li>
<li><p>定义指定对象成员的数组</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> ArrayObj &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> arrObj: ArrayObj[] = [&#123; name: <span class="string">"xxx"</span>, age: <span class="number">12</span> &#125;];</span><br><span class="line"><span class="comment">// 任意类型的数组</span></span><br><span class="line"><span class="keyword">let</span> arrAny: <span class="built_in">any</span>[] = [<span class="number">1</span>,<span class="string">'string'</span>,<span class="built_in">boolean</span>,<span class="literal">null</span>,<span class="literal">undefined</span>]</span><br><span class="line"><span class="keyword">let</span> arrAny1:<span class="built_in">Array</span>&lt;<span class="built_in">any</span>&gt; = [<span class="number">1</span>,<span class="number">2</span>,<span class="literal">true</span>,<span class="string">'string'</span>]</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><ul>
<li><p>函数声明</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>函数表达式</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> mySum: <span class="function">(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span> = <span class="function"><span class="keyword">function</span> (<span class="params">x: <span class="built_in">number</span> y:<span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>可选参数且函数有返回值</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">joinName</span>(<span class="params">firstName: <span class="built_in">string</span>, lastName?: <span class="built_in">string</span></span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> firstName + lastName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数默认值</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">names</span>(<span class="params">firstName: <span class="built_in">string</span>, lastName: <span class="built_in">string</span> = "Cat"</span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> firstName + lastName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>剩余参数</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">push</span>(<span class="params">arr: <span class="built_in">any</span>[], ...items: <span class="built_in">any</span>[]</span>) </span>&#123;</span><br><span class="line">  items.forEach(<span class="function">(<span class="params">element</span>) =&gt;</span> &#123;</span><br><span class="line">    arr.push(element);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>带参数无返回值<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">name:<span class="built_in">string</span>,age:<span class="built_in">number</span></span>):<span class="title">void</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>函数重载<br>js是一个动态语言，我们通常会使用不同类型的参数来调用同一个函数，该函数会根据不同的参数返回不同类型的调用结果;</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line">add(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">add(<span class="string">"1"</span>,<span class="string">"2"</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li><p>定义联合类型 </p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义联合类型同时为该联合类型取一个别名</span></span><br><span class="line"><span class="keyword">type</span> Combinable = <span class="built_in">string</span> | <span class="built_in">number</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用联合类型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a:Combinable,b:Combinable</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> a === <span class="string">'string'</span> || <span class="keyword">typeof</span> b === <span class="string">'string'</span>) &#123;    </span><br><span class="line">  <span class="keyword">return</span> a.toString() + b.toString();   </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Tuple-元组"><a href="#Tuple-元组" class="headerlink" title="Tuple(元组)"></a>Tuple(元组)</h3></li>
</ul>
</li>
<li><p>元组定义<br>元组是TypeSctipt 中特有的类型，其工作方式类似于数组元组最重要的特性是可以限制<code>数组元素的个数和类型</code>,特别适合用来实现多值返回。<br>元组用于保存定长定数据类型的数据。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x: [<span class="built_in">string</span>,<span class="built_in">number</span>] years</span><br><span class="line"><span class="comment">// 类型必须匹配且个数必须为2</span></span><br><span class="line">x = [<span class="string">"12"</span>,<span class="number">10</span>] <span class="comment">// ok</span></span><br><span class="line">x = [<span class="number">10</span>,<span class="number">10</span>]   <span class="comment">// error</span></span><br></pre></td></tr></table></figure></li>
<li><p>元组类型的解构赋值</p>
</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> employee:[<span class="built_in">number</span>,<span class="built_in">string</span>] = [<span class="number">1</span>,<span class="string">'string'</span>]</span><br><span class="line"><span class="keyword">let</span> [id,username] = employee</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`id:<span class="subst">$&#123;id&#125;</span>`</span>)   <span class="comment">// id:1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`username:<span class="subst">$&#123;username&#125;</span>`</span>)  <span class="comment">// username:string</span></span><br></pre></td></tr></table></figure>
<p>注意点，在解构时，如果解构数组元素的个数不能超过元组中元素的个数，否则也会出现错误。</p>
<ul>
<li><p>元组类型的可选元素<br>在定义元组类型时，可以通过 ? 号来声明元组类型的可选元素。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> optionalTuple:[<span class="built_in">string</span>,<span class="built_in">boolean</span>?];</span><br><span class="line">optionalTuple = [<span class="string">'string'</span>,<span class="literal">true</span>]</span><br><span class="line">optionalTuple = [<span class="string">'string'</span>]</span><br></pre></td></tr></table></figure>
<h3 id="枚举-interFace"><a href="#枚举-interFace" class="headerlink" title="枚举 interFace"></a>枚举 interFace</h3><p>是一个完全抽象的对象，一个interface 可以对应多个class 对其内部的未实现方法进行实现，ts 中，interface 主要用于类型描述。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">interface</span> User&#123;</span><br><span class="line">      name:<span class="built_in">string</span></span><br><span class="line">      age:<span class="built_in">number</span></span><br><span class="line">      sex:<span class="built_in">string</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> obj:User =&#123;</span><br><span class="line">      name:<span class="built_in">string</span></span><br><span class="line">      age:<span class="built_in">number</span></span><br><span class="line">      sex:<span class="built_in">string</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//是强约束 约定该对象必须包含name,age,sex 这几个属性，不能有其他对象</span></span><br><span class="line">    <span class="keyword">interface</span> Us&#123;</span><br><span class="line">      readonly name:<span class="built_in">string</span>,  <span class="comment">// 表示该属性只读，不可以修改</span></span><br><span class="line">      age:<span class="built_in">number</span>,</span><br><span class="line">      [props:<span class="built_in">string</span>]:<span class="built_in">any</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 可以有约定以外的其他属性</span></span><br><span class="line">    <span class="keyword">interface</span> Func&#123;</span><br><span class="line">      (name):<span class="built_in">string</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 定义函数的接口</span></span><br><span class="line">    <span class="keyword">let</span> fun:Func = <span class="function"><span class="keyword">function</span>(<span class="params">name:<span class="built_in">string</span></span>):<span class="title">string</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> name</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">interface</span> User &#123;</span><br><span class="line">      name:<span class="built_in">string</span>,</span><br><span class="line">      age:<span class="built_in">number</span>,</span><br><span class="line">      sex:<span class="built_in">string</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">interface</span> Admin&#123;</span><br><span class="line">      name:<span class="built_in">string</span>,</span><br><span class="line">      age:<span class="built_in">number</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">type</span> Person = User | Admin</span><br><span class="line">    <span class="keyword">let</span> userobj =  <span class="built_in">Array</span>&lt;Person&gt; = [</span><br><span class="line">      &#123;name:<span class="string">''</span>,age:<span class="string">''</span>,sex:<span class="string">''</span>&#125;,</span><br><span class="line">      &#123;name:<span class="string">""</span>,age:<span class="string">""</span>&#125;</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">  <span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">### 泛型</span></span><br><span class="line"><span class="string"> 泛型是静态类型语言的另一灵魂工具，这里体现于静态类型的语言在定义类型时必须明确类型而造成的问题。</span></span><br><span class="line"><span class="string"> 当函数的参数和返回类型明确时，相同结构的函数需要根据不同的类型定义多个，这种情况很容易将代码的复杂度提高降低可维护性</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  `</span><span class="string">``</span> ts</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">test</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg:T</span>):<span class="title">T</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="类型推断"><a href="#类型推断" class="headerlink" title="类型推断"></a>类型推断</h3><p>在很多情况下，Typescript会根据上下文环境自动推断出变量的类型，无需我们再写明类型注解。<br>  <figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">'ss'</span></span><br><span class="line"><span class="keyword">let</span> num = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> bool = <span class="literal">true</span></span><br></pre></td></tr></table></figure><br>我们把TypeScript 这种基于赋值表达式推断类型的能力称之为 <code>类型推断</code></p>
<h3 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h3><p>  有时候会遇到这样的情况，你会比ts 更了解某个值的详细信息通常这会发生在你清楚的知道一个实体具有比它现有类型更确切的类型。<br>  通过类型断言这种方式告诉编辑器 ，”相信我，我知道自己在干什么”。类型断言好比其他语言里的类型转换，但是不进行特殊的数据检查和解构。它没有运行时的影响，只是在编译阶段起作用。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 尖括号语法</span></span><br><span class="line"><span class="keyword">let</span> someValue:<span class="built_in">any</span> = <span class="string">'this is a string'</span></span><br><span class="line"><span class="keyword">let</span> strLength:<span class="built_in">number</span> = (&lt;<span class="built_in">string</span>&gt;someValue).length</span><br><span class="line"><span class="comment">// as 语法</span></span><br><span class="line"><span class="keyword">let</span> someValue:<span class="built_in">any</span> = <span class="string">'this is a string'</span></span><br><span class="line"><span class="keyword">let</span> strLength:<span class="built_in">number</span> = (someValue <span class="keyword">as</span> <span class="built_in">string</span>).length</span><br></pre></td></tr></table></figure>
<h3 id="非空断言"><a href="#非空断言" class="headerlink" title="非空断言"></a>非空断言</h3><p>  在上下文中当类型检查器无法判定类型时，一个新的后缀表达式操作符! 可以用于断言操作对象是非 null 和undefined 类型，<code>x! 将从x值域中排除 null 和undefined</code><br>  <figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> value:<span class="literal">null</span> | <span class="literal">undefined</span> | <span class="built_in">string</span> </span><br><span class="line">value!.toString() </span><br><span class="line">value.toString()  <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure></p>
<h3 id="确定赋值断言"><a href="#确定赋值断言" class="headerlink" title="确定赋值断言"></a>确定赋值断言</h3><p>  允许实例属性和变量声明后面放置一个! 号，从而告诉 ts 该属性会被明确地赋值。<br>  <figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x: <span class="built_in">number</span>;</span><br><span class="line">initialize();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Variable 'x' is used before being assigned.(2454)</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span> * x); <span class="comment">// Error</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initialize</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">  x = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用确定赋值断言</span></span><br><span class="line"><span class="keyword">let</span> x!:<span class="built_in">number</span></span><br><span class="line">initialize()</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>*x)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initialize</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  x=<span class="number">10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>  通过 <code>let x!:number</code> 确定赋值类型断言，ts编辑器就会知道该属性会被明确地赋值。</p>
<h3 id="字面量类型"><a href="#字面量类型" class="headerlink" title="字面量类型"></a>字面量类型</h3><p>  在ts 中字面量不仅可以表示值，还可以表示类型，即所谓的字面量类型。目前ts支持三种字面量类型：<code>字符串字面量类型、数字字面量类型、布尔字面量类型</code>。<br>  <figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str: <span class="string">'1'</span> =<span class="string">'string'</span></span><br><span class="line"><span class="keyword">let</span> num: <span class="number">1</span> = <span class="number">124</span></span><br><span class="line"><span class="keyword">let</span> bool: <span class="literal">true</span> = <span class="literal">false</span></span><br></pre></td></tr></table></figure></p>
<h3 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h3><p>  联合类型表示取值可以为多种类型中的一种，使用 | 分割每个类型</p>
  <figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> strNum: <span class="built_in">string</span> | <span class="built_in">number</span> </span><br><span class="line">strNum = <span class="string">'ss'</span></span><br><span class="line">strNum = <span class="number">123</span></span><br></pre></td></tr></table></figure>
<h3 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h3><p>  类型别名用来给一个类型起一个新名字。类型别名常用于联合类型</p>
  <figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Message = <span class="built_in">string</span> | <span class="built_in">string</span>[]</span><br></pre></td></tr></table></figure>
<p>  注意：类型别名是给类型起一个新的名字，并不是创建一个新的类型。</p>
<h3 id="交叉类型"><a href="#交叉类型" class="headerlink" title="交叉类型"></a>交叉类型</h3><p>  交叉类型是将多个类型合并为一个类型。我们可以把现有的多种类型叠加到一起成为一种类型，它包含了所需的所有类型的特性，使用<code>&amp;</code> 定义交叉类型。<br>  如果我们仅仅是把原始类型，字面量类型，函数类型等原始类型合并成为交叉类型是没有任何用处的。它的用处是将多个接口类型合并成一个类型，从而实现等同接口继承的效果，也就是所谓的合并接口类型。<br>  <figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span>  IntersectionType = &#123;id:<span class="built_in">number</span>,name:<span class="built_in">string</span>&#125;&amp;&#123;age:<span class="built_in">number</span>&#125;</span><br><span class="line"><span class="keyword">const</span> user:IntersectonType = &#123;</span><br><span class="line">  id:<span class="number">1</span>,</span><br><span class="line">  name:<span class="string">'name'</span>,</span><br><span class="line">  age:<span class="number">18</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>  上面例子，我们通过交叉类型，使得IntersectionType 同时拥有了id name age 所有属性，这里我们可以试着将合并接口类型理解为求并集。</p>
<h2 id="object-Object-和"><a href="#object-Object-和" class="headerlink" title="object Object 和 {}"></a>object Object 和 {}</h2><p>小 <code>object</code> 代表的是所有非原始类型，也就是我们不能把 <code>number string boolean</code> 等原始类型赋值给<code>object</code> 。在严格模式下 <code>null</code> 和<code>undefined</code> 类型也不能赋给 <code>object</code></p>
<p>大 <code>Object</code> 代表所有拥有 <code>toString hasOwnProperty</code> 方法的类型，所以所有原始类型、非原始类型都可以赋给 <code>Object</code>。 在严格模式下 <code>null</code> 和<code>undefined</code> 类型也不能赋给 <code>object</code><br>  大 Object 保护你原始类型，小object 仅包含非原始类型，所以大Object 似乎是小 object的父类型。实际上， 大Object 不仅是 小object的父类型，同时也是小object的子类型。<br>  注意点：尽管官方文档说可以使用小object代替 大Object，但是我们仍要明白大Object 并不完全等于小object。</p>
<p><code>{}</code> 空对象类型和大Object一样，也是表示原始类型和非原始类型的集合，并且在严格模式下，<code>null</code> 和 <code>undefined</code> 也不能赋给 <code>{}</code><br><code>综上结论：{}、大 Object 是比小 object 更宽泛的类型（least specific），{} 和大 Object 可以互相代替，用来表示原始类型（null、undefined 除外）和非原始类型；而小 object 则表示非原始类型。</code></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2022/04/13/TypeScript/ts/" data-id="cl8473rcf004qw0dxa788c5xo" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-项目遇到的奇怪问题/elementUI奇怪问题解决办法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/04/13/%E9%A1%B9%E7%9B%AE%E9%81%87%E5%88%B0%E7%9A%84%E5%A5%87%E6%80%AA%E9%97%AE%E9%A2%98/elementUI%E5%A5%87%E6%80%AA%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/" class="article-date">
  <time datetime="2022-04-13T07:41:31.747Z" itemprop="datePublished">2022-04-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/elementUI%E5%A5%87%E6%80%AA%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/">elementUI奇怪问题解决办法</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/04/13/%E9%A1%B9%E7%9B%AE%E9%81%87%E5%88%B0%E7%9A%84%E5%A5%87%E6%80%AA%E9%97%AE%E9%A2%98/elementUI%E5%A5%87%E6%80%AA%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/">elementUI奇怪问题解决办法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="el-tabs-切换窗口或者重新编译会有蓝色阴影"><a href="#el-tabs-切换窗口或者重新编译会有蓝色阴影" class="headerlink" title="el-tabs 切换窗口或者重新编译会有蓝色阴影"></a>el-tabs 切换窗口或者重新编译会有蓝色阴影</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 需要在全局添加以下样式</span><br><span class="line">.el-tabs__item:focus.is-active.is-focus:not(:active) &#123;</span><br><span class="line">    -webkit-box-shadow: none !important;</span><br><span class="line">    box-shadow: none !important;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2022/04/13/%E9%A1%B9%E7%9B%AE%E9%81%87%E5%88%B0%E7%9A%84%E5%A5%87%E6%80%AA%E9%97%AE%E9%A2%98/elementUI%E5%A5%87%E6%80%AA%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/" data-id="cl8473qwx0035w0dx9vhtafa3" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-项目中用到的js方法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/04/13/%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%94%A8%E5%88%B0%E7%9A%84js%E6%96%B9%E6%B3%95/" class="article-date">
  <time datetime="2022-04-13T07:41:31.734Z" itemprop="datePublished">2022-04-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84js%E6%93%8D%E4%BD%9C/">项目中常用的js操作</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/04/13/%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%94%A8%E5%88%B0%E7%9A%84js%E6%96%B9%E6%B3%95/">项目中常用的js操作,</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="创建tag标签"><a href="#创建tag标签" class="headerlink" title="创建tag标签"></a>创建tag标签</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 创建 script 标签 绑定id 创建新的script 时对比删除之前的。</span><br><span class="line">  function  createScipt(str, id) &#123;</span><br><span class="line">      let getId &#x3D; document.getElementById(id);</span><br><span class="line">      getId ? getId.parentNode.removeChild(getId) : &quot;&quot;;</span><br><span class="line">      let head &#x3D; document.getElementsByTagName(&quot;head&quot;)[0];</span><br><span class="line">      var script &#x3D; document.createElement(&quot;script&quot;);</span><br><span class="line">      script.type &#x3D; &quot;text&#x2F;javascript&quot;;</span><br><span class="line">      script.text &#x3D; str;</span><br><span class="line">      script.id &#x3D; id;</span><br><span class="line">      head.appendChild(script);</span><br><span class="line">      &#x2F;&#x2F; document.getElementsByTagName(&quot;head&quot;)[0].appendChild(script);</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2022/04/13/%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%94%A8%E5%88%B0%E7%9A%84js%E6%96%B9%E6%B3%95/" data-id="cl8473qua0015w0dx2vy81xdd" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-面试/浏览器缓存" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/04/13/%E9%9D%A2%E8%AF%95/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/" class="article-date">
  <time datetime="2022-04-13T07:41:31.721Z" itemprop="datePublished">2022-04-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a>►<a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/">浏览器缓存</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/04/13/%E9%9D%A2%E8%AF%95/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/">浏览器缓存</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="浏览器缓存机制"><a href="#浏览器缓存机制" class="headerlink" title="浏览器缓存机制"></a>浏览器缓存机制</h1><h2 id="为什么要使用缓存"><a href="#为什么要使用缓存" class="headerlink" title="为什么要使用缓存"></a>为什么要使用缓存</h2><p>缓存是性能优化中简单高效的一种优化方式。一个优秀的缓存策略可以缩短网页请求资源的距离，减少延迟，并且由于缓存文件可以重复利用，还可以减少带宽，降低网络负载。</p>
<p>对于一个数据请求来说，可以分为发起网络请求、后端处理、浏览器响应三个步骤。浏览器缓存可以帮我们在发起网络请求和浏览器响应优化性能。例如 直接使用缓存而不发起请求，或者发起请求但后端存储的数据和前端一致，那就没有必要将数据回传回来，这样就减少了响应数据。</p>
<h2 id="缓存位置"><a href="#缓存位置" class="headerlink" title="缓存位置"></a>缓存位置</h2><p>从缓存位置上来说分为四种，并且各自有优先级，当依次查找缓存且都没有命中的时候，才会去请求网络。<br>Service Worker<br>Memory Cache<br>Disk Cache<br>Push Cache</p>
<h3 id="Service-Worker"><a href="#Service-Worker" class="headerlink" title="Service Worker"></a>Service Worker</h3><p>是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。使用 Service Worker 的话，传输协议必须为 HTTPS。因为 Service Worker 中涉及到请求拦截，所以必须使用 HTTPS 协议来保障安全。它可以让我们自由控制缓存哪些文件，如何匹配缓存，如何读取缓存，并且缓存是持续性的。</p>
<ul>
<li>实现缓存功能的步骤<ul>
<li>首先注册 Service Worker</li>
<li>监听到 install 事件以后就可以缓存文件，在下次用户访问的时候就可以通过拦截请求的方式查询是否存在缓存，存在缓存的话就可以直接读取缓存文件，否则就去请求数据</li>
<li>当没有命中缓存的时候，我们需要去调用 fetch 函数获取数据。会根据缓存查找优先级去查找数据，但是不管是从 Memory Cache 中还是网络请求中获取的数据，浏览器都会显示我们是从 Service Worker 中获取的内容。</li>
</ul>
</li>
</ul>
<h3 id="Memory-Cache"><a href="#Memory-Cache" class="headerlink" title="Memory Cache"></a>Memory Cache</h3><p><code>Memory Cache</code> 是内存中的缓存，主要包含的是当前页面中已经抓取到的资源。eg:页面样式、脚本、图片等。</p>
<ul>
<li>内存缓存的特点<br>内存缓存读取高效，但是缓存持续性很短，会随着进程的释放而释放。<code>一旦关闭 Tab 页面，内存中的缓存也就被释放了。</code> 计算的内存容量小，所以缓存不能全部放在内存中。<br>注意点：<code>内存缓存在缓存资源时并不关心返回资源的 HTTP 缓存头 Cache-Control是什么值，同时资源的匹配也并非仅仅是对 URL 做匹配，还可能会对 Content-Type，CORS 等其他特征做校验。</code></li>
</ul>
<h3 id="Disk-Cache"><a href="#Disk-Cache" class="headerlink" title="Disk Cache"></a>Disk Cache</h3><p>Disk Cache 也就是存储在硬盘中的缓存，读取速度慢，但是什么都可以存储到硬盘中。<br>在所有浏览器缓存中，Disk Cache 覆盖面是最大的，它会根据 HTTP Herder 中的字段判断哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源已经过期需要重新请求，并且即使在跨站点的情况下，相同地址的资源一旦被硬盘缓存下来，就不会再次去请求数据。</p>
<h3 id="Push-Cache"><a href="#Push-Cache" class="headerlink" title="Push Cache"></a>Push Cache</h3><p>Push Cache (推送缓存) 是 HTTP/2 中的内容，Service Worker Memory Cache Disk Cache 三种缓存都没有命中的时，才会使用。Push Cache 只在会话中存在，一旦会话结束就被释放，并且缓存时间也很短暂。在 Chome 浏览器中只有五分钟左右，同时它也并非严格执行 HTTP 头中的缓存指令。</p>
<ul>
<li>所有的资源都能被推送并且能够被缓存，但是 Edge 和 Safari 浏览器支持相对比较差</li>
<li>可以推送 no-cache 和 no-store 的资源</li>
<li>一旦连接关闭，Push Cache 就释放</li>
<li>多个页面可以使用同一个 HTTP/2 连接，也就是可以使用同一个 Push Cache</li>
<li>Push Cache 中的缓存只能被使用一次</li>
<li>浏览器可以拒绝接受已经存在的资源推送</li>
<li>可以给其他域名推送资源</li>
</ul>
<p>如果以上四种缓存都没有命中的话，那么就只能发起请求来获取资源。为了性能上的考虑，大部分的接口都应该选择好缓存策略，<code>通常浏览器缓存策略分为两种：强缓存和协商缓存，并且缓存策略都是通过设置 HTTP Header 来实现</code></p>
<h2 id="缓存过程分析"><a href="#缓存过程分析" class="headerlink" title="缓存过程分析"></a>缓存过程分析</h2><p>浏览器和服务器的通讯方式为应答模式，即浏览器发起 HTTP 请求-服务器响应该请求，<code>那么浏览器怎么确定一个资源该不该缓存，如何去缓存呢？</code>浏览器第一次向服务器发起该请求后拿到请求结果后，将请求结果和缓存标识存入浏览器缓存，<code>浏览器对于缓存的处理是根据第一次请求资源时返回的响应头来确定的。</code></p>
<p><img src="https://upload-images.jianshu.io/upload_images/3174701-de3d6e025582103a?imageMogr2/auto-orient/strip%7CimageView2/2/w/670/format/webp" alt="发起请求"></p>
<ul>
<li>浏览器每次发起请求，都会在浏览器缓存中查找该请求的结果以及缓存标识</li>
<li>浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存中。</li>
</ul>
<h2 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h2><p>强缓存：不会向服务器发送请求，直接从缓存中读取资源，在 chorme 控制台中可以看到该请求返回 200 的状态码，并且 Size 显示 from disk cache 或 from memory cache 。强缓存可以通过设置两种 HTTP Header 实现： Expires 和 Cache-Control</p>
<h3 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h3><p><code>缓存过期时间，用来指定资源到期的时间，是服务器端的具体的时间点</code>。也就是说 Expires= max-age + 请求时间，需要和 Last-modified 结合使用。<code>Last-Modified</code>是服务器认为文件的最后修改时间，是第一次请求文件的时候，服务器返回的一个属性。<br>Expires 是 Web 服务器响应消息头字段，在响应 http 请求时告诉浏览器在过期时间前浏览器可以直接从缓存取数据，而无需再次请求</p>
<p>Expires 是 Http/1 的产物，受限于本地时间，如果修改了本地时间，可能会造成缓存失效。</p>
<h3 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h3><p>Cache-Control 是最重要的规则，主要用于控制网页缓存。可以在请求头或者响应头中设置。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3174701-8ff981603cdfded0?imageMogr2/auto-orient/strip%7CimageView2/2" alt="Cache-Control"></p>
<ul>
<li><p>public</p>
<ul>
<li>所有内容都将被缓存(客户端和代理服务器都可缓存)。响应可被任何中间节点缓存，</li>
<li>Browser &lt;– proxy1 &lt;– proxy2 &lt;– server 中间的 proxy 可以缓存。</li>
</ul>
</li>
<li><p>private</p>
<ul>
<li>所有内容只有客户端可以缓存，cache-control 的默认取值。具体来说，表示中间节点不允许缓存</li>
<li>对于 Browser &lt;– proxy1 &lt;– proxy2 &lt;– server，proxy 会把 server 返回的数据发送给 proxy1，自己不缓存任何数据，当下次浏览器再次请求时 proxy 会做好请求转发而不是自作主张给自己缓存的数据。</li>
</ul>
</li>
<li><p>no-cache</p>
<ul>
<li>客户端缓存内容，是否使用缓存则需要经过协商缓存来验证决定。表示不使用 Cache-Control 的缓存控制方式做前置验证，而是使用 Etag 或者 Last-Modified 字段来控制缓存。</li>
</ul>
</li>
<li><p>no-store</p>
<ul>
<li>所有的内容都不会被缓存，即不使用强制缓存，也不使用协商缓存。</li>
</ul>
</li>
<li><p>max-age</p>
<ul>
<li>max-age=xxx 表示缓存内容将在 xxx 秒后失效。</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/3174701-3fa81f5e9efac5af?imageMogr2/auto-orient/strip%7CimageView2/2" alt></p>
</li>
</ul>
<h3 id="Expires-和-Cache-Control-两者对比"><a href="#Expires-和-Cache-Control-两者对比" class="headerlink" title="Expires 和 Cache-Control 两者对比"></a>Expires 和 Cache-Control 两者对比</h3><p>Expires 是 http1.0 的产物，Cache-Control 是 Http1.1 的产物，<code>两者同时存在的话，Cache-Control优先级高于Expires</code>。<br>强缓存判断是否缓存的依据是来自于是否超出某个时间或者某个时间段，而不关心服务器端文件是否已经更新，这就可能会导致加载文件不是服务器端最新的内容。此时我们需要用协商缓存策略。</p>
<h2 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h2><p><code>协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程</code></p>
<ul>
<li>协商缓存生效，返回 304 和 Not Modified</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/3174701-660fd163329d080b?imageMogr2/auto-orient/strip%7CimageView2/2/w/709/format/webp" alt="协商缓存生效"></p>
<ul>
<li>协商缓存失效，返回 200 和请求结果<br><img src="https://upload-images.jianshu.io/upload_images/3174701-24953079cfebf2bf?imageMogr2/auto-orient/strip%7CimageView2/2/format/webp" alt="协商缓存失效"><br>协商缓存可以通过设置 HttP Header 实现：Last-Modified 和 ETag</li>
</ul>
<h3 id="Last-Modified-和-If-Modified-Since"><a href="#Last-Modified-和-If-Modified-Since" class="headerlink" title="Last-Modified 和 If-Modified-Since"></a>Last-Modified 和 If-Modified-Since</h3><p>浏览器在第一次访问资源时，服务器返回资源的同时，在 response header 中添加 Last-Modified 的 header,值是这个资源在服务器上的最后修改时间。<br>浏览器下次请求这个资源，浏览器检测到有 Last-Modified 这个 header，于是 添加 If-Modified-Since header 值就是 Last-Modified 中的值；服务器再次收到这个资源的请求，会根据 If-Modified-Since 中的值与服务器中这个资源的最后修改时间做对比，如果没有变化，返回 304 和空的响应体，直接从缓存中读取，如果 If-Modified-Since 的时间小于服务器中资源最后修改时间，说明文件有更新于是返回新的资源文件和 200</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3174701-bb7148a4431ccda1?imageMogr2/auto-orient/strip%7CimageView2/2/w/438/format/webp" alt></p>
<p>弊端：</p>
<ul>
<li>如果只是在本地打开文件，没有对文件进行修改，但是还是会造成 Last-Modified 被修改，服务器不能命中缓存</li>
<li>Last-Modified 只能以秒计时，如果在不可感知的时间内修改文件，服务器会认为会命中缓存</li>
</ul>
<p>根据文件修改时间来决定是否缓存存在问题，可以直接根据文件内容是否修改来决定缓存策略</p>
<h3 id="ETag-和-If-None-Match"><a href="#ETag-和-If-None-Match" class="headerlink" title="ETag 和 If-None-Match"></a>ETag 和 If-None-Match</h3><p>ETag 是服务器响应请求时，返回当前资源文件的一个唯一标识(Hash 值 由服务器生成)，只要资源有变化。ETag 就会重新生成。在下一次加载资源向服务器发送请求时，会将上次返回的 ETag 值放到 request header 里的 If-None-Match 里，服务器比较客户端传过来的 If-None-Match 跟自己服务器上该资源的 ETag 是否一致。就可以判断资源是不是最新的</p>
<p>Last-Modified 和 ETag 的对比</p>
<ul>
<li>精确度<br>Etag 要优于 Last-Modifed，Last-Modified 的时间单位是秒，如果资源在一秒内改变多次，Last-Modified 其实并不能体现出来，如果是负载均衡的服务器各个服务器生成的 Last-Modified 也有可能不一致。 ETag 每次都会改变确保了精确度。</li>
<li>性能上<br>ETag 要逊于 Last-Modified ，last-Modified 只需要记录时间，ETag 需要服务器通过算法来计算一个 hash 值。</li>
<li>优先级<br>服务器校验优先考虑 ETag</li>
</ul>
<h2 id="缓存机制"><a href="#缓存机制" class="headerlink" title="缓存机制"></a>缓存机制</h2><p>强缓存优先于协商缓存，若强缓存(Expires 和 Cache-Control) 生效则直接使用缓存，若不生效则进行协商缓存(Last-Modified/If-Modified-since 和 ETag/If-None-Match)，协商缓存由服务器决定是否使用缓存，若协商缓存失效，则缓存失效，返回 200 重新返回资源和缓存标识，再存入浏览器缓存中，生效则返回 304 继续使用缓存<br><img src="https://upload-images.jianshu.io/upload_images/3174701-9d9e8b52a18ed35a?imageMogr2/auto-orient/strip%7CimageView2/2/w/519/format/webp" alt></p>
<h2 id="实际场景应用缓存策略"><a href="#实际场景应用缓存策略" class="headerlink" title="实际场景应用缓存策略"></a>实际场景应用缓存策略</h2><h3 id="频繁变动的资源"><a href="#频繁变动的资源" class="headerlink" title="频繁变动的资源"></a>频繁变动的资源</h3><p>Cache-Control:no-cache<br>对于频繁变动的资源，首先需要使用 Cache-Control:no-cache 使浏览器每次都请求服务器，然后配合 ETag 或者 Last-Modified 来验证资源是否有效。这样的作法虽然不能节省请求数量，但是可以显著减少响应数据的大小</p>
<h3 id="不常变动的资源"><a href="#不常变动的资源" class="headerlink" title="不常变动的资源"></a>不常变动的资源</h3><p>Cache-Control:max-age = 31356000</p>
<p>通常处理这类资源时，给他们的 Cache-Control 配置一个很大的 max-age= 31536000(一年)，这样浏览器之后请求相同 Url 会命中强制缓存。而为了解决更新的问题，就需要在文件名中添加 hash 版本号等动态字符，之后更改为动态字符，从而达到更改引用 URL 的目的让之前的强制缓存失效(其实并未立即消失，只是暂时不再使用而已)</p>
<h2 id="用户行为对浏览器缓存的影响"><a href="#用户行为对浏览器缓存的影响" class="headerlink" title="用户行为对浏览器缓存的影响"></a>用户行为对浏览器缓存的影响</h2><p>指的就是用户再浏览器操作时，会触发怎样的缓存策略。主要有三种</p>
<ul>
<li>打开网页，地址输入 URL:查找 <code>disk cache</code> 中是否有匹配。如有则使用，没有则发送网络请求。</li>
<li>普通刷新(F5) 因为 tab 页没有关闭，因此 <code>memory cache</code>是可用的，会被优先使用(如果匹配的话)，其次才是 disk cache</li>
<li>强制刷新( Ctrl + F5): 浏览器不使用缓存，因此发送请求的头部均带有 <code>Cache-control:no-cache</code> ( 为了兼容，还带了 Pargam:no-cache),服务器直接返回 200 和最新内容。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2022/04/13/%E9%9D%A2%E8%AF%95/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/" data-id="cl8473qwv0032w0dx64ea49gt" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-面试/作用域-作用域链" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/04/13/%E9%9D%A2%E8%AF%95/%E4%BD%9C%E7%94%A8%E5%9F%9F-%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/" class="article-date">
  <time datetime="2022-04-13T07:41:31.719Z" itemprop="datePublished">2022-04-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a>►<a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95/%E4%BD%9C%E7%94%A8%E5%9F%9F-%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/">作用域-作用域链</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/04/13/%E9%9D%A2%E8%AF%95/%E4%BD%9C%E7%94%A8%E5%9F%9F-%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/">作用域-作用域链</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h1><p>作用域是运行时代码的某些特定部分中变量，函数和对象的可访问性。即作用域决定了代码区块中变量和其他资源的可见性。<br>函数作用域在函数定义的时候就决定了。函数内部有个内部属性[[scope]],当函数创建的时候，就会保存所有父变量对象到其中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function outFun2()&#123;</span><br><span class="line">  var inVariable &#x3D; &#39;内层变量2&#39;</span><br><span class="line">&#125;</span><br><span class="line">outFun2()</span><br><span class="line">console.log(inVariable)  &#x2F;&#x2F; Uncaught ReferenceError: inVariable is not defined</span><br></pre></td></tr></table></figure>

<p>作用域最大的用处是隔离变量，不同作用域下同名变量不会有冲突。Es6 之前 JavaScript 没有块级作用域，只有全局作用域和函数作用域。</p>
<h2 id="全局作用域和函数作用域"><a href="#全局作用域和函数作用域" class="headerlink" title="全局作用域和函数作用域"></a>全局作用域和函数作用域</h2><ul>
<li><p>最外层的函数和在最外层函数外面定义的变量拥有全局作用域</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var outVariable &#x3D; &#39;我是最外层变量&#39;</span><br><span class="line">function outFun() &#123;</span><br><span class="line">  var inVariable &#x3D; &#39;内层变量&#39;;</span><br><span class="line">  function innerFun() &#123;</span><br><span class="line">    console.log(inVariable)</span><br><span class="line">  &#125;</span><br><span class="line">  innerFun()</span><br><span class="line">&#125;</span><br><span class="line">console.log(outVariable)   &#x2F;&#x2F; 我是外层变量</span><br><span class="line">outFun()                   &#x2F;&#x2F; 内层变量</span><br><span class="line">console.log(inVariable)    &#x2F;&#x2F; inVariable is not defined</span><br><span class="line">innerFun()                 &#x2F;&#x2F; innerFun is not defined</span><br></pre></td></tr></table></figure></li>
<li><p>所有未定义直接赋值的变量自动声明为拥有全局作用域</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function outFun2()&#123;</span><br><span class="line">  variable &#x3D; &#39;未定义直接赋值的变量&#39;;</span><br><span class="line">  var inVariable2 &#x3D; &#39;内层变量2&#39;</span><br><span class="line">&#125;</span><br><span class="line">outFun2()</span><br><span class="line">console.log(variable)      &#x2F;&#x2F; 未定义直接赋值的变量</span><br><span class="line">console.log(inVariable2)   &#x2F;&#x2F; inVariable2 is not defined</span><br></pre></td></tr></table></figure>
</li>
<li><p>所有 window 对象的属性拥有全局作用域<br>一般情况下，window 对象的内置属性都拥有全局作用域，eg:window.name、window.location 等。</p>
</li>
</ul>
<p>全局作用域有个弊端：如果我们写了很多行 JS 代码，变量定义都没有用函数包括，那么他们就全部都在全局作用域中。这样就会污染全局命名空间，容易起命名冲突。</p>
<p>注意：全局作用域在页面打开时被创建，页面关闭时被销毁。</p>
<h2 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a>函数作用域</h2><p>函数作用域，是指声明在函数内部的变量，和全局作用域相反，局部作用域一般只在固定的代码片段内可以访问到</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function doSomeThing()&#123;</span><br><span class="line">  var blogName &#x3D; &#39;blogName&#39;</span><br><span class="line">  function innerSay()&#123;</span><br><span class="line">    alert(blogName)</span><br><span class="line">  &#125;</span><br><span class="line">  innerSay()</span><br><span class="line">&#125;</span><br><span class="line">console.log(blogName) &#x2F;&#x2F; blogName is not defined</span><br><span class="line">innerSay()            &#x2F;&#x2F; innerSay is not defined</span><br></pre></td></tr></table></figure>

<ul>
<li>调用函数时，函数作用域被创建，函数执行完毕，函数作用域被销毁。</li>
<li>每调用一次函数就会创建一个新的函数作用域，他们之间是互相独立的。</li>
<li>函数作用域中可以访问到全局作用域的变量，在函数外部无法访问函数内部的变量。</li>
<li>在函数作用域中访问变量、函数会先在自身作用域中寻找，若是没有找到会到函数上一级作用域中寻找，一直到全局作用域，若是还没有找到返回 undefined。</li>
<li>函数作用域中也有声明提前的特性，对于变量和函数都起作用。</li>
<li>在函数中定义形参，等同于声明变量。</li>
</ul>
<p>作用域是分层的，内层作用域可以访问外层作用域的变量。</p>
<h2 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h2><p>块级作用域可通过新增命令 let 和 const 声明，所声明的变量在指定块的作用域外无法被访问。</p>
<ul>
<li>块级作用域的特点<ul>
<li>变量声明不会提前到代码顶部<br>let/const 声明并不会被提升到当前代码块的顶部，因此需要手动将 let/const 声明放置到顶部，以便让变量在整个代码块内部可用。</li>
<li>禁止重复声明，如果一个标识符已经在代码块内声明过，那么在此代码块内使用同一个标进行 let 声明就会抛出错误。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var count &#x3D; 30</span><br><span class="line">let count &#x3D; 40  &#x2F;&#x2F; Uncaught SyntaxError: Identifier &#39;count&#39; has already been declare</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h1 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h1><h2 id="Scopr-Chain-作用域链"><a href="#Scopr-Chain-作用域链" class="headerlink" title="[[Scopr Chain]] 作用域链"></a>[[Scopr Chain]] 作用域链</h2><p>当查找变量的时候，会先从当前上下文的变量对象中查找，如果没有找到就会从父级执行上下文的变量对象中查找，一直找到全局上下文的变量对象(全局对象)。这样由多个执行上下文的变量对象构成的链表就是作用域链。<br>根据在内部函数可以访问外部函数变量的这种机制，用链式查找决定哪些数据能被内部函数访问，这就时作用域链。</p>
<h1 id="JS-执行环境"><a href="#JS-执行环境" class="headerlink" title="JS 执行环境"></a>JS 执行环境</h1><p>执行环境(Execution context，EC) 或执行上下文。分为三种( 全局执行环境、函数执行环境、eval()执行环境)<br>js 为每一个执行环境关联了一个变量对象。环境中定义的所有变量和函数都保存在这个对象中。</p>
<h2 id="EC-的组成"><a href="#EC-的组成" class="headerlink" title="EC 的组成"></a>EC 的组成</h2><p>当 JavaScript 代码执行的时候，会进入不同的执行环境(执行上下文)，这些执行环境会构成了一个执行环境栈(执行上下文栈)(Execution context stack,ECS)<br><img src="https://segmentfault.com/img/bVbenRf?w=881&h=466" alt="执行环境"></p>
<h3 id="变量对象-VO-和-活动对象-AO"><a href="#变量对象-VO-和-活动对象-AO" class="headerlink" title="变量对象(VO) 和 活动对象(AO)"></a>变量对象(VO) 和 活动对象(AO)</h3><p><code>变量对象(VO)</code>: 变量对象即包含变量的对象，除了我们无法访问它外，和普通对象没有区别。变量对象存储了在<code>上下文中定义的变量</code>和<code>函数声明</code>。</p>
<p><code>活动对象(AO)</code>: 活动对象和变量对象是一个东西，变量对象是规范上的或者说是引擎上实现的，不可在 JavaScript 环境中访问，只有到当进入一个执行上下文中，这个执行上下文的变量对象才会被激活，activation object <code>只有被激活的变量对象，也就是活动对象上的各种属性才能被访问</code>。<br>活动对象是在进入函数执行环境时刻被创建的，它通过函数的 argument 属性初始化</p>
<h3 id="执行环境"><a href="#执行环境" class="headerlink" title="执行环境"></a>执行环境</h3><p>全局执行环境是最外围的执行环境，全局执行环境被认为是 window 对象，因此所有的全局变量和函数都作为 window 对象的属性和方法创建的。<br>js 的执行顺序是根据函数的调用来决定的，当一个函数被调用时，该函数环境变量对象就被压入一个环境栈中。在函数执行之后，栈将该函数的变量对象弹出，把控制权交给之前的执行环境变量对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var scope &#x3D; &#39;global&#39;</span><br><span class="line">  function fn1()&#123;</span><br><span class="line">    return scope</span><br><span class="line">  &#125;</span><br><span class="line">  function fn2()&#123;</span><br><span class="line">    return scope</span><br><span class="line">  &#125;</span><br><span class="line">  fn1()</span><br><span class="line">  fn2()</span><br></pre></td></tr></table></figure>

<p><img src="https://segmentfault.com/img/bVbenRt?w=1042&h=436" alt></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2022/04/13/%E9%9D%A2%E8%AF%95/%E4%BD%9C%E7%94%A8%E5%9F%9F-%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/" data-id="cl8473qwu0030w0dx9fng8wuk" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/2/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/CommonJS-AMD-CMD-ES6/">CommonJS AMD CMD ES6</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/JS%E6%A8%A1%E5%9D%97%E5%8C%96%E5%8F%91%E5%B1%95/">JS模块化发展</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/JavaScript-%E9%AB%98%E7%BA%A7/">JavaScript 高级</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/TypeScript/">TypeScript</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Vue-js/">Vue.js</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Vue-js/Props%E4%B8%8EData%E7%9A%84%E5%8C%BA%E5%88%AB/">Props与Data的区别</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Vue-js-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/">Vue.js 源码解读</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Vue-js-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E5%8F%98%E5%8C%96%E4%BE%A6%E6%B5%8B/">变化侦测</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Vue-js-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E5%8F%98%E5%8C%96%E4%BE%A6%E6%B5%8B/%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8F%98%E5%8C%96%E4%BE%A6%E5%90%AC/">数据的变化侦听</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Vue-js-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E5%90%8D%E8%AF%8D/">名词</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Vue-js-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E6%A8%A1%E6%9D%BF%E7%BC%96%E8%AF%91/">模板编译</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Vue-js-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/">生命周期</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Vue-js-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/%E5%88%9D%E5%A7%8B%E5%8C%96-initState-%E9%98%B6%E6%AE%B5/">初始化 initState 阶段</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Vue-js-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E8%99%9A%E6%8B%9FDOM/">虚拟DOM</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Vue-js-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E8%99%9A%E6%8B%9FDOM/Diff/">Diff</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Vue-js-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E8%99%9A%E6%8B%9FDOM/Vue%E4%B8%AD%E7%9A%84%E8%99%9A%E6%8B%9FDom/">Vue中的虚拟Dom</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Vue-js-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E8%99%9A%E6%8B%9FDOM/%E6%9B%B4%E6%96%B0%E5%AD%90%E8%8A%82%E7%82%B9/">更新子节点</a></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/async-await/">async await</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/elementUI%E5%A5%87%E6%80%AA%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/">elementUI奇怪问题解决办法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/element%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/">element使用不常用方法总结</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/es6/">es6</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/es6/Symbol/">Symbol</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/es6/%E8%BF%90%E7%AE%97%E7%AC%A6%E6%89%A9%E5%B1%95/">运算符扩展</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/import-%E5%92%8C-export/">import 和 export</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/js%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/">js知识体系</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/js%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/js-%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/">js 代码执行过程分析</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/js%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/js-%E8%AF%AD%E8%A8%80%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7/">js 语言的三大特性</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/js%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/%E4%BA%8B%E4%BB%B6/">事件</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/js%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/%E6%95%B0%E6%8D%AE/">数据</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/vue2-%E4%B8%8E-vue3/">vue2 与 vue3</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/webpack/">webpack</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/">正则表达式</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/%E6%AD%A3%E5%88%99%E7%9F%A5%E8%AF%86%E7%82%B9/">正则知识点</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E6%B6%89%E5%8F%8A%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9/">浏览器渲染涉及的知识点</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/">状态管理</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%99%BB%E5%BD%95%E8%AE%A4%E8%AF%81%E7%9F%A5%E8%AF%86/">登录认证知识</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9D%A2%E8%AF%95/vue%E7%9F%A5%E8%AF%86%E7%82%B9/">vue知识点</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9D%A2%E8%AF%95/vue%E7%9F%A5%E8%AF%86%E7%82%B9/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9F%A5%E8%AF%86/">生命周期知识</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9D%A2%E8%AF%95/vue%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%8CSPA%E5%8D%95%E9%A1%B5%E9%9D%A2/">vue知识点，SPA单页面</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9D%A2%E8%AF%95/vue%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%8C%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86-MVVM/">vue知识点，双向数据绑定原理& MVVM</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9D%A2%E8%AF%95/vue%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%8C%E8%B7%AF%E7%94%B1%E6%A8%A1%E5%BC%8F%E5%8E%9F%E7%90%86/">vue知识点，路由模式原理</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9D%A2%E8%AF%95/%E4%BB%8EURL%E8%BE%93%E5%85%A5%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%8E%B0%E6%B6%89%E5%8F%8A%E7%9A%84%E7%9F%A5%E8%AF%86%E3%80%82/">从URL输入到页面展现涉及的知识。</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9D%A2%E8%AF%95/%E4%BD%9C%E7%94%A8%E5%9F%9F-%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/">作用域-作用域链</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9D%A2%E8%AF%95/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/">浏览器缓存</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84js%E6%93%8D%E4%BD%9C/">项目中常用的js操作</a></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/09/">September 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/08/">August 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/07/">July 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/04/">April 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">July 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/09/16/js%E6%A8%A1%E5%9D%97%E5%8C%96%E5%8F%91%E5%B1%95/%E5%90%84%E7%A7%8D%E6%A8%A1%E5%9D%97%E5%8C%96%E6%96%B9%E6%A1%88%E8%A7%84%E8%8C%83/">JS 模块化</a>
          </li>
        
          <li>
            <a href="/2022/09/15/js%E6%A8%A1%E5%9D%97%E5%8C%96%E5%8F%91%E5%B1%95/%E5%89%8D%E8%A8%80/">JS 模块化</a>
          </li>
        
          <li>
            <a href="/2022/08/12/%E5%89%8D%E7%AB%AF%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/">前端状态管理</a>
          </li>
        
          <li>
            <a href="/2022/07/27/%E9%9D%A2%E8%AF%95/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/">面试/面试问题</a>
          </li>
        
          <li>
            <a href="/2022/07/16/vue2vsvue3/beagin/">vue2 VS vue3,</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2022 sxhMxd<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>