---
title: [作用域-作用域链]
categories: [面试, 作用域-作用域链]
---

# 作用域

作用域是运行时代码的某些特定部分中变量，函数和对象的可访问性。即作用域决定了代码区块中变量和其他资源的可见性。
函数作用域在函数定义的时候就决定了。函数内部有个内部属性[[scope]],当函数创建的时候，就会保存所有父变量对象到其中。

```
  function outFun2(){
    var inVariable = '内层变量2'
  }
  outFun2()
  console.log(inVariable)  // Uncaught ReferenceError: inVariable is not defined
```

作用域最大的用处是隔离变量，不同作用域下同名变量不会有冲突。Es6 之前 JavaScript 没有块级作用域，只有全局作用域和函数作用域。

## 全局作用域和函数作用域

- 最外层的函数和在最外层函数外面定义的变量拥有全局作用域
  ```
    var outVariable = '我是最外层变量'
    function outFun() {
      var inVariable = '内层变量';
      function innerFun() {
        console.log(inVariable)
      }
      innerFun()
    }
    console.log(outVariable)   // 我是外层变量
    outFun()                   // 内层变量
    console.log(inVariable)    // inVariable is not defined
    innerFun()                 // innerFun is not defined
  ```
- 所有未定义直接赋值的变量自动声明为拥有全局作用域

  ```
    function outFun2(){
      variable = '未定义直接赋值的变量';
      var inVariable2 = '内层变量2'
    }
    outFun2()
    console.log(variable)      // 未定义直接赋值的变量
    console.log(inVariable2)   // inVariable2 is not defined

  ```

- 所有 window 对象的属性拥有全局作用域
  一般情况下，window 对象的内置属性都拥有全局作用域，eg:window.name、window.location 等。

全局作用域有个弊端：如果我们写了很多行 JS 代码，变量定义都没有用函数包括，那么他们就全部都在全局作用域中。这样就会污染全局命名空间，容易起命名冲突。

注意：全局作用域在页面打开时被创建，页面关闭时被销毁。

## 函数作用域

函数作用域，是指声明在函数内部的变量，和全局作用域相反，局部作用域一般只在固定的代码片段内可以访问到

```
  function doSomeThing(){
    var blogName = 'blogName'
    function innerSay(){
      alert(blogName)
    }
    innerSay()
  }
  console.log(blogName) // blogName is not defined
  innerSay()            // innerSay is not defined
```

- 调用函数时，函数作用域被创建，函数执行完毕，函数作用域被销毁。
- 每调用一次函数就会创建一个新的函数作用域，他们之间是互相独立的。
- 函数作用域中可以访问到全局作用域的变量，在函数外部无法访问函数内部的变量。
- 在函数作用域中访问变量、函数会先在自身作用域中寻找，若是没有找到会到函数上一级作用域中寻找，一直到全局作用域，若是还没有找到返回 undefined。
- 函数作用域中也有声明提前的特性，对于变量和函数都起作用。
- 在函数中定义形参，等同于声明变量。

作用域是分层的，内层作用域可以访问外层作用域的变量。

## 块级作用域

块级作用域可通过新增命令 let 和 const 声明，所声明的变量在指定块的作用域外无法被访问。

- 块级作用域的特点
  - 变量声明不会提前到代码顶部
    let/const 声明并不会被提升到当前代码块的顶部，因此需要手动将 let/const 声明放置到顶部，以便让变量在整个代码块内部可用。
  - 禁止重复声明，如果一个标识符已经在代码块内声明过，那么在此代码块内使用同一个标进行 let 声明就会抛出错误。
    ```
      var count = 30
      let count = 40  // Uncaught SyntaxError: Identifier 'count' has already been declare
    ```

# 作用域链

## [[Scopr Chain]] 作用域链

当查找变量的时候，会先从当前上下文的变量对象中查找，如果没有找到就会从父级执行上下文的变量对象中查找，一直找到全局上下文的变量对象(全局对象)。这样由多个执行上下文的变量对象构成的链表就是作用域链。
根据在内部函数可以访问外部函数变量的这种机制，用链式查找决定哪些数据能被内部函数访问，这就时作用域链。

# JS 执行环境

执行环境(Execution context，EC) 或执行上下文。分为三种( 全局执行环境、函数执行环境、eval()执行环境)
js 为每一个执行环境关联了一个变量对象。环境中定义的所有变量和函数都保存在这个对象中。

## EC 的组成

当 JavaScript 代码执行的时候，会进入不同的执行环境(执行上下文)，这些执行环境会构成了一个执行环境栈(执行上下文栈)(Execution context stack,ECS)
![执行环境](https://segmentfault.com/img/bVbenRf?w=881&h=466)

### 变量对象(VO) 和 活动对象(AO)

`变量对象(VO)`: 变量对象即包含变量的对象，除了我们无法访问它外，和普通对象没有区别。变量对象存储了在`上下文中定义的变量`和`函数声明`。

`活动对象(AO)`: 活动对象和变量对象是一个东西，变量对象是规范上的或者说是引擎上实现的，不可在 JavaScript 环境中访问，只有到当进入一个执行上下文中，这个执行上下文的变量对象才会被激活，activation object `只有被激活的变量对象，也就是活动对象上的各种属性才能被访问`。
活动对象是在进入函数执行环境时刻被创建的，它通过函数的 argument 属性初始化

### 执行环境

全局执行环境是最外围的执行环境，全局执行环境被认为是 window 对象，因此所有的全局变量和函数都作为 window 对象的属性和方法创建的。
js 的执行顺序是根据函数的调用来决定的，当一个函数被调用时，该函数环境变量对象就被压入一个环境栈中。在函数执行之后，栈将该函数的变量对象弹出，把控制权交给之前的执行环境变量对象。

```
  var scope = 'global'
    function fn1(){
      return scope
    }
    function fn2(){
      return scope
    }
    fn1()
    fn2()
```

![](https://segmentfault.com/img/bVbenRt?w=1042&h=436)
