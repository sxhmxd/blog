---
title: [面试]
categories: [面试, 浏览器缓存]
---

# 浏览器缓存机制

## 为什么要使用缓存

缓存是性能优化中简单高效的一种优化方式。一个优秀的缓存策略可以缩短网页请求资源的距离，减少延迟，并且由于缓存文件可以重复利用，还可以减少带宽，降低网络负载。

对于一个数据请求来说，可以分为发起网络请求、后端处理、浏览器响应三个步骤。浏览器缓存可以帮我们在发起网络请求和浏览器响应优化性能。例如 直接使用缓存而不发起请求，或者发起请求但后端存储的数据和前端一致，那就没有必要将数据回传回来，这样就减少了响应数据。

## 缓存位置

从缓存位置上来说分为四种，并且各自有优先级，当依次查找缓存且都没有命中的时候，才会去请求网络。
Service Worker
Memory Cache
Disk Cache
Push Cache

### Service Worker

是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。使用 Service Worker 的话，传输协议必须为 HTTPS。因为 Service Worker 中涉及到请求拦截，所以必须使用 HTTPS 协议来保障安全。它可以让我们自由控制缓存哪些文件，如何匹配缓存，如何读取缓存，并且缓存是持续性的。

- 实现缓存功能的步骤
  - 首先注册 Service Worker
  - 监听到 install 事件以后就可以缓存文件，在下次用户访问的时候就可以通过拦截请求的方式查询是否存在缓存，存在缓存的话就可以直接读取缓存文件，否则就去请求数据
  - 当没有命中缓存的时候，我们需要去调用 fetch 函数获取数据。会根据缓存查找优先级去查找数据，但是不管是从 Memory Cache 中还是网络请求中获取的数据，浏览器都会显示我们是从 Service Worker 中获取的内容。

### Memory Cache

`Memory Cache` 是内存中的缓存，主要包含的是当前页面中已经抓取到的资源。eg:页面样式、脚本、图片等。

- 内存缓存的特点
  内存缓存读取高效，但是缓存持续性很短，会随着进程的释放而释放。`一旦关闭 Tab 页面，内存中的缓存也就被释放了。` 计算的内存容量小，所以缓存不能全部放在内存中。
  注意点：`内存缓存在缓存资源时并不关心返回资源的 HTTP 缓存头 Cache-Control是什么值，同时资源的匹配也并非仅仅是对 URL 做匹配，还可能会对 Content-Type，CORS 等其他特征做校验。`

### Disk Cache

Disk Cache 也就是存储在硬盘中的缓存，读取速度慢，但是什么都可以存储到硬盘中。
在所有浏览器缓存中，Disk Cache 覆盖面是最大的，它会根据 HTTP Herder 中的字段判断哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源已经过期需要重新请求，并且即使在跨站点的情况下，相同地址的资源一旦被硬盘缓存下来，就不会再次去请求数据。

### Push Cache

Push Cache (推送缓存) 是 HTTP/2 中的内容，Service Worker Memory Cache Disk Cache 三种缓存都没有命中的时，才会使用。Push Cache 只在会话中存在，一旦会话结束就被释放，并且缓存时间也很短暂。在 Chome 浏览器中只有五分钟左右，同时它也并非严格执行 HTTP 头中的缓存指令。

- 所有的资源都能被推送并且能够被缓存，但是 Edge 和 Safari 浏览器支持相对比较差
- 可以推送 no-cache 和 no-store 的资源
- 一旦连接关闭，Push Cache 就释放
- 多个页面可以使用同一个 HTTP/2 连接，也就是可以使用同一个 Push Cache
- Push Cache 中的缓存只能被使用一次
- 浏览器可以拒绝接受已经存在的资源推送
- 可以给其他域名推送资源

如果以上四种缓存都没有命中的话，那么就只能发起请求来获取资源。为了性能上的考虑，大部分的接口都应该选择好缓存策略，`通常浏览器缓存策略分为两种：强缓存和协商缓存，并且缓存策略都是通过设置 HTTP Header 来实现`

## 缓存过程分析

浏览器和服务器的通讯方式为应答模式，即浏览器发起 HTTP 请求-服务器响应该请求，`那么浏览器怎么确定一个资源该不该缓存，如何去缓存呢？`浏览器第一次向服务器发起该请求后拿到请求结果后，将请求结果和缓存标识存入浏览器缓存，`浏览器对于缓存的处理是根据第一次请求资源时返回的响应头来确定的。`

![发起请求](https://upload-images.jianshu.io/upload_images/3174701-de3d6e025582103a?imageMogr2/auto-orient/strip|imageView2/2/w/670/format/webp)

- 浏览器每次发起请求，都会在浏览器缓存中查找该请求的结果以及缓存标识
- 浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存中。

## 强缓存

强缓存：不会向服务器发送请求，直接从缓存中读取资源，在 chorme 控制台中可以看到该请求返回 200 的状态码，并且 Size 显示 from disk cache 或 from memory cache 。强缓存可以通过设置两种 HTTP Header 实现： Expires 和 Cache-Control

### Expires

`缓存过期时间，用来指定资源到期的时间，是服务器端的具体的时间点`。也就是说 Expires= max-age + 请求时间，需要和 Last-modified 结合使用。`Last-Modified`是服务器认为文件的最后修改时间，是第一次请求文件的时候，服务器返回的一个属性。
Expires 是 Web 服务器响应消息头字段，在响应 http 请求时告诉浏览器在过期时间前浏览器可以直接从缓存取数据，而无需再次请求

Expires 是 Http/1 的产物，受限于本地时间，如果修改了本地时间，可能会造成缓存失效。

### Cache-Control

Cache-Control 是最重要的规则，主要用于控制网页缓存。可以在请求头或者响应头中设置。

![Cache-Control](https://upload-images.jianshu.io/upload_images/3174701-8ff981603cdfded0?imageMogr2/auto-orient/strip|imageView2/2)

- public
  - 所有内容都将被缓存(客户端和代理服务器都可缓存)。响应可被任何中间节点缓存，
  - Browser <-- proxy1 <-- proxy2 <-- server 中间的 proxy 可以缓存。
- private
  - 所有内容只有客户端可以缓存，cache-control 的默认取值。具体来说，表示中间节点不允许缓存
  - 对于 Browser <-- proxy1 <-- proxy2 <-- server，proxy 会把 server 返回的数据发送给 proxy1，自己不缓存任何数据，当下次浏览器再次请求时 proxy 会做好请求转发而不是自作主张给自己缓存的数据。
- no-cache
  - 客户端缓存内容，是否使用缓存则需要经过协商缓存来验证决定。表示不使用 Cache-Control 的缓存控制方式做前置验证，而是使用 Etag 或者 Last-Modified 字段来控制缓存。
- no-store
  - 所有的内容都不会被缓存，即不使用强制缓存，也不使用协商缓存。
- max-age

  - max-age=xxx 表示缓存内容将在 xxx 秒后失效。

  ![](https://upload-images.jianshu.io/upload_images/3174701-3fa81f5e9efac5af?imageMogr2/auto-orient/strip|imageView2/2)

### Expires 和 Cache-Control 两者对比

Expires 是 http1.0 的产物，Cache-Control 是 Http1.1 的产物，`两者同时存在的话，Cache-Control优先级高于Expires`。
强缓存判断是否缓存的依据是来自于是否超出某个时间或者某个时间段，而不关心服务器端文件是否已经更新，这就可能会导致加载文件不是服务器端最新的内容。此时我们需要用协商缓存策略。

## 协商缓存

`协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程`

- 协商缓存生效，返回 304 和 Not Modified

![协商缓存生效](https://upload-images.jianshu.io/upload_images/3174701-660fd163329d080b?imageMogr2/auto-orient/strip|imageView2/2/w/709/format/webp)

- 协商缓存失效，返回 200 和请求结果
  ![协商缓存失效](https://upload-images.jianshu.io/upload_images/3174701-24953079cfebf2bf?imageMogr2/auto-orient/strip|imageView2/2/format/webp)
  协商缓存可以通过设置 HttP Header 实现：Last-Modified 和 ETag

### Last-Modified 和 If-Modified-Since

浏览器在第一次访问资源时，服务器返回资源的同时，在 response header 中添加 Last-Modified 的 header,值是这个资源在服务器上的最后修改时间。
浏览器下次请求这个资源，浏览器检测到有 Last-Modified 这个 header，于是 添加 If-Modified-Since header 值就是 Last-Modified 中的值；服务器再次收到这个资源的请求，会根据 If-Modified-Since 中的值与服务器中这个资源的最后修改时间做对比，如果没有变化，返回 304 和空的响应体，直接从缓存中读取，如果 If-Modified-Since 的时间小于服务器中资源最后修改时间，说明文件有跟新于是返回新的资源文件和 200

![](https://upload-images.jianshu.io/upload_images/3174701-bb7148a4431ccda1?imageMogr2/auto-orient/strip|imageView2/2/w/438/format/webp)

弊端：

- 如果只是在本地打开文件，没有对文件进行修改，但是还是会造成 Last-Modified 被修改，服务器不能命中缓存
- Last-Modified 只能以秒计时，如果在不可感知的时间内修改文件，服务器会认为会命中缓存

根据文件修改时间来决定是否缓存存在问题，可以直接根据文件内容是否修改来决定缓存策略

### ETag 和 If-None-Match

ETag 是服务器响应请求时，返回当前资源文件的一个唯一标识(Hash 值 由服务器生成)，只要资源有变化。ETag 就会重新生成。在下一次加载资源向服务器发送请求时，会将上次返回的 ETag 值放到 request header 里的 If-None-Match 里，服务器比较客户端传过来的 If-None-Match 跟自己服务器上该资源的 ETag 是否一致。就可以判断资源是不是最新的

Last-Modified 和 ETag 的对比

- 精确度
  Etag 要优于 Last-Modifed，Last-Modified 的时间单位是秒，如果资源在一秒内改变多次，Last-Modified 其实并不能体现出来，如果是负载均衡的服务器各个服务器生成的 Last-Modified 也有可能不一致。 ETag 每次都会改变确保了精确度。
- 性能上
  ETag 要逊于 Last-Modified ，last-Modified 只需要记录时间，ETag 需要服务器通过算法来计算一个 hash 值。
- 优先级
  服务器校验优先考虑 ETag

## 缓存机制

强缓存优先于协商缓存，若强缓存(Expires 和 Cache-Control) 生效则直接使用缓存，若不生效则进行协商缓存(Last-Modified/If-Modified 和 ETag/If-None-Match)，协商缓存由服务器决定是否使用缓存，若协商缓存失效，则缓存失效，返回 200 重新返回资源和缓存标识，再存入浏览器缓存中，生效则返回 304 继续使用缓存
![](https://upload-images.jianshu.io/upload_images/3174701-9d9e8b52a18ed35a?imageMogr2/auto-orient/strip|imageView2/2/w/519/format/webp)

## 实际场景应用缓存策略

### 频繁变动的资源

Cache-Control:no-cache
对于频繁变动的资源，首先需要使用 Cache-Control:no-cache 使浏览器每次都请求服务器，然后配合 ETag 或者 Last-Modified 来验证资源是否有效。这样的作法虽然不能节省请求数量，但是可以显著减少响应数据的大小

### 不常变动的资源

Cache-Control:max-age = 31356000

通常处理这类资源时，给他们的 Cache-Control 配置一个很大的 max-age= 31536000(一年)，这样浏览器之后请求相同 Url 会命中强制缓存。而为了解决更新的问题，就需要在文件名中添加 hash 版本号等动态字符，之后更改为动态字符，从而达到更改引用 URL 的目的让之前的强制缓存失效(其实并未立即消失，只是暂时不再使用而已)

## 用户行为对浏览器缓存的影响

指的就是用户再浏览器操作时，会触发怎样的缓存策略。主要有三种

- 打开网页，地址输入 URL:查找 `disk cache` 中是否有匹配。如有则使用，没有则发送网络请求。
- 普通刷新(F5) 因为 tab 页没有关闭，因此 `memory cache`是可用的，会被优先使用(如果匹配的话)，其次才是 disk cache
- 强制刷新( Ctrl + F5): 浏览器不使用缓存，因此发送请求的头部均带有 `Cache-control:no-cache` ( 为了兼容，还带了 Pargam:no-cache),服务器直接返回 200 和最新内容。
