## 渲染流水线

![](https://raw.githubusercontent.com/wqxc/Picture/main/chrome/image-20210519171828121.png)

### 加载主页面

加载主页面，调用网络进程，下载HTML文件。

下载完成之后，渲染进程解析HTML，而后构建DOM。

在解析HTML的时候，浏览器会预先下载HTML文件内需要的JS资源和CSS资源。



这里JS会阻塞DOM的解析，必然也会影响渲染吗，

另外的，JS的执行，需要CSSOM构建完毕之后才能执行，

所以CSS会阻塞JS的执行，JS会阻塞DOM的解析，所以，CSS也间接的会阻塞DOM的解析，这里的阻塞不是必然的，是一种可能性。

CSS会阻塞浏览器的渲染。

所以，CSS放在最前边，JS放在最后边。





### 构建DOM

HTML文件浏览器是不认识的，需要转换为浏览器能够处理的结构 ———— **DOM**



### 样式计算

样式计算是在CSS文件获取完成之后进行的，主要作用是计算出每一个DOM节点中，每一个元素的样式，这个过程分为下图所示的三样：

![样式计算](https://raw.githubusercontent.com/wqxc/Picture/main/chrome/image-20210519171905175.png)

##### 第一，将CSS文件转换为浏览器能识别的形式---styleSheets

CSS样式来源主要有三种：1、<style> 标签内的CSS。 2、link标签引入的。3、内嵌入HTML标签的CSS

CSS文件，和HTML文件一样，浏览器本身是理解不了的，需要将其转换为浏览器可以理解的结构---styleSheets。 styleSheets 也叫做 CSSOM

##### 第二，转换样式表中的属性值，使其标准化

比如，CSS中又很多 2rem,blue,bold 值。

就需要将其标准化为一个值，比如 2rem 就是  32px，blue 被解析为rgb, bold被解析为700.



##### 第三，计算出DOM树中每个节点的具体样式

这里涉及CSS的继承规则和层叠规则。

首先是CSS继承，CSS继承就是每个DOM节点都包含有父节点的样式。比如，html设定了font-size:20px.

其他的文本，没有设定 font-size 就会默认继承 html的字体。

层叠规则主要是根据CSS权重来处理。





样式计算阶段的目的是为了计算出DOM节点中，每个元素的具体样式，根据CSS的继承和层叠两个规则。





### 布局阶段

到了现在，我们有了DOM树和CSSOM树，有了元素，有了样式，唯一缺少的是DOM元素的几何信息，接下来要做的就是计算出DOM树中 **可见元素** 的位置信息。

布局阶段，主要完成两件是 **创建布局树** 和 **布局计算**



##### 创建布局树

DOM树种包含了很多不可见的元素，比如head标签，display：none 属性的元素，所以还要额外的构建一棵可见元素的布局树。

核心是遍历DOM树，可见的就放在布局树上，不可见的就放弃。



##### 布局计算

计算布局树的坐标位置，这个过程很复杂。

计算完成之后，每一个元素的几何坐标信息就存储在布局树中。

这时候，布局树就包含了布局的多数信息。



### 分层

布局阶段，计算了元素的位置信息，按道理来说，有了元素，有了元素的位置信息，已经可以绘制页面了，但是，直接进行绘制的话，会有很大的性能问题，这里，浏览器做了另外的操作  ————  **分层**



为什么要分层？

页面上会有很多的效果，比如 3D变换，页面的滚动，横向的元素运动等。

如果所有的元素，在一个层面内，元素的变化必然引整个页面的重新布局计算。

而分层就可以解决这个问题，将这些变换的元素单独的分为一层，一些特殊的效果在这些层上去做，将影响降为最小。



最终，将多个分层合并在一起，最终合成一个页面，展示出来。



分层阶段，渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的———— **图层树**



##### 如何成为一层

第一：拥有层叠上下文属性的元素会被单独提升为一层

```javascript
position: absolute|releative  并且 z-index值不为auto
flex 容器的子元素  z-index 不为auto
grid 容器的子元素，z-index不为auto
opacity 属性值小于1 
transform/filter 等属性值不为none

如上，拥有这些属性的元素被称之为拥有层叠上下文属性
```



第二：需要裁剪的地方会被创建为图层,举个例子

```javascript
<style>
    div {
        width: 200;
        height: 200;
        overflow: auto;
        background: gray;
    }
</style>

<body>
    <div>
        <p> 所以元素有了层叠上下文的属性或者需要被剪裁，那么就会被提升成为单独一层，你可以参看下
        <p> 从上图我们可以看到，document 层上有 A 和 B 层，而 B 层之上又有两个图层。这些图层组
        <p> 图层树是基于布局树来创建的，为了找出哪些元素需要在哪些层中，渲染引擎会遍历布局树来创
    </div>
</body>
```

如上所示，div宽高都是200，超出之后浏览器会自动滚动。出现这种剪裁情况的时候，渲染引擎会为文字部分单独创建一个层，出现滚动的话，滚动条会被提升为单独的层。

![分层](https://raw.githubusercontent.com/wqxc/Picture/main/chrome/image-20210520114909460.png)

如上图文字被单独提升为一层，有滚动的情况下，滚动条也会被单独提升为一层。



到这里，分层完成，分层树构建完成。接下来就是绘制



### 图层绘制

渲染引擎会把一个图层的绘制拆分成很多的小的 **绘制指令**，然后再把这些指令按照顺序组成一个待绘制列表。

![绘制列表](https://raw.githubusercontent.com/wqxc/Picture/main/chrome/image-20210520120237554.png)

图层绘制阶段，输出的内容就是这些待绘制的列表。



### 栅格化

绘制列表记录的是绘制顺序，和绘制指令的列表，真正的绘制操作是由渲染引擎中的**合成线程**来完成的。

渲染引擎可以认为是一个进程，从加载页面到计算样式再到布局阶段再到分层都是运行在主线程上的。

![渲染进程](https://raw.githubusercontent.com/wqxc/Picture/main/chrome/image-20210520142913259.png)



如图所示，当图层的绘制列表准备好之后，主线程会把改绘制列表  **提交（commit）**给合成线程.





### 光栅化

合成线程，首先是要注意一个概念 ———— **视口**

##### 视口

视口就是用户能看到的一部分，一个页面可能很大，大到超出当前的屏幕，有时候需要滚动很久才能到底部，用户能看到的就是屏幕那么大的空间。

如果一个页面很大，完全绘制的话是没有意义的，毕竟用户都看不到，性能开销也很大。



##### 图块

图块是栅格化执行的最小单位。

合成线程会将图层划分为图块，一般这些图块大小都是256x256 或者是 512x512

![分块](https://raw.githubusercontent.com/wqxc/Picture/main/chrome/image-20210520145517614.png)



如图，每一个小块儿就是图块，黑色框就是视口，或者是叫做屏幕，当前需要展示的图块就是 红线画的那些。

视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的，栅格化是指将图块转换为位图。



渲染进程维护了一个栅格化线程池，所有的图块栅格化都是在线程池内执行的，如下：

![渲染进程](https://raw.githubusercontent.com/wqxc/Picture/main/chrome/image-20210520151012247.png)



记得一点，栅格化线程将图块转换为位图。一般这个过程会有GPU的参与，用来快速的栅格化，GPU栅格化的位图都保存在GPU中。

GPU是运行在GPU进程中的，这里使用了GPU来快速栅格化，就涉及到跨进程操作了。

操作的流程如下所示：



![加GPU进程](https://raw.githubusercontent.com/wqxc/Picture/main/chrome/image-20210520152755253.png)



这里虽然也叫做栅格化，但是和前边我们说额栅格化不是一回事，比较常见的说法这里的栅格化也可以叫做光栅化。

##### 位图

位图也叫做点阵图，像素图，光栅图等。

由被称作像素的单个点组成的，这些点可以进行不同的排列组合，比如使用RGB编码，用红绿蓝三原色的光学强度来表示一种颜色

比如 RGB(0,0,0) 表示一个黑色的块儿，不同的RGB拼接在一起就可以形成一幅画。

最常见的，比如 色盲图谱，一个个的点会组成不同的图像或者是数字，这些也可以称之为位图。





### 合成

光栅化的最后就生成位图，每一个图层对应一个位图或者是一张图片，最后这些图片会根据层叠的顺序合并为一张图片。

最终生成的图片发送到后缓冲区。

简单的来说，一旦所有的图块都被光栅化了，合成线程就会生成一个绘制图块的命令，该命令会被提交给浏览器进程。

浏览器进程里的有专门的组件来接收这个命令，而后负责将页面内容绘制到内存中。



### 显示

页面的显示依靠的是显示器，显示器显示图像的核心是显卡，显示器上的页面（其实是图片）来自于显卡的一个叫做  **前缓冲区**  的地方。

显示器要做的事情很简单，就是每秒钟读取60张图片，并将读取的图片显示在浏览器上。



##### 显卡的职责

显卡的职责就是不断的合成新的图像，并保存在 **后缓冲区** ，一旦写入完成，系统就会让前后缓冲区对调，保证显示器总是读取最新的图像。一般而言，显卡的更新频率和显示器的刷新频率是一致的，但是，有些时候，在一些复杂的场景中，显卡处理图片会很慢，就会造成卡顿。



##### 帧和帧率

渲染流水线生成的一张图片，被称之为一帧，每秒钟渲染流水线制造了多少张图片，被称之为帧率。

如果渲染引擎生成某些帧的时间过长了，用户就会觉得卡顿。



##### 如何生成一帧图像

有三种方式来生成一帧图像

第一：重排

```javascript
首先说说第一种，在首次加载一个网站的时候，这三种方式都会被使用。

重排很简单，就是修改了元素的几何信息，比如朝DOM里添加一个元素，或者是删除一个元素等，都会触发重排，继而生成一帧图像，这个过程需要 重新构建布局树，而后的渲染阶段都要重新来一遍，这个过程是很耗性能的
```



第二： 重绘

```javascript
重绘不会影响布局阶段，操作效率要比重排要高一些，但是，依旧需要计算绘制信息，触发绘制操作之后的所有操作。 包括 绘制 分块，光栅化，合成，显示等
```



第三：合成

在合成线程中完成的任务都不会涉及图层内容的改变，一般都是图层的运动操作，比如滚动，动画，旋转等。

```javascript
相对而言，合成的效率就明显高了很多，合成操作不需要触发布局和绘制操作，而且合成是在合成线程上运行的，不会阻塞主线程，如果合成还采用了GPU的话，效率就更高了。
.box {
 will-change: transform, opacity;
 }
如上，这是告诉渲染进程这个元素要做一些比较秀的操作，transform 或者是 opacity，渲染引擎将该元素单独实现为一层，等变换发生的时候，渲染引擎会通过合成线程直接去处理变换，这些变换并没有涉及到主线程，就大大的提升了渲染的效率。

但是，虽然will-change 好用，但是用的多了也会影响效率的。
```





最后来一张总结的图



![全部的渲染](https://raw.githubusercontent.com/wqxc/Picture/main/chrome/image-20210520181235864.png)



