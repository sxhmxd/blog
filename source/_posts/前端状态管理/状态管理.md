---
title: 前端状态管理
categories: [状态管理]
---

## 什么是状态
`状态是数据的变化`,例如颜色是红或是蓝，而颜色从红色变为蓝色这就是状态。
 状态的改变对应着视图的渲染或某段逻辑的执行。比如颜色从红色变为蓝色可能就要重新渲染视图，并且执行发送请求到服务端的逻辑。
 `通过视图交互或者其他方式触发状态的变化。状态变化联动视图的渲染和逻辑的执行，这就是前端应用的核心。`

## 什么是状态管理

状态管理具体有两层含义：
  * 状态变化之前的逻辑，一般是异步的。
  * 状态变化之后的联动处理，比如渲染视图或执行某段逻辑
举一些例子🌰
  - React 的 setState 不会马上修改状态，而是异步的批量的执行，把状态做一下合并。
  - Redux 的 action 在修改全局 state 之前也是要经历中间件的处理。
   这些都是状态变化之前的异步过程的管理，是状态管理的第一层含义。
  - 再例如 React setState修改了状态之后要触发视图的渲染和生命周期函数的执行，hooks 在依赖数组的状态变化之后也会重新执行(vue的data修改之后会重新渲染视图、执行computed和watch逻辑)
  - Redux 修改了全局状态之后要通知组件做渲染或者做其他逻辑的处理，Vuex、Mobx 等都是。
   这些状态变化之后联动处理的管理，是状态管理的第二层含义。
  
 那 Vue、React 和全局状态管理的库 Redux、Mobx、Vuex都是怎么实现状态管理的

## 状态管理的两种实现思路
  状态不会是一个，多个状态的集合会用对象的key、value 来表示，例如React 的 state 对象 Vue 的 data 对象
  如何监听一个对象的变化？

 *  我们是不是可以提供一个api 来修改，在这个api内做 state变化之前的处理，并且在state变化之后做联动处理。
  所以这样的方案只能通过提供的api 来触发状态修改，直接修改state的值是触发不了状态管理逻辑。
   
   React 的setState就是这种思路，通过setState修改状态会做状态变化之前的批量异步的状态合并，会触发状态变化之后视图渲染和hooks、生命周期的重新执行。直接修改state是没有用的。
* 那怎么让直接修改状态也能监听到变化？
   可以对对象做一层代理，代理它的set和get ，当执行get 的时候把依赖改状态的逻辑收集起来，当set修改状态的时候通知所有依赖它的逻辑(视图渲染、逻辑执行)做更新。
   这种思路叫做响应式，也就是状态变化之后自动响应变化做联动处理的意思。
  
` 监听对象的变化就这两种方式：一 提供api来修改，内部做联动处理。二对对象做一层代理，set的时候做联动处理，通知get时收集的所有依赖。`

## 前端框架状态变化的性能优化
  频繁的修改state不是每一次都要做联动处理，有一些可以合并，所以React的setState是异步，会做批量的state合并(React 的setState传入的不是最终的state,而是state的diff,React内部去把这些diffstate更新到state.)
  而Vue是直接修改的是同一个对象，所以没有必要做合并，它的Watcher 执行是异步的，对多次放到队列里的Watcher 做下去重就行。 

## 组件间的状体管理
 组件内的状态管理是利用前端框架自带的state机制来管理。
 组件之间？一个组件的state变了如何联动其他组件变化。
 ### props