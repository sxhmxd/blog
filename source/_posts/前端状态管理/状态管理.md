---
title: 前端状态管理
categories: [状态管理]
---

## 什么是状态
`状态是数据的变化`,例如颜色是红或是蓝，而颜色从红色变为蓝色这就是状态。
 状态的改变对应着视图的渲染或某段逻辑的执行。比如颜色从红色变为蓝色可能就要重新渲染视图，并且执行发送请求到服务端的逻辑。
 `通过视图交互或者其他方式触发状态的变化。状态变化联动视图的渲染和逻辑的执行，这就是前端应用的核心。`

## 什么是状态管理

状态管理具体有两层含义：
  * 状态变化之前的逻辑，一般是异步的。
  * 状态变化之后的联动处理，比如渲染视图或执行某段逻辑
举一些例子🌰
  - React 的 setState 不会马上修改状态，而是异步的批量的执行，把状态做一下合并。
  - Redux 的 action 在修改全局 state 之前也是要经历中间件的处理。
   这些都是状态变化之前的异步过程的管理，是状态管理的第一层含义。
  - 再例如 React setState修改了状态之后要触发视图的渲染和生命周期函数的执行，hooks 在依赖数组的状态变化之后也会重新执行(vue的data修改之后会重新渲染视图、执行computed和watch逻辑)
  - Redux 修改了全局状态之后要通知组件做渲染或者做其他逻辑的处理，Vuex、Mobx 等都是。
   这些状态变化之后联动处理的管理，是状态管理的第二层含义。
  
 那 Vue、React 和全局状态管理的库 Redux、Mobx、Vuex都是怎么实现状态管理的

## 状态管理的两种实现思路
  状态不会是一个，多个状态的集合会用对象的key、value 来表示，例如React 的 state 对象 Vue 的 data 对象
  如何监听一个对象的变化？

 *  我们是不是可以提供一个api 来修改，在这个api内做 state变化之前的处理，并且在state变化之后做联动处理。
  所以这样的方案只能通过提供的api 来触发状态修改，直接修改state的值是触发不了状态管理逻辑。
   
   React 的setState就是这种思路，通过setState修改状态会做状态变化之前的批量异步的状态合并，会触发状态变化之后视图渲染和hooks、生命周期的重新执行。直接修改state是没有用的。
* 那怎么让直接修改状态也能监听到变化？
   可以对对象做一层代理，代理它的set和get ，当执行get 的时候把依赖改状态的逻辑收集起来，当set修改状态的时候通知所有依赖它的逻辑(视图渲染、逻辑执行)做更新。
   这种思路叫做响应式，也就是状态变化之后自动响应变化做联动处理的意思。
  
` 监听对象的变化就这两种方式：一 提供api来修改，内部做联动处理。二对对象做一层代理，set的时候做联动处理，通知get时收集的所有依赖。`

## 前端框架状态变化的性能优化
  频繁的修改state不是每一次都要做联动处理，有一些可以合并，所以React的setState是异步，会做批量的state合并(React 的setState传入的不是最终的state,而是state的diff,React内部去把这些diffstate更新到state.)
  而Vue是直接修改的是同一个对象，所以没有必要做合并，它的Watcher 执行是异步的，对多次放到队列里的Watcher 做下去重就行。 

## 组件间的状体管理
 组件内的状态管理是利用前端框架自带的state机制来管理。
 组件之间？一个组件的state变了如何联动其他组件变化。
 ### props
  通过props，把当前的组件的state作为props 传入其他组件，这样就可以联动变化。但是props只能一层层传递，如果组件和联动变化的组件相隔很层，传递props就很麻烦。
 React 提供了Context 、Vue 提供了Event Bus。
 ### Context、Event Bus 
  React 组件可以在content中存放state,当context 中的state 变化的时候会直接触发相关联组件的渲染。

  ### Redux、Mobx、Vuex 
    redux 就提供了中间件的机制，组件里发送action到store 之前会经历层层中间件的处理，在这里可以做一些可复用的逻辑的封装。
    redux 就是提供api来修改的方案，通过reducer函数来对传入的action做处理，返回新的state。
    mobx 没有提供中间件机制，它的action是执行状态class 的某个方法，可以用class的那套来做封装。mobx是响应式代理的方案，它对全局state做了一层代理(通过Object.defineProperty)，状态的get收集依赖，set的时候触发依赖更新。
    vuex则像是两种思路的结合，内部是响应式代理来实现的变化监听，但是暴露出的api却是 redux 的 action 那一套。



不管是前端框架内置的组件内状态变化管理的方案(react的setState、vue的直接修改data),还是前端框架提供的组件的状态管理方案(props、react的content、vue 的 event bus) 或是第三方的全局状态管理方案(redux、vuex、mobx等)都没有脱离那两种实现状态管理的方式：提供修改状态的api或者对状态对象做一层响应式代理。
也没有脱离状态管理的两层含义：对状态变化前的异步过程做管理，状态变化后做联动处理。只不过它们用在了不同的地方(前端框架内、全局状态管理库)，提供了不同的封装形式(对象、函数)，基于不同的思想(函数式、面向对象)结合了不同的异步管理方案。
`状态是数据的变化。前端应用的核心问题就是管理状态，管理状态变化之前的通过视图或者其他方式触发的异步过程，管理状态变化之后的联动渲染和联动的逻辑执行`