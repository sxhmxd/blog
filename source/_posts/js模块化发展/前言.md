---
title: JS 模块化
categories: [JS模块化发展]
---
# 什么是模块化
  将一个复杂的程序按照一定的规则封装成几个文件，并进行组合在一起。每个模块的内部数据是私有的，只是向外部暴露一些接口(方法)与外部其它模块通信。
 ## 为什么要有模块化
  技术的诞生是为了解决某个问题，模块化也是，在js模块化诞生历程。
 * 第一阶段
  在JavaScript 语言刚刚诞生的时候，它仅仅用于实现页面中的一些小效果，一个页面所用到的JS可能只有区区几百行的代码，在这种情况下语言存在的缺陷被大家有意的忽略，程序的规模实在太小，只要开发人员小心谨慎，往往不会造成什么问题。在这个阶段不存在专业的前端工程师。
 * 第二个阶段
  ajax 的出现，逐渐改变了JavaScript 在浏览器中扮演的角色，它不仅可以实现小的效果，还可以和服务器之间进行交互，以更好的体验来改变数据。JS 的代码量逐渐增加，从最初的几百行到后来的几万行，前端的程序变的复杂。
    有三个问题阻碍了前端的程序的规模进一步扩大
    - 浏览器解释执行JS的速度太慢
    - 用户的电脑配置不足
    - 更多的代码带来的全局变量污染，依赖关系混乱等问题。
     以上问题成为前端开发挥之不去的阴影和原罪。
  * 第三个阶段
  到了2008 年 谷歌的V8 引擎发布，将JS的执行速度推上了一个新的台阶，甚至可以和后端语言媲美。个人电脑的配置开始飞跃，制约前端发展的两大问题得以解决，只剩下一个全局变量污染和依赖管理混乱的问题。
  在此时Ryan Dahl 需要在服务器端手写一个高性能的web服务，高性能必须尽可能的减少线程，而要减少线程避免不了要使用异步方案，在他一筹莫展的时候谷歌的V8 引擎吸引了他的注意他发现JS就是最好的实现web服务器的语言，它天生是单线程，并且是基于异步的，有了V8 引擎的支撑，它的执行速度完全可以撑起一个服务器他基于V8 引擎 对源码作了一些修改 推出了该web服务项目命名为 nodejs。从此，JS第一次堂堂正正的入主后端，不再是必须附属于浏览器的“玩具”语言了。也是从刻开始，人们开始认识到，JS 是一门真正的语言，它依附于运行环境(运行时)(宿主程序)而执行。nodejs 的诞生，便把JS 中的最后一个问题放到了台前即`全局变量污染和依赖混乱`问题。
  经过社区的激烈讨论，最终，形成了一个模块化方案，即CommonJS，该方案彻底解决了全局变量污染和依赖混乱的问题。
  * 第四个阶段
    CommonJS(后端模块化方案) 的出现打开了前端开发者的思路。既然后端可以使用模块化的JS，那作为JS 语言的的老东家浏览器为啥不行呢？于是，开始有人想办法把CommonJS 语言运用到浏览器中。但是把CommonJS运用到浏览器里面存在诸多困难
      - CommonJS 是同步加载，适用于服务器端的模块加载，因为所用的模块都存放在本地硬盘，可以同步加载完成，等待时间就是硬盘的读取时间，但是对于浏览器，却是一个大问题，因为浏览器都放在服务器端，等待的时间取决于网速的快慢，可能要等很是长时间，浏览器处于“假死”状态。
      - 浏览器不兼容CommonJS 的根本原因，在于缺少四个Node.js环境的变量。
        + module
        + export 
        + require
        + global
    于是有些开发者就想，既然CommonJS运用到浏览器困难，我们干嘛不自己重新定一个模块化的标准出来，非得用CommonJS 的标准。于是很快AMD 规范出炉，它解决的问题和CommonJS 一样即 解决JS 全局变量污染和依赖混乱的问题，但是可以更好的适应浏览器环境相继的CMD规范出炉，它对AMD 的规范进行了改进。
    这些行为，都受到了ECMA官方的密切关注，2015年，ES6发布，它提出了官方的模块化解决方案——ES6 模块化。从此以后，模块化成为了JS 本身特有的性质，这门语言有了可以和其他语言较量的资本，成为了可以编写大型应用的正式语言。
![JS模块化发展时间线](https://img-blog.csdnimg.cn/ceef233a5b4447ac8782d440ce62445c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Y-25YeM5aSp,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)