---
title: [js知识体系, 数据]
categories: [js知识体系, 数据]
---

# 原始数据

原始数据类型共有六种：Number 、String 、Boolean 、 Undefined 、 Null 、Symbol

## Number 数据类型

Number 数据类型包含数字和 NaN

### NaN

`NaN` 非数字，不是一个数但是隶属于数字类型 NaN 和任何值(包括自己)相比较，不大于、不小于、不等于任何值。

判断是不是数字类型

```
isNaN('1243')   // false 虽然'123' 是字符串类型，但是由于是纯数字组成可以转换成一个数字

isNaN(123)    // false 说明是数字

isNaN('123ffff') // true


```

### 数字不同进制

Number 可以使用四种数字进制：十进制，二进制，八进制和十六进制
二进制：以零为开头，后面接一个小写或大写的拉丁文字母 B(0b 或者 0B)
八进制：以零为开头，假如 0 后面的数字不在 0 到 7 的范围内，改数字会被转换成十进制数字
十六进制：以零为开头，后面接一个小写或大写的拉丁文字母(0x 或者 0X)

```
// 十进制
1234566
12
// 二进制
0b1100    // 12
0b0001    // 1
// 八进制
0755    // 493
0644    // 420

// 十六进制
0xA     // 10
```

### 转换成数字方法

Number()、parseInt()、parseFloat()

#### Number()

可以用于任何数据类型，

- 转换规则

  - Boolean 值，true 转换成 1，false 转换成 0
  - null 值，返回 0。
  - undefined，返回 NaN
  - 如果是字符串，遵循的规则

    - 只包含数字(包括带正负号的情况)，则转换为十进制，
      ```
      Number('1')   // 1
      Number('+1')  // 1
      Number('011') // 11   前导的零被忽略
      ```
    - 字符是有效的浮点数格式，则将其转换成相对应的浮点数
      ```
      Number('-1.1')   // -1.1
      Number('01.1')   // 1.1
      Number('-01.12') // 1.12
      ```
    - 字符串包含有效的十六进制或者二进制格式，则将其转换为相同大小的十进制整数值

      ```
      Number('0xF')   // 15
      Number('0b1000') // 8

      ```

    - 如果是空字符串，则将其转换为 0 Number('') // 0
    - 如果不符合上面的，将其转换成 NaN Number('0www') // NaN

  - 如果是对象，则调用 valueOf() 方法，然后依照前面的规则转换返回的值，如果转换的值是 NaN ,则调用对象的 toString() 方法，然后再按照前面的规则转换字符串。

#### parseInt()

处理整数的时候，更常用 parseInt()函数
在转换字符串时是看其是否符合数值模式，会忽略字符串前面的空格，如果第一个字符不是数字或者符号就会返回 NaN

```
parseInt('123456blue')   // 123456
parseInt('')             // NaN
parseInt('22.34')        // 22
parseInt('0xa')          // 10  符合十六进制，转换成十进制
parseInt('070')          // 56  符合八进制，
parseInt('70')           // 70
parseInt('0b1100')       // 0
```

在包含进制的时候，parseInt(),可以有第二个参数，说明是几进制

```
parseInt('10',2) //2 按二进制解析转换为十进制
parseInt('10',8) //8 按八进制解析转换为十进制
parseInt('10',10) //10 按八进制解析转换为十进制
parseInt('10',16) //16 按十六进制解析转换为十进制


```

#### parseFloat()

parseFloat() 与 parseInt() 的解析方法基本一样，对浮点数和进制数不同
parseFloat 会忽略前置零

parseFloat() 对于二进制，十六进制的转换都是 0

```
parseFloat('123456blue')   // 123456
parseFloat('')             // NaN
parseFloat('22.34')        // 22.34
parseFloat('0xa')          // 0  十六进制字符串始终为零
parseFloat('070')          // 70
parseFloat('70')           // 70
parseFloat('0b1100')       // 0
```

## String 类型

### 创建

```
let strObject = new String('hello word')
let strs = 'hello word'

typeof (strObject)   // object
typeof(strs)  // String
```

### 属性

string 具有长度属性，字符串长度(空格也占位),可以通过 string[index]来访问对应的字符

```
let str = 'today is good day'
str.length // 17
str[2]     // d
```

### string 方法

- charAt(n)  
  传入数值，返回该位置对应字符

- charCodeAt(n)
  传入数值，返回该位置对应字符编码
- slice(n,m) 字符串截取，接受一个或者两个值
  从 index 为 n 开始(包括 n),到 index 为 m 结束(不包括 m) 返回一个新的字符串，不改变原字符串。

```
var str = 'DaShu.yang'
str.charAt(2) // 3
str.charCodeAt(2) // 83
str.slice(2)   // Shu.yang
str.slice(2,3) // S
```

- indexOf()
  搜索给定字符串，然后返回字符串的位置(找到返回该字符串的 index 值，反之返回 -1)，可以接受第二个参数，表示从字符串中的哪个位置开始搜索。

  ```
  let str = 'qwertyuiop';
  str.indexOf('w') // 1
  str.indexOf('m')  // -1
  ```

- match()
  字符串的模式匹配方法，接收一个正则表达式或者 RegExp 对象，返回一个数组，如果没匹配值返回 null
  该方法可在字符串内检索指定的值。
  ```
  var str = 'asdfghajk'
  str.match('a')    // [a] 查找是惰性的只会返回一个a,即查找到了第一个就返回查找结果。
  str.amtch(/a/g)   // [ a,a ]
  ```
- replace()  
  字符串替换，接收两个参数，第一个参数为字符串或者正则表达式，第二个参数是字符串或者是一个函数，返回一个字符串。

  ```
  var text = 'cat,bat,sat,fat'
  var reg = /at/g
  str.replace(reg,'')
  var str = 'abcdefg'
  var reg = /(c)d/g
  str.replace(reg,'$$d') // ab$defg
  var reg1 = /(c)d(e)/g
  str.replace(reg,'$2$1')  // abedcfg
  //这里把匹配的第一个内容和第二个内容替换位置($1匹配第一个位置，$2匹配第二个位置，然后再替换整个匹配到的cde)


  ```

- split
  字符串分割，接收两个参数，第一个字符串或者正则表达式，第二个是返回数组的最大长度，返回一个数组。

  ```
  var text = 'cat,bat,sat,fat'
  text.split(',')       // ['cat','bat','sat','fat']
  text.split(',',3)     // ['cat','bat','sat']
  ```

## Boolean

### 创建

```
var boo = new Boolean()    // false 未对boo进行赋值，默认值为 false
var boo new Boolean(true)  // true
var boo = true/false

```

如果逻辑对象无初始值或者其值为 0 -0 null '' false undefined NaN,那么对象的值为 false,否则其值为 true

- ! 一个叹号是取反，首先将值转化为布尔类型的，然后再取反

```
!3 // false ->先把3转化为 boolean 此时为 true,然后再取反为 false
!0 // true -> 先把 0 转化为 boolean 此时为 false,然后再取反为 true

```

!! 将其他的数据类型转化为 boolean 类型，相当于 Boolean()

```
Boolean('dddd') // true
!!'dddd'        // true
```

### 不同数据类型的比较

- 两个不同类型数据比较时隐式转换规则

  - 数字和字符串、布尔类型、数组进行比较时，字符串(或者布尔、或数组)先转换为数字(Number),再进行比较。
    ```
    123 == '1234a'  // false
    123 == '123'    // true
    123 == false    // false
    123 == true     // false
    ```
  - 字符串和布尔类型比较，进行比较的两个数据同时经过 Number() 的转换后再进行比较，数组和布尔类型的比较也如此
    ```
      'qwe' ==  false   // false   Number('qwe') -> NaN ; Number(false) -> 0
      'qwe' == true     // false
      ''  ==  false     // true    Number('') -> 0 ; Number(false) -> 0
      ''  ==  true      // false
      []  ==  false     // true    Number([]) -> 0
      [0]  ==  false    // true    Number([0]) -> 0
      [00]  ==  false   // true    Number([00]) -> 0
      [0,0] ==  false   // false   Number([0,0]) -> NaN
    ```
  - undefined 除了和 Null 进行非全等比较返回 true，其它均返回 false。
  - null 除了和 undefined 进行非全等比较返回 true，其它均返回 false。

    ```
    undefined == nll    // true
    undefined == 124    // false
    undefined == '123'  // false
    undefined == false  // false
    undefined == true   // false

    null == undefined   // true
    null == 124         // false
    null == '124'       // false
    null == false       // false
    null == true        // true
    ```

  - 数组(或对象) 和字符串进行比较时，数组(或对象) 会转换成字符串再进行比较

    ```
      [] == ''   // true
      [0] == ''  // false
      [0] == '0' // true

      var obj = {a:0}
      obj == ''  // false
      obj == '[object Object]' // true
    ```

## Undefined 和 Null

undefined 表示 "缺少值"，就是此处应该有一个值，但是还没有定义。
用法:

- 变量被声明了，但没有赋值时，就等于 undefined。
- 调用函数时，应该提供的参数没有提供，该参数等于 undefined。
- 对象没有赋值的属性，该属性的值为 undefined。
- 函数没有返回值时，默认返回 undefined。
  null 表示 "没有对象"，即该处不应该有值
  用法
- 作为函数的参数，表示该函数的参数不是对象。
- 作为原型链的终点。

## Symbol

本质上是一种唯一标识符，可作为对象的唯一属性名，别就不会改写或覆盖你设置的属性值

- 创建

```
let id = Symbol('id')
```

- 特点

  - 唯一性，即使是用同一个变量生成的值也不相等。

    ```
      let id1 = Symbol('id')
      let id2 = Symbol('id')
      id1 == id2                // false

    ```

  - 隐藏性 for in Object.keys() 不能访问
    ```
      let id = Symbol('id')
      let obj = {
        [id]:'symbol'
      };
      for(let option in obj){
        console.log(obj[option])   // 空
      }
    ```

- Symbol.for()，Symbol.keyFor()

```
  let name1 = Symbol.for('name')  // 检测到未创建后返回
  let name2 = Symbol.for('name')  // 检测到已创建后返回
  name1 === name2
  // 访问值
  Symbol.keyFor('name1')  // name
  Symbol.keyFor('name2')  // name

```

# 引用数据类型

- 引用数据类型也就是对象数据类型 object (Object，Array,Function, data )
- JavaScript 的引用数据类型是保存在堆内存中的对象，不可以直接访问堆内存空间中的位置和操作堆内存空间，只能操作对象在栈内存中的对象。
- 引用数据类型在栈内存中实际上保存的是对象在堆内存中的引用地址，通过该地址可以快速的查找到保存在堆内存中的对象。

# 引用类型与原始类型的区别

### 声明变量时不同的内存分配

- 原始值：存储在栈内存(stack) 中的简单数据段，即他们的值直接存储在变量访问的位置。
- 引用值：存储在堆内存中，栈内存中存储的是该对象的指针，指向存储对象的内存地址
  为什么引用类型的值不能放在栈中，引用类型的值大小会发生改变，放在栈内存中会降低变量查询的速度。

### 访问机制

- 原始类型，值是可以直接访问
- 引用类型，访问一个对象时，首先得到的是这个对象在内存中的地址，然后再按照这个地址去获得这个对象中的值，即`按应用访问`

### 复制变量

- 原始类型：将保存原始值的变量复制给另一个变量时，会将原始值的副本赋值给新变量，此后这两个变量是完全独立的。
- 引用类型：是将内存地址赋值给新变量，即这两个变量都指向同一个堆内存中的同一个对象，任何一个改变都会反映在另一个身上。

### 传递参数

ECMAScript 中所有的函数的参数都是`按值传递`。
但是涉及到原始和引用类型的值时是有差异的，因为内存分配时的差异。

- 原始值：把变量的值传递给参数，之后参数和这个变量互不影响。
- 引用值：传递的值是内存地址，所以在函数内部对参数修改会体现在外部，因为他们指向的是同一个对象。
