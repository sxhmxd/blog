---
title: [js知识体系, 数据]
categories: [js知识体系, 数据]
---

# 原始数据

原始数据类型共有六种：Number 、String 、Boolean 、 Undefined 、 Null 、Symbol

## Number 数据类型

Number 数据类型包含数字和 NaN

### NaN

`NaN` 非数字，不是一个数但是隶属于数字类型 NaN 和任何值(包括自己)相比较，不大于、不小于、不等于任何值。

判断是不是数字类型

```
isNaN('1243')   // false 虽然'123' 是字符串类型，但是由于是纯数字组成可以转换成一个数字

isNaN(123)    // false 说明是数字

isNaN('123ffff') // true


```

### 数字不同进制

Number 可以使用四种数字进制：十进制，二进制，八进制和十六进制
二进制：以零为开头，后面接一个小写或大写的拉丁文字母 B(0b 或者 0B)
八进制：以零为开头，假如 0 后面的数字不在 0 到 7 的范围内，改数字会被转换成十进制数字
十六进制：以零为开头，后面接一个小写或大写的拉丁文字母(0x 或者 0X)

```
// 十进制
1234566
12
// 二进制
0b1100    // 12
0b0001    // 1
// 八进制
0755    // 493
0644    // 420

// 十六进制
0xA     // 10
```

### 转换成数字方法

Number()、parseInt()、parseFloat()

#### Number()

可以用于任何数据类型，

- 转换规则

  - Boolean 值，true 转换成 1，false 转换成 0
  - null 值，返回 0。
  - undefined，返回 NaN
  - 如果是字符串，遵循的规则

    - 只包含数字(包括带正负号的情况)，则转换为十进制，
      ```
      Number('1')   // 1
      Number('+1')  // 1
      Number('011') // 11   前导的零被忽略
      ```
    - 字符是有效的浮点数格式，则将其转换成相对应的浮点数
      ```
      Number('-1.1')   // -1.1
      Number('01.1')   // 1.1
      Number('-01.12') // 1.12
      ```
    - 字符串包含有效的十六进制或者二进制格式，则将其转换为相同大小的十进制整数值

      ```
      Number('0xF')   // 15
      Number('0b1000') // 8

      ```

    - 如果是空字符串，则将其转换为 0 Number('') // 0
    - 如果不符合上面的，将其转换成 NaN Number('0www') // NaN

  - 如果是对象，则调用 valueOf() 方法，然后依照前面的规则转换返回的值，如果转换的值是 NaN ,则调用对象的 toString() 方法，然后再按照前面的规则转换字符串。

#### parseInt()

处理整数的时候，更常用 parseInt()函数
在转换字符串时是看其是否符合数值模式，会忽略字符串前面的空格，如果第一个字符不是数字或者符号就会返回 NaN

```
parseInt('123456blue')   // 123456
parseInt('')             // NaN
parseInt('22.34')        // 22
parseInt('0xa')          // 10  符合十六进制，转换成十进制
parseInt('070')          // 56  符合八进制，
parseInt('70')           // 70
parseInt('0b1100')       // 0
```

在包含进制的时候，parseInt(),可以有第二个参数，说明是几进制

```
parseInt('10',2) //2 按二进制解析转换为十进制
parseInt('10',8) //8 按八进制解析转换为十进制
parseInt('10',10) //10 按八进制解析转换为十进制
parseInt('10',16) //16 按十六进制解析转换为十进制


```

#### parseFloat()

parseFloat() 与 parseInt() 的解析方法基本一样，对浮点数和进制数不同
parseFloat 会忽略前置零

parseFloat() 对于二进制，十六进制的转换都是 0

```
parseFloat('123456blue')   // 123456
parseFloat('')             // NaN
parseFloat('22.34')        // 22.34
parseFloat('0xa')          // 0  十六进制字符串始终为零
parseFloat('070')          // 70
parseFloat('70')           // 70
parseFloat('0b1100')       // 0
```

## String 类型

### 创建

```
let strObject = new String('hello word')
let strs = 'hello word'

typeof (strObject)   // object
typeof(strs)  // String
```

### 属性

string 具有长度属性，字符串长度(空格也占位),可以通过 string[index]来访问对应的字符

```
let str = 'today is good day'
str.length // 17
str[2]     // d
```

### string 方法

- charAt(n)  
  传入数值，返回该位置对应字符

- charCodeAt(n)
  传入数值，返回该位置对应字符编码
- slice(n,m) 字符串截取，接受一个或者两个值
  从 index 为 n 开始(包括 n),到 index 为 m 结束(不包括 m) 返回一个新的字符串，不改变原字符串。

```
var str = 'DaShu.yang'
str.charAt(2) // 3
str.charCodeAt(2) // 83
str.slice(2)   // Shu.yang
str.slice(2,3) // S
```

- indexOf()
  搜索给定字符串，然后返回字符串的位置(找到返回该字符串的 index 值，反之返回 -1)，可以接受第二个参数，表示从字符串中的哪个位置开始搜索。

  ```
  let str = 'qwertyuiop';
  str.indexOf('w') // 1
  str.indexOf('m')  // -1
  ```

- match()
  字符串的模式匹配方法，接收一个正则表达式或者 RegExp 对象，返回一个数组，如果没匹配值返回 null
  该方法可在字符串内检索指定的值。
  ```
  var str = 'asdfghajk'
  str.match('a')    // [a] 查找是惰性的只会返回一个a,即查找到了第一个就返回查找结果。
  str.amtch(/a/g)   // [ a,a ]
  ```
- replace()  
  字符串替换，接收两个参数，第一个参数为字符串或者正则表达式，第二个参数是字符串或者是一个函数，返回一个字符串。

  ```
  var text = 'cat,bat,sat,fat'
  var reg = /at/g
  str.replace(reg,'')
  var str = 'abcdefg'
  var reg = /(c)d/g
  str.replace(reg,'$$d') // ab$defg
  var reg1 = /(c)d(e)/g
  str.replace(reg,'$2$1')  // abedcfg
  //这里把匹配的第一个内容和第二个内容替换位置($1匹配第一个位置，$2匹配第二个位置，然后再替换整个匹配到的cde)


  ```

- split
  字符串分割，接收两个参数，第一个字符串或者正则表达式，第二个是返回数组的最大长度，返回一个数组。

  ```
  var text = 'cat,bat,sat,fat'
  text.split(',')       // ['cat','bat','sat','fat']
  text.split(',',3)     // ['cat','bat','sat']
  ```

## Boolean

### 创建

```
var boo = new Boolean()    // false 未对boo进行赋值，默认值为 false
var boo new Boolean(true)  // true
var boo = true/false

```

如果逻辑对象无初始值或者其值为 0 -0 null '' false undefined NaN,那么对象的值为 false,否则其值为 true

- ! 一个叹号是取反，首先将值转化为布尔类型的，然后再取反

```
!3 // false ->先把3转化为 boolean 此时为 true,然后再取反为 false
!0 // true -> 先把 0 转化为 boolean 此时为 false,然后再取反为 true

```

!! 将其他的数据类型转化为 boolean 类型，相当于 Boolean()

```
Boolean('dddd') // true
!!'dddd'        // true
```

### 不同数据类型的比较

- 两个不同类型数据比较时隐式转换规则

  - 数字和字符串、布尔类型、数组进行比较时，字符串(或者布尔、或数组)先转换为数字(Number),再进行比较。
    ```
    123 == '1234a'  // false
    123 == '123'    // true
    123 == false    // false
    123 == true     // false
    ```
  - 字符串和布尔类型比较，进行比较的两个数据同时经过 Number() 的转换后再进行比较，数组和布尔类型的比较也如此
    ```
      'qwe' ==  false   // false   Number('qwe') -> NaN ; Number(false) -> 0
      'qwe' == true     // false
      ''  ==  false     // true    Number('') -> 0 ; Number(false) -> 0
      ''  ==  true      // false
      []  ==  false     // true    Number([]) -> 0
      [0]  ==  false    // true    Number([0]) -> 0
      [00]  ==  false   // true    Number([00]) -> 0
      [0,0] ==  false   // false   Number([0,0]) -> NaN
    ```
  - undefined 除了和 Null 进行非全等比较返回 true，其它均返回 false。
  - null 除了和 undefined 进行非全等比较返回 true，其它均返回 false。

    ```
    undefined == nll    // true
    undefined == 124    // false
    undefined == '123'  // false
    undefined == false  // false
    undefined == true   // false

    null == undefined   // true
    null == 124         // false
    null == '124'       // false
    null == false       // false
    null == true        // true
    ```

  - 数组(或对象) 和字符串进行比较时，数组(或对象) 会转换成字符串再进行比较

    ```
      [] == ''   // true
      [0] == ''  // false
      [0] == '0' // true

      var obj = {a:0}
      obj == ''  // false
      obj == '[object Object]' // true
    ```

## Undefined 和 Null

undefined 表示 "缺少值"，就是此处应该有一个值，但是还没有定义。
用法:

- 变量被声明了，但没有赋值时，就等于 undefined。
- 调用函数时，应该提供的参数没有提供，该参数等于 undefined。
- 对象没有赋值的属性，该属性的值为 undefined。
- 函数没有返回值时，默认返回 undefined。
  null 表示 "没有对象"，即该处不应该有值
  用法
- 作为函数的参数，表示该函数的参数不是对象。
- 作为原型链的终点。

## Symbol

本质上是一种唯一标识符，可作为对象的唯一属性名，别就不会改写或覆盖你设置的属性值

- 创建

```
let id = Symbol('id')
```

- 特点

  - 唯一性，即使是用同一个变量生成的值也不相等。

    ```
      let id1 = Symbol('id')
      let id2 = Symbol('id')
      id1 == id2                // false

    ```

  - 隐藏性 for in Object.keys() 不能访问
    ```
      let id = Symbol('id')
      let obj = {
        [id]:'symbol'
      };
      for(let option in obj){
        console.log(obj[option])   // 空
      }
    ```

- Symbol.for()，Symbol.keyFor()

```
  let name1 = Symbol.for('name')  // 检测到未创建后返回
  let name2 = Symbol.for('name')  // 检测到已创建后返回
  name1 === name2
  // 访问值
  Symbol.keyFor('name1')  // name
  Symbol.keyFor('name2')  // name

```

# 引用数据类型

- 引用数据类型也就是对象数据类型 object (Object，Array,Function, data )
- JavaScript 的引用数据类型是保存在堆内存中的对象，不可以直接访问堆内存空间中的位置和操作堆内存空间，只能操作对象在栈内存中的对象。
- 引用数据类型在栈内存中实际上保存的是对象在堆内存中的引用地址，通过该地址可以快速的查找到保存在堆内存中的对象。

## 数组(Array)

数组是一组数据的集合，在内存中是一段连续的内存空间。
数组定义时可以无需指定数组长度
存储数据时无需指定具体的数据类型，可以存储任意类型。

## 创建

```
let arr1 = []
let arr2 = new Array()
let arr3 = new Array(3) // [empty*3]   创建一个数组，长度为三，值都为空。

```

## 属性

### length 属性

- length 属性表示数组的长度，即其中元素的个数。
- 当 length 属性被设置得更大时，数组将增大，新的元素将被添加到数组的尾部，他们的值为空(empty)
- 当 length 设置的值小于数组的长度时，数组将被截断，其尾部的元素将丢失。
  ```
  let arr = [1,2,3,4]
  arr.length // 4
  arr.length = 6 // [1,2,3,4,expty*2]
  arr.length = 2 // [1,2]
  ```

### 数组的方法

#### 改变数组自身内容的方法

`push() 、 pop()、 unshift()、 shift()、 reserve()、 splice()、 sort()、 fill() `

- push() 和 pop()
  push() 将某些值加入到数组的最后一个位置，不限制添加的数量，添加多项内容使用逗号隔开。
  pop() 会移除数组的最后一个元素。
  ```
    let a = [1,2,3,4,5]
    a.push(6)       // [1,2,3,4,5,6]
    a.push(7,8,9)   // [1,2,3,4,5,6,7,8,9]
    a.pop()         // [1,2,3,4,5,6,7,8]
  ```
- unshift(),shift()
  unshift() 会将指定的元素添加到数组的第一个位置。
  shift() 会移除数组的第一个元素。

  ```
    let arr = [1,2,3,4,5]
    arr.unshift(6)      // [6,1,2,3,4,5]
    arr.unshit(7,8,9)   // [7,8,9,6,1,2,3,4,5]
    arr.shift()         // [8,9,6,1,2,3,4,5]

  ```

- reverse()
  将数组反转
  ```
    let a = [1,2,3,4,5,6]
    a.reverse()   // [6,5,4,3,2,1]
  ```
- splice()
  该方法可以移除或新增数列的元素，包含三个参数，一个是要移除或要添加的序列号(必填)，第二个是要移除的长度(选填。若不填则从第一个参数位置开始，后面的元素都会被移除，设为 0 表示不会有元素删除，第三个是要替换的内容)
  ```
    let arr = [1,2,3,4,5,6,7]
    arr.splice(1,1) // [1,3,4,5,6,7]
    arr.splice(3,1,100) // [1,3,4,100.6,7]
    arr.splice(2,0,200) // [1,3,200,4,100,6,7]
  ```
- sort()
  该方法可以针对数组的元素进行排序，里头包含一个排序的判断函数，函数内必须包含的两个参数，两个参数分别代表数组里第 n 个和第 n+1 个元素，通过比较第 n 个和第 n+1 个元素的大小来进行排序
  ```
    let a = [3,2,4,5,1,6,7,8]
    a.sort((a,b)=>a-b)  // [1,2,3,4,5,6,7,8]
    a.sort((a,b)=>b-a)  // [8,7,6,5,4,3,2,1]
  ```
  若不使用判断函数，`默认会将元素换成字符串，并采用 unicode 来判断，这也会造成某些数字的排序错误`
  ```
    let a = [1,2,3,4,5,6,7,8,9,10,11,12]
    a.sort()  // [1,10,11,12,2,3,4,5,6,7,8,9]
  ```
- fill()
  该方法会把数组中所有元素，置换为指定的值，fill() 有三个参数，第一个是准备要置换的内容(必填)，第二个是从什么位置开始置换(选填，不设定就全部置换)，第三个是停止置换的元素的前一个位置(选填，默认等于数组长度)
  ```
  let a = [1,2,3,4,5,6,7,8,9]
  a.fill('a')  // ['a','a','a','a','a','a','a','a','a']
  let b = [1,2,3,4,5]
  b.fill('b',2,3) // [1,2,'b',4,5]
  ```

### 获取数组属性或索引值

`length() 、indexOf() 、lastIndexOf() 、 find()、 findIndex() 、filter()`

- length()
  可以取得数组的长度。
  ```
    let a = [1,2,3,4,5,6]
    a.length() // 6
  ```
- indexOf()、lastIndexOf()
  indexOf()会判断数组中是否包含某个值(从左往右)，如果包含就返回这个值在数组中的索引值，若没有找到返回 -1 。有两个参数一个是要找的的值，另外一个是表示数组数组从哪个位置开始判断。
  ```
    let a = [1,2,3,4,5]
    a.indexOf(3)   // 2
    a.indexOf(7)   // -1
    a.indexOf(3,6) // -1
  ```
  lastIndexOf()会判断数组中是否包含某个值(从右往左)，查找方式 indexOf()一样。
- find()
  find() 会将数组中的每一个元素带入指定的函数内做判断，并会返回一个符号判断条件的元素，若没有元素符合则会返回 undefined.
  ```
   let a = [1,2,3,4,5,6]
   a.find((e)=>e>3)  // 4
   a.find((e)=>e<1)  // undefined
  ```
- findIndex()
  findIndex() 会将数组中的每一个元素带入指定的函数内做判断，并返回第一个符合条件元素的位置索引。
- filter()
  filter() 会将数组中的每一个元素带入指定的函数内部做判断，如果符合条件则会返回，组成一个新的数组。

  ```
    let a = [1,2,3,4,5,6,7]
    a.filter(e => e>3)  // [4,5,6,7]
    a.filter(e = >e%2 == 0)  // [2,4,6]
  ```

### 针对每一项处理

- forEach()
  该方法会将数组中每一个元素用指定的函数里进行运算，函数有三个参数，第一个参数表示每个元素的值(必填),第二个参数为该元素的索引值(选填)，第三个参数则表示原本的数组(选填)。
  ```
    let a = [1,2,3,4,5]
    a.forEach((item,index,arr)=>{
      arr[index] = item*10
    })
    // [10,20,30,40,50]
  ```

### 产生新的数组或新的值

`join() concat() slice() map() reduce() reduceRight() flat() flatMap() Array.from() Array.of() toString()`

- join()
  可以将数组中所有元素，变成由指定的字符串分割合并在一起组成字符串进行呈现，若没有指定字符默认会用逗号合并。

  ```
    let a = [1,2,3,4,5]
    a.join()  // 1,2,3,4,5
    a.join('') // 12345

  ```

- concat() 可以将两个数组合并在一起，可以使用扩展运算符 ... 来代替。
  ```
  let a = [1,2,3,4,5]
  let b = [6,7,8,9]
  let c = a.concat(b)   // [1,2,3,4,5,6,7,8,9]
  let d = [...a,...b]   // [1,2,3,4,5,6,7,8,9]
  ```
- slice()
  可以截取出数组某部分的元素为一个新的数组，有两个必填的参数，一个是起始位置，一个是结束位置
  ```
  let a = [1,2,3,4,5,6]
  let b = a.slice(2,4)  // [3,4]
  ```
- map()
  会处理数组中每一个元素，最后返回一个新的数组，里面是一个函数和一个返回函数里的 this 参数，函数包含三个参数，第一个是每一个元素的值(必填)，第二个是当前元素的索引值，第三个是当前的数组。
  ```
    let a = [1,2,3,4,5,6]
    let b = a.map((e)=>{
      return e+2
    })
    // [3,4,5,6,7,8]
  ```
- reduce()
  可以将数组中每一个元素进行计算，每次计算的结果再与下一个元素计算，直到结束为止，里头包含一个函数(必填)和初始计算的数值(选填)，函数内有四个参数，第一个是计算的值(必填)，第二个是取得的元素(必填)，第三个是该元素的索引值(选填)，第四个是原本的数组(选填)。

  ```
    let a = [1,2,3,4,5,6,7,8]
    let b = a.reduce((total,e)=>{
      total + e
    })
    // 36 (1+2+3+4+5+6+7+8)
  ```

- flat()
  可以将一个多维数组的深度转换成一维(扁平化数组或成为降维)，有一个选填的参数代表要转换的深度数字，默认值为 1 ，如果是很多层可以使用 Infinity 来全部展开成一维数组
  ```
    let a = [1,[2],[3,4,[8,9]]]
    let b = a.flat()   // [1,2,3,4,[8,9]]
    let c = a.flat(2)  // [1,2,3,4,8,9]
    let d = a.flat(Infinity) // [1,2,3,4,8,9]
  ```
- Array.form()
  会将类数组或是可迭代的对象转换成数组，有两个参数，第一个参数为类数组对象或可迭代的对象(必填)，第二个参数则是改变转换成数组元素的函数。
  类数组对象具有 length 属性以及索引化 index 的元素，可迭代对象表示具有可以利用迭代的方式取得它自己本身的元素，如 Map 和 Set
  ```
    let a = 'abcd'
    Array.from(a) // ['a','b','c','d']
    let obj = {
      '0':12,
      '2':11,
      '1':10,
      length:3
    }
    let objb = Array.from(obj) // [12,11.10]
  ```
- Array.of()
  可以快速将数字、字符串等内容，转换成数组。
  ```
    let a = Array.of(1,'q',3)
    a // [1,'q',3]
  ```
- toString()
  会把整个数组转换成字符串
  ```
    let a = [1,2,3,4]
    a.toString() // '1,2,3,4'
  ```

### 布尔判断

`every() some() includes() Array.isArray()`

- every()
  会将数组中的每一个元素带入指定的函数内部进行判断，只要有一个元素不符合判断条件,会返回 false，如果全部符合，就会返回 true

  ```
    let a = [1,2,3,4,5]
    a.every((e) => e > 3)   // false
    a.every((e) => e > 0)   // true
  ```

- some()
  会将数组中的每一个函数放入指定的函数内部做判断，只要有任何一个符合判断条件，就会返回 true,如果全部不符合，才会返回 false。

  ```
   let a = [1,2,3,4]
   a.some((e) => e > 3)  // true
   a.some((e) => e > 4)  // false
  ```

- includes()
  会判断数组中是否包含某个值，如果包含就返回 true 否则返回 false。有两个参数，第一个参数表示要判断的值，第二个参数是表示从数组的哪个位置开始判断。

  ```
    let a = [1,2,3,4,5,6]
    a.includes(2)     // true
    a.includes(2,2)   // false
  ```

- Array.isArray()
  Array.isArray() 能判断一个元素是否为数组，如果是就返回 true,不然就返回 false。

  ```
    let a = [1,2,3]
    Array.isArray(a)  // true
    Array.isArray(124) // false

  ```

## 其他

` valueOf() keys`

- valueOf()
  会返回数组的原始值，如果数组原本有修改，返回的原始值也会跟着改变(相当于浅复制)

  ```
    let a = [1,2,3,4,5]
    let b = a.valueOf()   // [1,2,3,4,5]
    let c = a.valueOf()
    a.shift()
    b  // [2,3,4,5]
    c  // [2,3,4,5]
  ```

- keys
  keys 会返回数组中的每一个索引值(key) 成一个新的 Array Iterator 对象，可以用 for of 进行迭代
  ```
    let a = [1,2,3,4,5,6]
    let b = a.keys()
    for(let key of b){
      console.log(key)    // 1,2,3,4,5,6
    }
  ```

## Oject

### 创建

- new 构造函数法

  ```
    var person = new Object()
    person.name = '张三';
    person.age = 25
  ```

- 对象字面量

  ```
    var person = {
      name:'张三',
      age: 25
    }
  ```

### 属性和方法

- constructor
  constructor 属性是保存当前对象的构造函数

  ```
  var obj1 = new Object()
  obj1.id = 'obj1'
  var obj2 = {
    id:'obj2'
  }
  obj1.constructor // function Object(){}
  obj2.constructor // function Object(){}

  ```

- hasOwnProperty('属性名字') 方法
  该方法接收一个字符串参数(属性名)，用来判断该属性是否是当前对象实例中，而不是来自对象的原型链中。

  ```
    var obj = {
      name:'ddd'
    }
    obj.hasOwnProperty('name')      // true
    obj.hasOwnProperty('toString')  // false
  ```

- toLocaleString() 方法
  该方法返回对象的字符串表示，和代码的执行环境有关。
  ```
    var obj = {}
    obj.toLocalString()    // '[object object]'
  ```
- toString() 方法
  返回对象的字符串表示
  ```
    var obj = {}
    obj.toString()  // '[object object]'
  ```
- valueOf() 方法
  该方法返回对象的原始值。可能是字符串、数值或者布尔值。

  ```
    var obj = {
      name:'obj'
    }
    var arr = [1]
    var bool = new Boolean(1)
    var date = new Date()

    obj.valueOf()     // Object {name:'obj'}
    arr.valueOf()     // [1]
    bool.valueOf()    // true
    data.valueOf()    // 145556666666

  ```

### 属性的类型

在 JavaScript 中，属性有两种类型，分别是数据属性和访问器属性

#### 数据属性

数据属性可以理解为我们平时定义对象赋予的属性，可以进行读和写。但在 ES5 中定义了一些特性，这些特性用来描述属性的各种特征，特性是内部值，不能直接访问。需要通过 Object.defineProperty 方法来修改。

- [[Configurable]]
  该特性表示是否可以通过 delete 操作符来删除属性，默认值为 true。

  ```
    var obj = {
      name:'obj',
      age:25
    }
    obj.name         // obj
    delete obj.name
    obj.name         // undefined
    Object.defineProperty(obj,'age',{
      configurable:false
    })
    obj.age          // 25
    delete obj.age
    obj.age          // 25
  ```

  通过 configurable 特性设置成 false 之后，delete 就无法删除 age 属性，如果是在严格模式下，使用 delete 去删除就会报错。

- [[Enumerable]]
  表示是否能够通过 for in 语句来枚举出属性。默认是 true

  ```
    var obj = {
      name:'objName'
    }
    for( var key in obj){
      console.log(key)      // name
    }

    Object.defineProperty(obj,'constructor',{
      enumerable:true
    })

    for ( var key in obj){
      console.log(key)       // name constructor
    }

  ```

- [[Writable]] 和 [[Value]]
  Writable：表示属性值是否可以修改，默认为 true，若设为 false，修改属性值的时候没有效果，在严格模式下会报错。
  Value：表示属性的值，默认为 undefined
  ```
    var obj = {
      name:'name'
    }
    obj.name // name
    Object.defineProperty(obj,'name',{
      value:'newVlaue',
      writable:false
    })
    obj.name  // newValue
    obj.name = 'oldValue'
    obj.name // newValue
  ```

#### 访问器属性

[[get]] 读取属性时调用的函数,[[st]] 给属性设置值的时候调用的函数

```
  var person = {
    age:15
  }
  Object.defineProperty(person,'type',{
    get:function(){
      if(person.age>17){
        return '成人'
      }
      return '小孩'
    }
  })
  person.type // 小孩
  person.age = 20
  person.type // 成人
```

## Function

函数的本身就是对象。函数是第一类对象。
第一类对象又称第一类公民。具有的的特性

- 能够作为参数被传递。
- 能够从一个函数结果中返回。
- 能够被修改和赋值给变量。
  `在js 里函数也是对象，可以拥有自己的属性和方法，而它和一般js对象的区别是：可以被调用，即可以执行。`

### 创建

函数创建方法:`函数定义表达式、函数声明语句和 new Function()`

```
// 函数声明
function fun() {

}
// 函数表达式
var  fun = function() {

}
// new Function
var  fun1 = new Function()
```

- 变量提升
  JavaScript 中由 var 关键字声明的变量存在变量提升：将变量声明提升到作用域的顶部，但赋值仍保留在原处。函数表达式和函数声明有本质的区别。

  - 函数声明语句
    将函数声明和函数的赋值都提升到作用域的顶部，在同一个作用域中可以出现调用在函数之前。
  - 函数表达式
    与 var 声明的普通变量相同，只是将变量声明提升到作用域顶部，但赋值仍然留在原处，不能在定义前使用

  ```
    fun()                       // 函数声明
    fun1()                      // undefined
    function fun() {
      var name = '函数声明'
      console.log(name)
    }
    var fun1 = function() {
      var name = '函数表达式'
      console.log(name)
    }
    fun()                     // 函数声明
    fun1()                    // 函数表达式
  ```

### 函数的调用

在定义函数时，函数体中的代码不会执行，只有在调用函数时，才会执行函数体中的语句。函数的调用方式有四种

#### 作为普通函数

使用调用表达式来调用普通函数，每个调用表达式由多个函数表达式组成。每个函数表达式包括函数对象、括号和传入的实参组成。

- 每次调用会拥有本次调用的上下文 this；在 ES5 非严格模式下，普通函数的 this 值是全局对象；在严格模式下是 undefined
- 以函数形式调用的函数通常不使用 this 关键字
- 如果函数没有显式 return 语句返回一个值，默认返回 undefined
- 传入的实参是由逗号分隔的 0 个或多个函数表达式

  ```
    function printPrps(o) {
      for(var prop in o) {
        console.log(prop + ": " + o[prop] + "\n");
      }
      console.log(this)   // window
    }
    printPrps({x:1})      // x:1

  ```

#### 作为对象的方法

方法是保存在 JavaScript 对象中的函数

- 对方法调用的参数和返回值处理与函数调用相同
- 方法调用由两部分组成：`对象.属性名()`，其中属性名是值为函数的属性
- 方法调用中：调用上下文指调用方法的对象，使用 this 关键字引用
  ```
    var obj ={
      num1: 12,
      num2: 11,
      add: function() {
        this.result = this.num1 + this.num2
      }
    }
    obj.add()   // 调用 add 方法
    obj.result  // 23
  ```

#### 作为构造器函数

函数或者方法调用前有关键字 new，函数或者方法便作为构造函数来调用。构造函数会创建一个新对象，新对象继承构造函数的 prototype 属性。
作为构造函数的调用，会将新创建的对象作为其调用上下文(this 指向新创建的对象)，在构造函数中使用 this 引用新创建的对象。

#### 使用函数的 call() 和 apply() 方法间接调用

函数是对象，每个函数都有 call() 和 apply() 两个方法，作用是改变函数运行时的上下文--改变函数体内部 this 的指向。
call()和 apply()作用都是动态改变函数体内 this 指向。只是接受参数形式不太一样。
call() 需要将参数按顺序传递进函数，并且知道参数的数量。
apply() 将参数放在数组中传进函数。(参数数量不确定时使用)

### 函数的实参和形参

实参和形参是相对的概念，在函数定义时指定的参数叫做形参；在函数调用时传入的参数叫做实参。对于需要省略的实参，可以使用 null 或 undefined 作为占位符。

#### 参数对象

函数体内，标识符 argument 指向实参对象的引用，实参对象是一个类数组对象，可以通过下标访问每个传入的参数。

- callee 和 caller 属性。
  callee 是 ECMAScript 规范中 arguments 对象的属性：代表当前正在执行的函数。
  caller 是非标准的，只是浏览器基本实现了这个属性：代表调用当前函数的函数。
  在严格模式中，对这个两个属性读写都会产生错误。

### 闭包

闭包在 JavaScript 中，指内部函数总是可以访问其所在的外部函数中声明的变量和参数，即是外部函数被返回(调用结束)。

```
  var scope = 'global scope'
  function checkScope() {
    var scope = 'local scope'
    function f() { return scope}
    return f
  }
  checkScope()()
```

- 在 Js 中，每个函数在定义时会创建一个与之相关的作用域链，并且在程序执行期间一直存在
  外部函数有自身的作用域链，内部函数有自身单独的作用域链。
- 每次调用函数都会创建一个新对象来保存参数和局部变量，并将其添加到作用域链。
  - 当函数返回时，将绑定的新对象从作用域链上删除。如果没有其他变量引用该对象、或该对象没有保存在某个对象的属性中，它会被当做垃圾回收。
  - 如果没有外部变量引用，调用函数时创建的临时对象，函数 return 后便被垃圾回收。
- 如果 checkScope 定义有嵌套函数 f,并将 f 作为返回值保存在某个对象的属性中。相当于有一个外部引用指向嵌套函数。

JavaScript 中的函数，通过作用域和词法作用域两者的特性，将该函数定义时所处的作用域中的相关函数进行补货和保存，从而可以在完全不同的上下文中进行引用。

## Data

# 引用类型与原始类型的区别

### 声明变量时不同的内存分配

- 原始值：存储在栈内存(stack) 中的简单数据段，即他们的值直接存储在变量访问的位置。
- 引用值：存储在堆内存中，栈内存中存储的是该对象的指针，指向存储对象的内存地址
  为什么引用类型的值不能放在栈中，引用类型的值大小会发生改变，放在栈内存中会降低变量查询的速度。

### 访问机制

- 原始类型，值是可以直接访问
- 引用类型，访问一个对象时，首先得到的是这个对象在内存中的地址，然后再按照这个地址去获得这个对象中的值，即`按应用访问`

### 复制变量

- 原始类型：将保存原始值的变量复制给另一个变量时，会将原始值的副本赋值给新变量，此后这两个变量是完全独立的。
- 引用类型：是将内存地址赋值给新变量，即这两个变量都指向同一个堆内存中的同一个对象，任何一个改变都会反映在另一个身上。

### 传递参数

ECMAScript 中所有的函数的参数都是`按值传递`。
但是涉及到原始和引用类型的值时是有差异的，因为内存分配时的差异。

- 原始值：把变量的值传递给参数，之后参数和这个变量互不影响。
- 引用值：传递的值是内存地址，所以在函数内部对参数修改会体现在外部，因为他们指向的是同一个对象。
