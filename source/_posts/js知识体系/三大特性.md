---
title: [js知识体系, js 语言的三大特性]
categories: [js知识体系, js 语言的三大特性]
---

## 封装

  JavaScript 是一种基于对象的语言，我们所遇到的东西几乎都是对象。
  在 JS中，封装的过程就是把一些属性和方法放到对象中 "包裹" 起来，
  封装：就是把事务封装成类，隐藏事物的属性和方法的实现细节，仅对外公开接口。
  封装的好处：使用封装，可以达到代码的复用，使代码更加简洁
  `将属性和方法组成一个类的过程就是封装`

  - 通过构造函数添加
    JavaScript 提供了一个构造函数模式，用来创建对象时初始化对象
  
  ```
    functuon Cat(name,color) {
      this.name = name
      this.colot = color
      this.eat = ( () => {
        console.log('🐟')
      })
    }
    // 生成实例
    var cat1 = new Cat('tom','gray')
  ```
  - 通过原型 prototype 封装
  
  ```
    function Cat(name,color) {
      this.name = name
      this.color = color
    }
    Cat.prototype.type = '英短'
    Cat.prototype.eat = ( () => {
      alert('🐟')
    })
    // 生成实例
    var cat1 = new Cat('Tom','gray')
    var cat2 = new Cat('Kobe','purple')
    console.log(cat1.type)
    cat2.eat()

  ```



## 继承

继承：我们想要一个对象能够访问另一个对象的属性，同时，这个对象还能够添加新的属性或者覆盖可访问的另一个对象的属性。
继承就是子类可以使用父类的所有功能，并且对这些功能进行扩展。

  - 类式继承
    就是使用原型的方式，将方法添加在父类的原型上，然后子类的原型是父类的一个实例化对象
  ```
    // 声明父类
    var SuperClass = function() {
      let id = 1
      this.name = ['java']
      this.superValue = function() {
        console.log('this is superValue')
      }
    }
    // 为父类添加共有方法
    SuperClass.prototype.getSuperVlaue = function() {
      return this.superValue()
    }
    // 声明子类
    var SubClass = function() {
      this.subValue = (() => {
        console.log('this is subValue)
      })
    }
    // 继承父类
    SubClass.prototype = new SuperClass()
    // 为子类添加共有方法
    SubClass.prototype.getSubValue = function(){
      return this.subValue()
    }
    // 生成实例
    var sub1 = new SubClass()
    var sub2 = new SubClass()
    sub1.getSuperValue() // this is superValue
    sub1.getSubValue()   // this is subValue

    console.log(sub1.id)   // undefined
    console.log(sub1.name) // ['java']

    sub1.name.push('php')
    console.log(sub1.name) //['java','php']
    console.log(sub1.name) //['java','php']
  
  ```

  `使用类继承的方法缺陷，如果父类的构造函数中有引用数据类型，就会在子类中被所有实例共用，因此一个子类的实例如果更改了这个引用数据类型，就会影响到其他子类的实例`

  - 构造函数继承
    构造函数继承的核心思想就是 直接改变this的指向，使通过this创建的属性和方法在子类中复制一份，因为是单独复制，所以各个实例的子类互不影响。但是会造成内存浪费的问题。
  ```
  // 声明父类
    function SuperClass(id) {
      var name = 'js'
      this.languages = ['JavaScript','Python']
      this.id = id
    }

  // 声明子类
    function SubClass(id) {
      SuperClass.call(this,id)
    }

  // 生成实例
    var sub1 = new SubClass(1)
    var sub2 = new SubClass(2)

    console.log(sub2.id)   // 2
    console.log(sub2.name) // undefined
  
    sub1.languages.push('node') 
    console.log(sub1.languages)  // ['JavaScript','Python','node']
    console.log(sub2.languages)  // ['JavaScript','Python']

  ```
  - 组合继承 
    组合继承是汲取了类继承和构造函数继承的优点，即避免了内存浪费，又使得每个实例化的子类互不影响
  ```
    // 声明父类

    function SuperClass(name) {
      this.languages = ['js','python']
      this.name = name
    }
  
    // 声明父类原型方法
    SuperClass.prototype.showlangs = function (){
      console.log(this.languages)
    }
    
    // 声明子类
    function SubClass(name){
      SuperClass.call(this,name)
    }

    // 子类继承父类(链式继承)
    SubClass.prototype = new SuperClass()

    // 生成实例
    var sub1 = new SubClass('node')
    var subw = new SubClass('go')
    
    sub2.showlangs()  // ['js','python']
    sub1.languages.push(sub1.name)
    sub1.languages    // ['js','python','node']
    sub.languages     // ['js','python','go']
  ```
  `组合继承的问题，父类的构造函数会被创建两次，一次是call的时候，一次是new的时候`

  - 寄生组合继承
  
  ```
  // 原型式继承
    function inheritObject(o){
      // 声明一个过度函数
      function F() {}
      F.prototype = 0
      return new F()
    }
  // 寄生式继承
    function inheritPrototype(subClass,superClass){
      var p = inheritObject(superClass.prototype)
      p.constructor = subClass
      subClass.prototype = p
    }
  
  // 定义父类
    function SuperClass(name) {
      this.name = name
      this.languages = ['js']

    }
  
  // 定义父类原型方法
    SuperClass.prototype.showLangs = function() {
      console.log(this.languages)
    }
  
  // 定义子类
    function SubClass(name) {
      SuperClass.call(this.name)
    }
    inheritPrototype(SubClass, SuperClass);
    var sub1 = new SubClass('go');
  ```
## 多态

  多态：同一操作作用于不同的对象，可以用不同的解释，产生不同的执行结果。本质上就是将做什么和谁去做以及怎么做分开，就是消除不同对象的耦合关系。
