<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>有理想的笛子</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="有理想的笛子">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="有理想的笛子">
<meta property="og:locale" content="zh">
<meta property="article:author" content="sxhMxd">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="有理想的笛子" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">有理想的笛子</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-浏览器渲染涉及的知识/http" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/05/27/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E6%B6%89%E5%8F%8A%E7%9A%84%E7%9F%A5%E8%AF%86/http/" class="article-date">
  <time datetime="2021-05-27T06:47:53.305Z" itemprop="datePublished">2021-05-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E6%B6%89%E5%8F%8A%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9/">浏览器渲染涉及的知识点</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/05/27/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E6%B6%89%E5%8F%8A%E7%9A%84%E7%9F%A5%E8%AF%86/http/">HTTP 知识</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="什么是-HTTP"><a href="#什么是-HTTP" class="headerlink" title="什么是 HTTP"></a>什么是 HTTP</h2><p>超文本传输协议，是一个基于请求与响应，无状态的，应用层的协议，常基于 TCP/IP 协议传输数据，互联网上应用最为广泛的一种网络协议，所有的 WWWW 文件都必须遵守这个标准。</p>
<h2 id="HTTP-的基本优化"><a href="#HTTP-的基本优化" class="headerlink" title="HTTP 的基本优化"></a>HTTP 的基本优化</h2><p>影响一个　HTTP网络请求的因素主要有两个带宽和延迟<br>　＿带宽＿：当我们停留在拨号上网的阶段，带宽可能会成为一个比较严重影响请求的问题。<br>　＿延迟＿：<br>    - 浏览器阻塞：浏览器对于同一个域名，同时只能有4 个连接，超过浏览器最大数限制，后续请求就会被阻塞。<br>    - DNS 查询：浏览器需要知道目标服务器的IP 才能建立连接。将域名解析为IP。通常可以利用DNS缓存结果来达到减少查询的时间的目的。<br>    - 建立链接：HTTP 是基于TCP 协议的，浏览器最快也要在第三次握手时才能捎带 HTTP 请求报文，达到真正的建立连接。但是这些连接无法复用会导致每次请求都经历三次握手和慢启动。三次握手在高延迟的场景下影响比较明显，慢启动则对文件类请求影响较大。</p>
<h2 id="HTTP-1-0-和-HTTP-1-1-的区别"><a href="#HTTP-1-0-和-HTTP-1-1-的区别" class="headerlink" title="HTTP 1.0  和 HTTP 1.1 的区别"></a>HTTP 1.0  和 HTTP 1.1 的区别</h2><p>http 1.1 是当前使用最为广泛的 HTTP 协议。主要区别是：<br>    - 缓存处理：在HTTP 1.0 中主要使用header 里的 if-Modified-Since,Expires 来作为缓存判断的标准。http 1.1 则引入更多的缓存控制策略 例如：Entity tag if-Unmodified-Since,if-Match,if-None-Match等更多可供选择的缓存头来控制缓存策略。<br>    - 带宽优化及网络连接的使用，http 1.1 在请求头引入 rang 头域，它允许只请求资源的某个部分，方便开发者自由的选择以便于充分利用带宽和连接。<br>    - 错误通知的管理，在 http 1.1 中新增了24个错误状态响应码。<br>    - Host头处理：在HTTP 1.0 中认为每台服务器都绑定一个唯一的ip地址，因此，请求消息中的 URL 并没有传递主机名。因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）<br>    - 长连接：HTTP1.1支持长连接 和请求的流水线处理，在一个TCP连接上可以传送多个 HTTP 请求和响应，减少了建立和关闭连接的消耗和延迟，在 HTTP1.1中默认开启Connection:keep-alive,一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。</p>
<h2 id="HTTPS与HTTP的一些区别"><a href="#HTTPS与HTTP的一些区别" class="headerlink" title="HTTPS与HTTP的一些区别"></a>HTTPS与HTTP的一些区别</h2><pre><code>- HTTPS 协议需要到CA申请证书，
- HTTP 协议运行在TCP之上，所有传输的内容都是明文，HTTPS 运行在 SSL/TLS之上，SSL/TLS运行在TCP 之上，所有传输的内容都经过加密的。
- HTTP 和 HTTPS 使用的是完全不同的连接方式，用的端口也不一样。
- HTTPS可以有效的防止运营商劫持。</code></pre><h3 id="什么是多路复用"><a href="#什么是多路复用" class="headerlink" title="什么是多路复用"></a>什么是多路复用</h3><p>多路复用：通过单一的 HTTP/2链接请求发起多重的请求-响应消息，多个请求stream 共享一个TCP连接，实现</p>
<h2 id="http-状态码"><a href="#http-状态码" class="headerlink" title="http 状态码"></a>http 状态码</h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2021/05/27/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E6%B6%89%E5%8F%8A%E7%9A%84%E7%9F%A5%E8%AF%86/http/" data-id="cksjtyq9f003to0dxehsfc7c7" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-渲染流水线" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/05/27/%E6%B8%B2%E6%9F%93%E6%B5%81%E6%B0%B4%E7%BA%BF/" class="article-date">
  <time datetime="2021-05-27T06:40:29.237Z" itemprop="datePublished">2021-05-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/05/27/%E6%B8%B2%E6%9F%93%E6%B5%81%E6%B0%B4%E7%BA%BF/">渲染流水线</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="渲染流水线"><a href="#渲染流水线" class="headerlink" title="渲染流水线"></a>渲染流水线</h2><p><img src="https://raw.githubusercontent.com/wqxc/Picture/main/chrome/image-20210519171828121.png" alt></p>
<h3 id="加载主页面"><a href="#加载主页面" class="headerlink" title="加载主页面"></a>加载主页面</h3><p>加载主页面，调用网络进程，下载HTML文件。</p>
<p>下载完成之后，渲染进程解析HTML，而后构建DOM。</p>
<p>在解析HTML的时候，浏览器会预先下载HTML文件内需要的JS资源和CSS资源。</p>
<p>这里JS会阻塞DOM的解析，必然也会影响渲染吗，</p>
<p>另外的，JS的执行，需要CSSOM构建完毕之后才能执行，</p>
<p>所以CSS会阻塞JS的执行，JS会阻塞DOM的解析，所以，CSS也间接的会阻塞DOM的解析，这里的阻塞不是必然的，是一种可能性。</p>
<p>CSS会阻塞浏览器的渲染。</p>
<p>所以，CSS放在最前边，JS放在最后边。</p>
<h3 id="构建DOM"><a href="#构建DOM" class="headerlink" title="构建DOM"></a>构建DOM</h3><p>HTML文件浏览器是不认识的，需要转换为浏览器能够处理的结构 ———— <strong>DOM</strong></p>
<h3 id="样式计算"><a href="#样式计算" class="headerlink" title="样式计算"></a>样式计算</h3><p>样式计算是在CSS文件获取完成之后进行的，主要作用是计算出每一个DOM节点中，每一个元素的样式，这个过程分为下图所示的三样：</p>
<p><img src="https://raw.githubusercontent.com/wqxc/Picture/main/chrome/image-20210519171905175.png" alt="样式计算"></p>
<h5 id="第一，将CSS文件转换为浏览器能识别的形式—styleSheets"><a href="#第一，将CSS文件转换为浏览器能识别的形式—styleSheets" class="headerlink" title="第一，将CSS文件转换为浏览器能识别的形式—styleSheets"></a>第一，将CSS文件转换为浏览器能识别的形式—styleSheets</h5><p>CSS样式来源主要有三种：1、<style> 标签内的CSS。 2、link标签引入的。3、内嵌入HTML标签的CSS</p>
<p>CSS文件，和HTML文件一样，浏览器本身是理解不了的，需要将其转换为浏览器可以理解的结构—styleSheets。 styleSheets 也叫做 CSSOM</p>
<h5 id="第二，转换样式表中的属性值，使其标准化"><a href="#第二，转换样式表中的属性值，使其标准化" class="headerlink" title="第二，转换样式表中的属性值，使其标准化"></a>第二，转换样式表中的属性值，使其标准化</h5><p>比如，CSS中又很多 2rem,blue,bold 值。</p>
<p>就需要将其标准化为一个值，比如 2rem 就是  32px，blue 被解析为rgb, bold被解析为700.</p>
<h5 id="第三，计算出DOM树中每个节点的具体样式"><a href="#第三，计算出DOM树中每个节点的具体样式" class="headerlink" title="第三，计算出DOM树中每个节点的具体样式"></a>第三，计算出DOM树中每个节点的具体样式</h5><p>这里涉及CSS的继承规则和层叠规则。</p>
<p>首先是CSS继承，CSS继承就是每个DOM节点都包含有父节点的样式。比如，html设定了font-size:20px.</p>
<p>其他的文本，没有设定 font-size 就会默认继承 html的字体。</p>
<p>层叠规则主要是根据CSS权重来处理。</p>
<p>样式计算阶段的目的是为了计算出DOM节点中，每个元素的具体样式，根据CSS的继承和层叠两个规则。</p>
<h3 id="布局阶段"><a href="#布局阶段" class="headerlink" title="布局阶段"></a>布局阶段</h3><p>到了现在，我们有了DOM树和CSSOM树，有了元素，有了样式，唯一缺少的是DOM元素的几何信息，接下来要做的就是计算出DOM树中 <strong>可见元素</strong> 的位置信息。</p>
<p>布局阶段，主要完成两件是 <strong>创建布局树</strong> 和 <strong>布局计算</strong></p>
<h5 id="创建布局树"><a href="#创建布局树" class="headerlink" title="创建布局树"></a>创建布局树</h5><p>DOM树种包含了很多不可见的元素，比如head标签，display：none 属性的元素，所以还要额外的构建一棵可见元素的布局树。</p>
<p>核心是遍历DOM树，可见的就放在布局树上，不可见的就放弃。</p>
<h5 id="布局计算"><a href="#布局计算" class="headerlink" title="布局计算"></a>布局计算</h5><p>计算布局树的坐标位置，这个过程很复杂。</p>
<p>计算完成之后，每一个元素的几何坐标信息就存储在布局树中。</p>
<p>这时候，布局树就包含了布局的多数信息。</p>
<h3 id="分层"><a href="#分层" class="headerlink" title="分层"></a>分层</h3><p>布局阶段，计算了元素的位置信息，按道理来说，有了元素，有了元素的位置信息，已经可以绘制页面了，但是，直接进行绘制的话，会有很大的性能问题，这里，浏览器做了另外的操作  ————  <strong>分层</strong></p>
<p>为什么要分层？</p>
<p>页面上会有很多的效果，比如 3D变换，页面的滚动，横向的元素运动等。</p>
<p>如果所有的元素，在一个层面内，元素的变化必然引整个页面的重新布局计算。</p>
<p>而分层就可以解决这个问题，将这些变换的元素单独的分为一层，一些特殊的效果在这些层上去做，将影响降为最小。</p>
<p>最终，将多个分层合并在一起，最终合成一个页面，展示出来。</p>
<p>分层阶段，渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的———— <strong>图层树</strong></p>
<h5 id="如何成为一层"><a href="#如何成为一层" class="headerlink" title="如何成为一层"></a>如何成为一层</h5><p>第一：拥有层叠上下文属性的元素会被单独提升为一层</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">position: absolute|releative  并且 z-index值不为auto</span><br><span class="line">flex 容器的子元素  z-index 不为auto</span><br><span class="line">grid 容器的子元素，z-index不为auto</span><br><span class="line">opacity 属性值小于<span class="number">1</span> </span><br><span class="line">transform/filter 等属性值不为none</span><br><span class="line"></span><br><span class="line">如上，拥有这些属性的元素被称之为拥有层叠上下文属性</span><br></pre></td></tr></table></figure>



<p>第二：需要裁剪的地方会被创建为图层,举个例子</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">    div &#123;</span><br><span class="line">        width: <span class="number">200</span>;</span><br><span class="line">        height: <span class="number">200</span>;</span><br><span class="line">        overflow: auto;</span><br><span class="line">        background: gray;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;<span class="regexp">/style&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;body&gt;</span></span><br><span class="line"><span class="regexp">    &lt;div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;p&gt; 所以元素有了层叠上下文的属性或者需要被剪裁，那么就会被提升成为单独一层，你可以参看下</span></span><br><span class="line"><span class="regexp">        &lt;p&gt; 从上图我们可以看到，document 层上有 A 和 B 层，而 B 层之上又有两个图层。这些图层组</span></span><br><span class="line"><span class="regexp">        &lt;p&gt; 图层树是基于布局树来创建的，为了找出哪些元素需要在哪些层中，渲染引擎会遍历布局树来创</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/body&gt;</span></span><br></pre></td></tr></table></figure>

<p>如上所示，div宽高都是200，超出之后浏览器会自动滚动。出现这种剪裁情况的时候，渲染引擎会为文字部分单独创建一个层，出现滚动的话，滚动条会被提升为单独的层。</p>
<p><img src="https://raw.githubusercontent.com/wqxc/Picture/main/chrome/image-20210520114909460.png" alt="分层"></p>
<p>如上图文字被单独提升为一层，有滚动的情况下，滚动条也会被单独提升为一层。</p>
<p>到这里，分层完成，分层树构建完成。接下来就是绘制</p>
<h3 id="图层绘制"><a href="#图层绘制" class="headerlink" title="图层绘制"></a>图层绘制</h3><p>渲染引擎会把一个图层的绘制拆分成很多的小的 <strong>绘制指令</strong>，然后再把这些指令按照顺序组成一个待绘制列表。</p>
<p><img src="https://raw.githubusercontent.com/wqxc/Picture/main/chrome/image-20210520120237554.png" alt="绘制列表"></p>
<p>图层绘制阶段，输出的内容就是这些待绘制的列表。</p>
<h3 id="栅格化"><a href="#栅格化" class="headerlink" title="栅格化"></a>栅格化</h3><p>绘制列表记录的是绘制顺序，和绘制指令的列表，真正的绘制操作是由渲染引擎中的<strong>合成线程</strong>来完成的。</p>
<p>渲染引擎可以认为是一个进程，从加载页面到计算样式再到布局阶段再到分层都是运行在主线程上的。</p>
<p><img src="https://raw.githubusercontent.com/wqxc/Picture/main/chrome/image-20210520142913259.png" alt="渲染进程"></p>
<p>如图所示，当图层的绘制列表准备好之后，主线程会把改绘制列表  <strong>提交（commit）</strong>给合成线程.</p>
<h3 id="光栅化"><a href="#光栅化" class="headerlink" title="光栅化"></a>光栅化</h3><p>合成线程，首先是要注意一个概念 ———— <strong>视口</strong></p>
<h5 id="视口"><a href="#视口" class="headerlink" title="视口"></a>视口</h5><p>视口就是用户能看到的一部分，一个页面可能很大，大到超出当前的屏幕，有时候需要滚动很久才能到底部，用户能看到的就是屏幕那么大的空间。</p>
<p>如果一个页面很大，完全绘制的话是没有意义的，毕竟用户都看不到，性能开销也很大。</p>
<h5 id="图块"><a href="#图块" class="headerlink" title="图块"></a>图块</h5><p>图块是栅格化执行的最小单位。</p>
<p>合成线程会将图层划分为图块，一般这些图块大小都是256x256 或者是 512x512</p>
<p><img src="https://raw.githubusercontent.com/wqxc/Picture/main/chrome/image-20210520145517614.png" alt="分块"></p>
<p>如图，每一个小块儿就是图块，黑色框就是视口，或者是叫做屏幕，当前需要展示的图块就是 红线画的那些。</p>
<p>视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的，栅格化是指将图块转换为位图。</p>
<p>渲染进程维护了一个栅格化线程池，所有的图块栅格化都是在线程池内执行的，如下：</p>
<p><img src="https://raw.githubusercontent.com/wqxc/Picture/main/chrome/image-20210520151012247.png" alt="渲染进程"></p>
<p>记得一点，栅格化线程将图块转换为位图。一般这个过程会有GPU的参与，用来快速的栅格化，GPU栅格化的位图都保存在GPU中。</p>
<p>GPU是运行在GPU进程中的，这里使用了GPU来快速栅格化，就涉及到跨进程操作了。</p>
<p>操作的流程如下所示：</p>
<p><img src="https://raw.githubusercontent.com/wqxc/Picture/main/chrome/image-20210520152755253.png" alt="加GPU进程"></p>
<p>这里虽然也叫做栅格化，但是和前边我们说额栅格化不是一回事，比较常见的说法这里的栅格化也可以叫做光栅化。</p>
<h5 id="位图"><a href="#位图" class="headerlink" title="位图"></a>位图</h5><p>位图也叫做点阵图，像素图，光栅图等。</p>
<p>由被称作像素的单个点组成的，这些点可以进行不同的排列组合，比如使用RGB编码，用红绿蓝三原色的光学强度来表示一种颜色</p>
<p>比如 RGB(0,0,0) 表示一个黑色的块儿，不同的RGB拼接在一起就可以形成一幅画。</p>
<p>最常见的，比如 色盲图谱，一个个的点会组成不同的图像或者是数字，这些也可以称之为位图。</p>
<h3 id="合成"><a href="#合成" class="headerlink" title="合成"></a>合成</h3><p>光栅化的最后就生成位图，每一个图层对应一个位图或者是一张图片，最后这些图片会根据层叠的顺序合并为一张图片。</p>
<p>最终生成的图片发送到后缓冲区。</p>
<p>简单的来说，一旦所有的图块都被光栅化了，合成线程就会生成一个绘制图块的命令，该命令会被提交给浏览器进程。</p>
<p>浏览器进程里的有专门的组件来接收这个命令，而后负责将页面内容绘制到内存中。</p>
<h3 id="显示"><a href="#显示" class="headerlink" title="显示"></a>显示</h3><p>页面的显示依靠的是显示器，显示器显示图像的核心是显卡，显示器上的页面（其实是图片）来自于显卡的一个叫做  <strong>前缓冲区</strong>  的地方。</p>
<p>显示器要做的事情很简单，就是每秒钟读取60张图片，并将读取的图片显示在浏览器上。</p>
<h5 id="显卡的职责"><a href="#显卡的职责" class="headerlink" title="显卡的职责"></a>显卡的职责</h5><p>显卡的职责就是不断的合成新的图像，并保存在 <strong>后缓冲区</strong> ，一旦写入完成，系统就会让前后缓冲区对调，保证显示器总是读取最新的图像。一般而言，显卡的更新频率和显示器的刷新频率是一致的，但是，有些时候，在一些复杂的场景中，显卡处理图片会很慢，就会造成卡顿。</p>
<h5 id="帧和帧率"><a href="#帧和帧率" class="headerlink" title="帧和帧率"></a>帧和帧率</h5><p>渲染流水线生成的一张图片，被称之为一帧，每秒钟渲染流水线制造了多少张图片，被称之为帧率。</p>
<p>如果渲染引擎生成某些帧的时间过长了，用户就会觉得卡顿。</p>
<h5 id="如何生成一帧图像"><a href="#如何生成一帧图像" class="headerlink" title="如何生成一帧图像"></a>如何生成一帧图像</h5><p>有三种方式来生成一帧图像</p>
<p>第一：重排</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">首先说说第一种，在首次加载一个网站的时候，这三种方式都会被使用。</span><br><span class="line"></span><br><span class="line">重排很简单，就是修改了元素的几何信息，比如朝DOM里添加一个元素，或者是删除一个元素等，都会触发重排，继而生成一帧图像，这个过程需要 重新构建布局树，而后的渲染阶段都要重新来一遍，这个过程是很耗性能的</span><br></pre></td></tr></table></figure>



<p>第二： 重绘</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">重绘不会影响布局阶段，操作效率要比重排要高一些，但是，依旧需要计算绘制信息，触发绘制操作之后的所有操作。 包括 绘制 分块，光栅化，合成，显示等</span><br></pre></td></tr></table></figure>



<p>第三：合成</p>
<p>在合成线程中完成的任务都不会涉及图层内容的改变，一般都是图层的运动操作，比如滚动，动画，旋转等。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">相对而言，合成的效率就明显高了很多，合成操作不需要触发布局和绘制操作，而且合成是在合成线程上运行的，不会阻塞主线程，如果合成还采用了GPU的话，效率就更高了。</span><br><span class="line">.box &#123;</span><br><span class="line"> will-change: transform, opacity;</span><br><span class="line"> &#125;</span><br><span class="line">如上，这是告诉渲染进程这个元素要做一些比较秀的操作，transform 或者是 opacity，渲染引擎将该元素单独实现为一层，等变换发生的时候，渲染引擎会通过合成线程直接去处理变换，这些变换并没有涉及到主线程，就大大的提升了渲染的效率。</span><br><span class="line"></span><br><span class="line">但是，虽然will-change 好用，但是用的多了也会影响效率的。</span><br></pre></td></tr></table></figure>





<p>最后来一张总结的图</p>
<p><img src="https://raw.githubusercontent.com/wqxc/Picture/main/chrome/image-20210520181235864.png" alt="全部的渲染"></p>
</style></p>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2021/05/27/%E6%B8%B2%E6%9F%93%E6%B5%81%E6%B0%B4%E7%BA%BF/" data-id="cksjtyq6e0021o0dxbna254fh" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-element使用不常用方法总结/element使用不常用方法总结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/04/22/element%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/element%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/" class="article-date">
  <time datetime="2021-04-22T07:57:57.324Z" itemprop="datePublished">2021-04-22</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/element%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/">element使用不常用方法总结</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/04/22/element%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/element%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/">element使用不常用方法总结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="el-table-相同列进行合并"><a href="#el-table-相同列进行合并" class="headerlink" title="el-table  相同列进行合并"></a>el-table  相同列进行合并</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">  &lt;el-table</span><br><span class="line">      :data&#x3D;&quot;tableDataqingkaung&quot;</span><br><span class="line">      border</span><br><span class="line">      style&#x3D;&quot;width: 100%&quot;</span><br><span class="line">      :span-method&#x3D;&quot;objectSpanMethod&quot;</span><br><span class="line">      :row-class-name&#x3D;&quot;tableRowClassName&quot;</span><br><span class="line">    &gt;</span><br><span class="line">      &lt;el-table-column label&#x3D;&quot;ID&quot; prop&#x3D;&quot;date&quot; width&#x3D;&quot;100&quot; align&#x3D;&quot;center&quot;&gt;</span><br><span class="line">      &lt;&#x2F;el-table-column&gt;</span><br><span class="line">      &lt;el-table-column</span><br><span class="line">        label&#x3D;&quot;供电分区代码&#x2F;影响区域&quot;</span><br><span class="line">        prop&#x3D;&quot;options&quot;</span><br><span class="line">        align&#x3D;&quot;center&quot;</span><br><span class="line">        width&#x3D;&quot;300&quot;</span><br><span class="line">      &gt;</span><br><span class="line">        &lt;template slot-scope&#x3D;&quot;scope&quot;&gt;</span><br><span class="line">          &lt;span v-html&#x3D;&quot;scope.row.options&quot;&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;&#x2F;template&gt;</span><br><span class="line">      &lt;&#x2F;el-table-column&gt;</span><br><span class="line"></span><br><span class="line">      &lt;el-table-column label&#x3D;&quot;行车调整原则&quot; prop&#x3D;&quot;rules&quot;&gt;</span><br><span class="line">        &lt;template slot-scope&#x3D;&quot;scope&quot;&gt;</span><br><span class="line">          &lt;span v-html&#x3D;&quot;scope.row.rules&quot;&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;&#x2F;template&gt;</span><br><span class="line">      &lt;&#x2F;el-table-column&gt;</span><br><span class="line">    &lt;&#x2F;el-table&gt;</span><br><span class="line">&#x2F;*</span><br><span class="line">* data 传入的参数</span><br><span class="line">* rules 判断的属性值</span><br><span class="line">*&#x2F;</span><br><span class="line">  getSpanArr(data) &#123;</span><br><span class="line">      this.spanArr &#x3D; []</span><br><span class="line">      for (var i &#x3D; 0; i &lt; data.length; i++) &#123;</span><br><span class="line">        if (i &#x3D;&#x3D;&#x3D; 0) &#123;</span><br><span class="line">          this.spanArr.push(1);</span><br><span class="line">          this.pos &#x3D; 0</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          &#x2F;&#x2F; 判断当前元素与上一个元素是否相同  inAccessCode（批次字段）</span><br><span class="line">          if (data[i].rules &#x3D;&#x3D; data[i - 1].rules) &#123;</span><br><span class="line">            this.spanArr[this.pos] +&#x3D; 1;</span><br><span class="line">            this.spanArr.push(0);</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            this.spanArr.push(1);</span><br><span class="line">            this.pos &#x3D; i;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    objectSpanMethod(&#123; row, column, rowIndex, columnIndex &#125;) &#123;</span><br><span class="line">      if (columnIndex &#x3D;&#x3D;&#x3D; 2) &#123;  &#x2F;&#x2F; 指定那一列进行合并</span><br><span class="line">        const _row &#x3D; this.spanArr[rowIndex];</span><br><span class="line">        const _col &#x3D; _row &gt; 0 ? 1 : 0;</span><br><span class="line">        return &#123;</span><br><span class="line">          rowspan: _row,</span><br><span class="line">          colspan: _col</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2021/04/22/element%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/element%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/" data-id="cksjtyq7g0024o0dxcf0dd9kc" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-项目遇到的奇怪问题/elementUI奇怪问题解决办法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/04/22/%E9%A1%B9%E7%9B%AE%E9%81%87%E5%88%B0%E7%9A%84%E5%A5%87%E6%80%AA%E9%97%AE%E9%A2%98/elementUI%E5%A5%87%E6%80%AA%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/" class="article-date">
  <time datetime="2021-04-22T07:52:09.127Z" itemprop="datePublished">2021-04-22</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/elementUI%E5%A5%87%E6%80%AA%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/">elementUI奇怪问题解决办法</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/04/22/%E9%A1%B9%E7%9B%AE%E9%81%87%E5%88%B0%E7%9A%84%E5%A5%87%E6%80%AA%E9%97%AE%E9%A2%98/elementUI%E5%A5%87%E6%80%AA%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/">elementUI奇怪问题解决办法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="el-tabs-切换窗口或者重新编译会有蓝色阴影"><a href="#el-tabs-切换窗口或者重新编译会有蓝色阴影" class="headerlink" title="el-tabs 切换窗口或者重新编译会有蓝色阴影"></a>el-tabs 切换窗口或者重新编译会有蓝色阴影</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 需要在全局添加以下样式</span><br><span class="line">.el-tabs__item:focus.is-active.is-focus:not(:active) &#123;</span><br><span class="line">    -webkit-box-shadow: none !important;</span><br><span class="line">    box-shadow: none !important;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2021/04/22/%E9%A1%B9%E7%9B%AE%E9%81%87%E5%88%B0%E7%9A%84%E5%A5%87%E6%80%AA%E9%97%AE%E9%A2%98/elementUI%E5%A5%87%E6%80%AA%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/" data-id="cksjtyq83002oo0dxdsos2vfp" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-面试/浏览器缓存" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/04/22/%E9%9D%A2%E8%AF%95/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/" class="article-date">
  <time datetime="2021-04-22T07:51:22.477Z" itemprop="datePublished">2021-04-22</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a>►<a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/">浏览器缓存</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/04/22/%E9%9D%A2%E8%AF%95/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/">浏览器缓存</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="浏览器缓存机制"><a href="#浏览器缓存机制" class="headerlink" title="浏览器缓存机制"></a>浏览器缓存机制</h1><h2 id="为什么要使用缓存"><a href="#为什么要使用缓存" class="headerlink" title="为什么要使用缓存"></a>为什么要使用缓存</h2><p>缓存是性能优化中简单高效的一种优化方式。一个优秀的缓存策略可以缩短网页请求资源的距离，减少延迟，并且由于缓存文件可以重复利用，还可以减少带宽，降低网络负载。</p>
<p>对于一个数据请求来说，可以分为发起网络请求、后端处理、浏览器响应三个步骤。浏览器缓存可以帮我们在发起网络请求和浏览器响应优化性能。例如 直接使用缓存而不发起请求，或者发起请求但后端存储的数据和前端一致，那就没有必要将数据回传回来，这样就减少了响应数据。</p>
<h2 id="缓存位置"><a href="#缓存位置" class="headerlink" title="缓存位置"></a>缓存位置</h2><p>从缓存位置上来说分为四种，并且各自有优先级，当依次查找缓存且都没有命中的时候，才会去请求网络。<br>Service Worker<br>Memory Cache<br>Disk Cache<br>Push Cache</p>
<h3 id="Service-Worker"><a href="#Service-Worker" class="headerlink" title="Service Worker"></a>Service Worker</h3><p>是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。使用 Service Worker 的话，传输协议必须为 HTTPS。因为 Service Worker 中涉及到请求拦截，所以必须使用 HTTPS 协议来保障安全。它可以让我们自由控制缓存哪些文件，如何匹配缓存，如何读取缓存，并且缓存是持续性的。</p>
<ul>
<li>实现缓存功能的步骤<ul>
<li>首先注册 Service Worker</li>
<li>监听到 install 事件以后就可以缓存文件，在下次用户访问的时候就可以通过拦截请求的方式查询是否存在缓存，存在缓存的话就可以直接读取缓存文件，否则就去请求数据</li>
<li>当没有命中缓存的时候，我们需要去调用 fetch 函数获取数据。会根据缓存查找优先级去查找数据，但是不管是从 Memory Cache 中还是网络请求中获取的数据，浏览器都会显示我们是从 Service Worker 中获取的内容。</li>
</ul>
</li>
</ul>
<h3 id="Memory-Cache"><a href="#Memory-Cache" class="headerlink" title="Memory Cache"></a>Memory Cache</h3><p><code>Memory Cache</code> 是内存中的缓存，主要包含的是当前页面中已经抓取到的资源。eg:页面样式、脚本、图片等。</p>
<ul>
<li>内存缓存的特点<br>内存缓存读取高效，但是缓存持续性很短，会随着进程的释放而释放。<code>一旦关闭 Tab 页面，内存中的缓存也就被释放了。</code> 计算的内存容量小，所以缓存不能全部放在内存中。<br>注意点：<code>内存缓存在缓存资源时并不关心返回资源的 HTTP 缓存头 Cache-Control是什么值，同时资源的匹配也并非仅仅是对 URL 做匹配，还可能会对 Content-Type，CORS 等其他特征做校验。</code></li>
</ul>
<h3 id="Disk-Cache"><a href="#Disk-Cache" class="headerlink" title="Disk Cache"></a>Disk Cache</h3><p>Disk Cache 也就是存储在硬盘中的缓存，读取速度慢，但是什么都可以存储到硬盘中。<br>在所有浏览器缓存中，Disk Cache 覆盖面是最大的，它会根据 HTTP Herder 中的字段判断哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源已经过期需要重新请求，并且即使在跨站点的情况下，相同地址的资源一旦被硬盘缓存下来，就不会再次去请求数据。</p>
<h3 id="Push-Cache"><a href="#Push-Cache" class="headerlink" title="Push Cache"></a>Push Cache</h3><p>Push Cache (推送缓存) 是 HTTP/2 中的内容，Service Worker Memory Cache Disk Cache 三种缓存都没有命中的时，才会使用。Push Cache 只在会话中存在，一旦会话结束就被释放，并且缓存时间也很短暂。在 Chome 浏览器中只有五分钟左右，同时它也并非严格执行 HTTP 头中的缓存指令。</p>
<ul>
<li>所有的资源都能被推送并且能够被缓存，但是 Edge 和 Safari 浏览器支持相对比较差</li>
<li>可以推送 no-cache 和 no-store 的资源</li>
<li>一旦连接关闭，Push Cache 就释放</li>
<li>多个页面可以使用同一个 HTTP/2 连接，也就是可以使用同一个 Push Cache</li>
<li>Push Cache 中的缓存只能被使用一次</li>
<li>浏览器可以拒绝接受已经存在的资源推送</li>
<li>可以给其他域名推送资源</li>
</ul>
<p>如果以上四种缓存都没有命中的话，那么就只能发起请求来获取资源。为了性能上的考虑，大部分的接口都应该选择好缓存策略，<code>通常浏览器缓存策略分为两种：强缓存和协商缓存，并且缓存策略都是通过设置 HTTP Header 来实现</code></p>
<h2 id="缓存过程分析"><a href="#缓存过程分析" class="headerlink" title="缓存过程分析"></a>缓存过程分析</h2><p>浏览器和服务器的通讯方式为应答模式，即浏览器发起 HTTP 请求-服务器响应该请求，<code>那么浏览器怎么确定一个资源该不该缓存，如何去缓存呢？</code>浏览器第一次向服务器发起该请求后拿到请求结果后，将请求结果和缓存标识存入浏览器缓存，<code>浏览器对于缓存的处理是根据第一次请求资源时返回的响应头来确定的。</code></p>
<p><img src="https://upload-images.jianshu.io/upload_images/3174701-de3d6e025582103a?imageMogr2/auto-orient/strip%7CimageView2/2/w/670/format/webp" alt="发起请求"></p>
<ul>
<li>浏览器每次发起请求，都会在浏览器缓存中查找该请求的结果以及缓存标识</li>
<li>浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存中。</li>
</ul>
<h2 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h2><p>强缓存：不会向服务器发送请求，直接从缓存中读取资源，在 chorme 控制台中可以看到该请求返回 200 的状态码，并且 Size 显示 from disk cache 或 from memory cache 。强缓存可以通过设置两种 HTTP Header 实现： Expires 和 Cache-Control</p>
<h3 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h3><p><code>缓存过期时间，用来指定资源到期的时间，是服务器端的具体的时间点</code>。也就是说 Expires= max-age + 请求时间，需要和 Last-modified 结合使用。<code>Last-Modified</code>是服务器认为文件的最后修改时间，是第一次请求文件的时候，服务器返回的一个属性。<br>Expires 是 Web 服务器响应消息头字段，在响应 http 请求时告诉浏览器在过期时间前浏览器可以直接从缓存取数据，而无需再次请求</p>
<p>Expires 是 Http/1 的产物，受限于本地时间，如果修改了本地时间，可能会造成缓存失效。</p>
<h3 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h3><p>Cache-Control 是最重要的规则，主要用于控制网页缓存。可以在请求头或者响应头中设置。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3174701-8ff981603cdfded0?imageMogr2/auto-orient/strip%7CimageView2/2" alt="Cache-Control"></p>
<ul>
<li><p>public</p>
<ul>
<li>所有内容都将被缓存(客户端和代理服务器都可缓存)。响应可被任何中间节点缓存，</li>
<li>Browser &lt;– proxy1 &lt;– proxy2 &lt;– server 中间的 proxy 可以缓存。</li>
</ul>
</li>
<li><p>private</p>
<ul>
<li>所有内容只有客户端可以缓存，cache-control 的默认取值。具体来说，表示中间节点不允许缓存</li>
<li>对于 Browser &lt;– proxy1 &lt;– proxy2 &lt;– server，proxy 会把 server 返回的数据发送给 proxy1，自己不缓存任何数据，当下次浏览器再次请求时 proxy 会做好请求转发而不是自作主张给自己缓存的数据。</li>
</ul>
</li>
<li><p>no-cache</p>
<ul>
<li>客户端缓存内容，是否使用缓存则需要经过协商缓存来验证决定。表示不使用 Cache-Control 的缓存控制方式做前置验证，而是使用 Etag 或者 Last-Modified 字段来控制缓存。</li>
</ul>
</li>
<li><p>no-store</p>
<ul>
<li>所有的内容都不会被缓存，即不使用强制缓存，也不使用协商缓存。</li>
</ul>
</li>
<li><p>max-age</p>
<ul>
<li>max-age=xxx 表示缓存内容将在 xxx 秒后失效。</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/3174701-3fa81f5e9efac5af?imageMogr2/auto-orient/strip%7CimageView2/2" alt></p>
</li>
</ul>
<h3 id="Expires-和-Cache-Control-两者对比"><a href="#Expires-和-Cache-Control-两者对比" class="headerlink" title="Expires 和 Cache-Control 两者对比"></a>Expires 和 Cache-Control 两者对比</h3><p>Expires 是 http1.0 的产物，Cache-Control 是 Http1.1 的产物，<code>两者同时存在的话，Cache-Control优先级高于Expires</code>。<br>强缓存判断是否缓存的依据是来自于是否超出某个时间或者某个时间段，而不关心服务器端文件是否已经更新，这就可能会导致加载文件不是服务器端最新的内容。此时我们需要用协商缓存策略。</p>
<h2 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h2><p><code>协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程</code></p>
<ul>
<li>协商缓存生效，返回 304 和 Not Modified</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/3174701-660fd163329d080b?imageMogr2/auto-orient/strip%7CimageView2/2/w/709/format/webp" alt="协商缓存生效"></p>
<ul>
<li>协商缓存失效，返回 200 和请求结果<br><img src="https://upload-images.jianshu.io/upload_images/3174701-24953079cfebf2bf?imageMogr2/auto-orient/strip%7CimageView2/2/format/webp" alt="协商缓存失效"><br>协商缓存可以通过设置 HttP Header 实现：Last-Modified 和 ETag</li>
</ul>
<h3 id="Last-Modified-和-If-Modified-Since"><a href="#Last-Modified-和-If-Modified-Since" class="headerlink" title="Last-Modified 和 If-Modified-Since"></a>Last-Modified 和 If-Modified-Since</h3><p>浏览器在第一次访问资源时，服务器返回资源的同时，在 response header 中添加 Last-Modified 的 header,值是这个资源在服务器上的最后修改时间。<br>浏览器下次请求这个资源，浏览器检测到有 Last-Modified 这个 header，于是 添加 If-Modified-Since header 值就是 Last-Modified 中的值；服务器再次收到这个资源的请求，会根据 If-Modified-Since 中的值与服务器中这个资源的最后修改时间做对比，如果没有变化，返回 304 和空的响应体，直接从缓存中读取，如果 If-Modified-Since 的时间小于服务器中资源最后修改时间，说明文件有更新于是返回新的资源文件和 200</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3174701-bb7148a4431ccda1?imageMogr2/auto-orient/strip%7CimageView2/2/w/438/format/webp" alt></p>
<p>弊端：</p>
<ul>
<li>如果只是在本地打开文件，没有对文件进行修改，但是还是会造成 Last-Modified 被修改，服务器不能命中缓存</li>
<li>Last-Modified 只能以秒计时，如果在不可感知的时间内修改文件，服务器会认为会命中缓存</li>
</ul>
<p>根据文件修改时间来决定是否缓存存在问题，可以直接根据文件内容是否修改来决定缓存策略</p>
<h3 id="ETag-和-If-None-Match"><a href="#ETag-和-If-None-Match" class="headerlink" title="ETag 和 If-None-Match"></a>ETag 和 If-None-Match</h3><p>ETag 是服务器响应请求时，返回当前资源文件的一个唯一标识(Hash 值 由服务器生成)，只要资源有变化。ETag 就会重新生成。在下一次加载资源向服务器发送请求时，会将上次返回的 ETag 值放到 request header 里的 If-None-Match 里，服务器比较客户端传过来的 If-None-Match 跟自己服务器上该资源的 ETag 是否一致。就可以判断资源是不是最新的</p>
<p>Last-Modified 和 ETag 的对比</p>
<ul>
<li>精确度<br>Etag 要优于 Last-Modifed，Last-Modified 的时间单位是秒，如果资源在一秒内改变多次，Last-Modified 其实并不能体现出来，如果是负载均衡的服务器各个服务器生成的 Last-Modified 也有可能不一致。 ETag 每次都会改变确保了精确度。</li>
<li>性能上<br>ETag 要逊于 Last-Modified ，last-Modified 只需要记录时间，ETag 需要服务器通过算法来计算一个 hash 值。</li>
<li>优先级<br>服务器校验优先考虑 ETag</li>
</ul>
<h2 id="缓存机制"><a href="#缓存机制" class="headerlink" title="缓存机制"></a>缓存机制</h2><p>强缓存优先于协商缓存，若强缓存(Expires 和 Cache-Control) 生效则直接使用缓存，若不生效则进行协商缓存(Last-Modified/If-Modified-since 和 ETag/If-None-Match)，协商缓存由服务器决定是否使用缓存，若协商缓存失效，则缓存失效，返回 200 重新返回资源和缓存标识，再存入浏览器缓存中，生效则返回 304 继续使用缓存<br><img src="https://upload-images.jianshu.io/upload_images/3174701-9d9e8b52a18ed35a?imageMogr2/auto-orient/strip%7CimageView2/2/w/519/format/webp" alt></p>
<h2 id="实际场景应用缓存策略"><a href="#实际场景应用缓存策略" class="headerlink" title="实际场景应用缓存策略"></a>实际场景应用缓存策略</h2><h3 id="频繁变动的资源"><a href="#频繁变动的资源" class="headerlink" title="频繁变动的资源"></a>频繁变动的资源</h3><p>Cache-Control:no-cache<br>对于频繁变动的资源，首先需要使用 Cache-Control:no-cache 使浏览器每次都请求服务器，然后配合 ETag 或者 Last-Modified 来验证资源是否有效。这样的作法虽然不能节省请求数量，但是可以显著减少响应数据的大小</p>
<h3 id="不常变动的资源"><a href="#不常变动的资源" class="headerlink" title="不常变动的资源"></a>不常变动的资源</h3><p>Cache-Control:max-age = 31356000</p>
<p>通常处理这类资源时，给他们的 Cache-Control 配置一个很大的 max-age= 31536000(一年)，这样浏览器之后请求相同 Url 会命中强制缓存。而为了解决更新的问题，就需要在文件名中添加 hash 版本号等动态字符，之后更改为动态字符，从而达到更改引用 URL 的目的让之前的强制缓存失效(其实并未立即消失，只是暂时不再使用而已)</p>
<h2 id="用户行为对浏览器缓存的影响"><a href="#用户行为对浏览器缓存的影响" class="headerlink" title="用户行为对浏览器缓存的影响"></a>用户行为对浏览器缓存的影响</h2><p>指的就是用户再浏览器操作时，会触发怎样的缓存策略。主要有三种</p>
<ul>
<li>打开网页，地址输入 URL:查找 <code>disk cache</code> 中是否有匹配。如有则使用，没有则发送网络请求。</li>
<li>普通刷新(F5) 因为 tab 页没有关闭，因此 <code>memory cache</code>是可用的，会被优先使用(如果匹配的话)，其次才是 disk cache</li>
<li>强制刷新( Ctrl + F5): 浏览器不使用缓存，因此发送请求的头部均带有 <code>Cache-control:no-cache</code> ( 为了兼容，还带了 Pargam:no-cache),服务器直接返回 200 和最新内容。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2021/04/22/%E9%9D%A2%E8%AF%95/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/" data-id="cksjtyq81002mo0dxe2nm6ppd" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-面试/从URL输入到页面展示" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/04/22/%E9%9D%A2%E8%AF%95/%E4%BB%8EURL%E8%BE%93%E5%85%A5%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%A4%BA/" class="article-date">
  <time datetime="2021-04-22T07:51:22.476Z" itemprop="datePublished">2021-04-22</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a>►<a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95/%E4%BB%8EURL%E8%BE%93%E5%85%A5%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%8E%B0%E6%B6%89%E5%8F%8A%E7%9A%84%E7%9F%A5%E8%AF%86%E3%80%82/">从URL输入到页面展现涉及的知识。</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/04/22/%E9%9D%A2%E8%AF%95/%E4%BB%8EURL%E8%BE%93%E5%85%A5%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%A4%BA/">从URL输入到页面展现涉及的知识。</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>总体分为六个过程</p>
<ul>
<li>DNS 解析：将域名解析成 IP 地址</li>
<li>TCP 连接：TCP 三次握手</li>
<li>发送 HTTP 请求</li>
<li>服务器处理请求并返回 HTTP 报文</li>
<li>浏览器解析渲染页面</li>
<li>断开连接：TCP 四次挥手</li>
</ul>
<h1 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h1><p>URL (Unifrom Resource Locator)，统一资源定位符，用于定位互联网上资源，俗称网址。</p>
<ul>
<li><p>遵循的语法规则<br>scheme://host.domain:port/path/filename</p>
<ul>
<li>scheme - 定义因特网服务的类型。常见的协议有 http、https、ftp、file 其中最常见的类型是 http，而 https 则是进行加密的网络传输。</li>
<li>host - 定义域主机(http 的默认主机是 www)</li>
<li>domain - 定义因特网<code>域名</code>，eg: w3school.com.cn</li>
<li>port - 定义主机上的端口号 (http 的默认端口号是 80)</li>
<li>path - 定义服务器上的路径 (如果省略，则文档必须位于网站的根目录中)</li>
<li>filename - 定义文档/资源的名称</li>
</ul>
</li>
<li><p>URL 编码</p>
<p>URL 只能使用 ASCII 字符集，不属于 ASCII 中的字符，都必须进行编码才能使用 URL 来进行表示，若传输时使用了特殊字符会造成不必要的问题，导致服务器不能解析。</p>
<ul>
<li>编码方法<br>使用 JavaScript 中 3 对方法进行 URL 的 编码/解码 <code>escape/unescape，encodeURI/decodeURI 和encodeURIComponent/decodeURIComponent</code>,<br>三者适用场合不同，<code>encodeURI</code> 用于对整个 URI 进行编码 <code>encodeURIComponent</code> 被用于对 URI 的一部份进行编码，通常是指查询字符串或路径。</li>
</ul>
</li>
</ul>
<h1 id="域名解析-DNS"><a href="#域名解析-DNS" class="headerlink" title="域名解析 (DNS)"></a>域名解析 (DNS)</h1><p>在浏览器输入网址后，首先要经过域名解析，浏览器并不能直接通过域名找到对应的服务器，而是通过 IP 地址</p>
<h2 id="IP-地址"><a href="#IP-地址" class="headerlink" title="IP 地址"></a>IP 地址</h2><p>IP 地址是指互联网协议地址，是 IP Address 的缩写。 IP 地址是 IP 协议提供的一种统一的地址格式，它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。Ip 地址是一个 32 位的二进制数。</p>
<p><code>域名相当于 IP 地址乔装打扮的伪装者，带着一副面具。作用就是便于记忆和沟通的一组服务器的地址。</code>与 Ip 地址的一组纯数字相比，用字母配合数字的表示形式来指定计算机名更符合人类的记忆习惯，但要计算机去理解就相对变得的困难，为了解决这个问题,DNS 服务器应运而生。</p>
<h2 id="什么是域名解析"><a href="#什么是域名解析" class="headerlink" title="什么是域名解析"></a>什么是域名解析</h2><p>DNS 协议提供通过域名查找 IP 地址，或逆向从 IP 地址反查域名的服务，DNS 是一个网络服务器，我们的域名解析简单来说就是在 DNS 上记录一条信息。</p>
<h2 id="浏览器如何通过域名去查询-URL-对应的-IP"><a href="#浏览器如何通过域名去查询-URL-对应的-IP" class="headerlink" title="浏览器如何通过域名去查询 URL 对应的 IP"></a>浏览器如何通过域名去查询 URL 对应的 IP</h2><ul>
<li>浏览器缓存：浏览器会按照一定的频率缓存 DNS 记录。</li>
<li>操作系统缓存：如果浏览器缓存中找不到需要的 DNS 记录，那就从操作系统中找。</li>
<li>路由缓存： 路由器也有 DNS 缓存。</li>
<li>ISP 的 DNS 服务器：ISP 是互联网提供商 (Internet Service Provider)的简称，ISP 有专门的 DNS 服务器应对 DNS 查询请求。</li>
<li>根服务器：ISP 的 DNS 服务器还找不到的话，它就会向根服务器发出请求，进行递归查询 (DNS 服务先问根域名服务器.com 域名服务器的 IP 地址，然后再问 .baidu 域名服务器，依次类推)</li>
</ul>
<p><code>浏览器通过向 DNS 服务器发送域名，DNS 服务器查询到与域名相对应的 IP 地址，然后返回给浏览器，浏览器再将 IP 地址打在协议上，同时请求参数也会在协议搭载，然后一并发送给对应的服务器。</code></p>
<h1 id="TCP-三次握手"><a href="#TCP-三次握手" class="headerlink" title="TCP 三次握手"></a>TCP 三次握手</h1><p>三次握手其实就是指建立一个 TCP 连接时，需要客户端和服务器端总共发送三个包。进行三次握手的主要目的是为了确认双方的接收能力和发送能力是否正常，指定自己的初始化序列号为后面的可靠性传送做准备。<br>在客户端发送数据之前会发起 TCP 三次握手用以同步客户端和服务端的序列号和确认号，并交换 TCP 窗口大小信息。</p>
<h3 id="握手过程"><a href="#握手过程" class="headerlink" title="握手过程"></a>握手过程</h3><p>刚开始客户端处于 closed 的状态，服务器处于 Listen 状态。</p>
<ul>
<li>第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN。此时客户端处于 SYN_Send 状态</li>
<li>第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 作为应答，并且也是指定了自己的初始化序列号 ISN，同时会把客户端的 ISN+1 作为 ACK 的值，表示已经收到了客户端的 SYN，此时服务器处于 SYN_REVD 的状态</li>
<li>第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，把服务器 ISN+1 作为 ACK 的值。表示已经收到了服务端的 SYN 报文，此时客户端处于 establised 状态。</li>
<li>服务器收到 ACK 报文之后，也处于 establised 状态。<br><img src="https://user-gold-cdn.xitu.io/2019/4/10/16a074b331fb0d85?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt></li>
</ul>
<p>注意点：解释一下为啥只有三次握手才能确认双方的接受与发送能力是否正常，而两次却不可以：<br>第一次握手：客户端发送网络包，服务端收到了。这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。<br>第二次握手：服务端发包，客户端收到了。这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。<br>第三次握手：客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。</p>
<h1 id="发送-HTTP-请求"><a href="#发送-HTTP-请求" class="headerlink" title="发送 HTTP 请求"></a>发送 HTTP 请求</h1><p>http 请求报文由请求行(request line)、请求头(header)、请求体、空行(blank line)四部分组成。</p>
<ul>
<li>请求行包含请求方法、URL、协议版本<ul>
<li>请求方法包含 8 种:get、post、put、delete、patch、head、options、trace<ul>
<li>get 请求<br>数据是英文字母/数字，原样发送；如果是空格，转换为 + ；如果是中文/其他字符，则直接把字符串用 BASE64 加密,得出：%E4%BD，其中%XX 中的 XX 为该字符号以 16 进制表示的 ASCII。</li>
<li>post 请求</li>
</ul>
</li>
<li>URL 即请求地址，由&lt;协议&gt;://&lt;主机&gt;:&lt;端口&gt;/&lt;路径&gt;?&lt;参数&gt; 组成</li>
<li>协议版本即 http 版本号。</li>
</ul>
</li>
<li>请求头包含请求附加信息，由关键字/值对组成每行一对，关键字和值用英文冒号分隔。<br>请求头部通知服务器有关于客户端请求的信息。它包含许多有关的客户端环境和请求正文的有用信息。eg:host，表示主机名，使用 keepalive,即持久连接，一个连接可以发多个请求；</li>
<li>请求体，可以承载多个请求参数的数据，包含回车符、换行符、和请求数据。</li>
</ul>
<p><img src="https://segmentfault.com/img/bVQL82?w=594&h=232" alt="http请求报文格式"></p>
<h1 id="服务器处理请求并返回-HTTP-报文"><a href="#服务器处理请求并返回-HTTP-报文" class="headerlink" title="服务器处理请求并返回 HTTP 报文"></a>服务器处理请求并返回 HTTP 报文</h1><h2 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h2><p>服务器是网络环境中的高性能计算机，它侦听网络上的其他计算机(客户机)提交的服务请求，并提供响应的服务，eg:网页服务、文件下载、邮件服务、视频服务。客户端的主要功能是浏览网页、看视频、等等两者截然不同。每台服务器上都会安装处理请求的应用————web server .<br><code>web server 担任管控的角色</code>，对于不同用户发送的请求，会结合配置文件，把不同请求委托给服务器上处理相应请求的程序进行处理，然后返回后台程序处理产生的结果作为响应。</p>
<h1 id="浏览器解析渲染页面"><a href="#浏览器解析渲染页面" class="headerlink" title="浏览器解析渲染页面"></a>浏览器解析渲染页面</h1><p>浏览器解析渲染页面分为五个步骤</p>
<ul>
<li>根据 HTML 解析出 DOM 树</li>
<li>根据 CSS 解析生成 CSS 规则树</li>
<li>结合 DOM 树和 CSS 规则树，生成渲染树</li>
<li>根据渲染树计算每一个节点是信息</li>
<li>根据计算好的信息绘制页面</li>
</ul>
<h2 id="根据-HTML-解析出-DOM-树"><a href="#根据-HTML-解析出-DOM-树" class="headerlink" title="根据 HTML 解析出 DOM 树"></a>根据 HTML 解析出 DOM 树</h2><ul>
<li>根据 HTML 的内容，将标签按照结构解析成为 DOM 树，DOM 树解析的过程是一个深度优先遍历。即先构建当前节点的所有子节点，再构建下一个兄弟节点。</li>
<li>在读取 HTML 文档，构建 DOM 树的过程中，若遇到 script 标签，则 DOM 树的构建会暂停，直至脚本执行完毕。</li>
</ul>
<h2 id="根据-CSS-解析生成-CSS-规则树"><a href="#根据-CSS-解析生成-CSS-规则树" class="headerlink" title="根据 CSS 解析生成 CSS 规则树"></a>根据 CSS 解析生成 CSS 规则树</h2><ul>
<li>解析 CSS 规则树时 js 执行将暂停，直至 CSS 规则树就绪。</li>
<li>浏览器在 CSS 规则树生成之前不会进行渲染。</li>
</ul>
<h2 id="结合-DOM-树和-CSS-规则树，生成渲染树"><a href="#结合-DOM-树和-CSS-规则树，生成渲染树" class="headerlink" title="结合 DOM 树和 CSS 规则树，生成渲染树"></a>结合 DOM 树和 CSS 规则树，生成渲染树</h2><ul>
<li>DOM 树和 CSS 规则树全部准备好了以后，浏览器才开始构建渲染树。</li>
<li>精简 CSS 并可以加快 CSS 规则树的构建，从而加快页面相应速度。</li>
</ul>
<h2 id="根据渲染树计算每一个节点的信息-布局"><a href="#根据渲染树计算每一个节点的信息-布局" class="headerlink" title="根据渲染树计算每一个节点的信息(布局)"></a>根据渲染树计算每一个节点的信息(布局)</h2><ul>
<li>布局：通过渲染树中渲染对象的信息，计算出每一个渲染对象的位置和尺寸。</li>
<li>回流：在布局完成后，发现了某个部分发生了变化影响了布局，那就需要倒回去重新渲染。</li>
</ul>
<h2 id="根据计算好的信息绘制页面"><a href="#根据计算好的信息绘制页面" class="headerlink" title="根据计算好的信息绘制页面"></a>根据计算好的信息绘制页面</h2><ul>
<li>绘制阶段：系统会遍历呈现树，并调用呈现器的”paint”方法，将呈现器的内容显示在屏幕上。</li>
<li>重绘：某个元素的背景颜色，文字颜色等，不影响元素周围或内部布局的属性，将只会引起浏览器的重绘。</li>
<li>回流：某个元素的尺寸发生了变化，则需要重新计算渲染树，重新渲染。</li>
</ul>
<h1 id="断开连接"><a href="#断开连接" class="headerlink" title="断开连接"></a>断开连接</h1><p>当数据传送完毕，需要断开 tcp 连接，此时发起 tcp 四次挥手。</p>
<ul>
<li>发起方向被动方发送报文，Fin、Ack、Seq，表示已经没有数据传输了。并进入 FIN_WAIT_1 状态。(第一次挥手：由浏览器发起的，发送给服务器，我请求报文发送完了，你准备关闭吧)</li>
<li>被动方发送报文，Ack、Seq，表示同意关闭请求。此时主机发起方进入 FIN_WAIT_2 状态。(第二次挥手：由服务器发起的，告诉浏览器，我请求报文接受完了，我准备关闭了，你也准备吧)</li>
<li>被动方向发起方发送报文段，Fin、Ack、Seq，请求关闭连接。并进入 LAST_ACK 状态。(第三次挥手：由服务器发起，告诉浏览器，我响应报文发送完了，你准备关闭吧)</li>
<li>发起方向被动方发送报文段，Ack、Seq。然后进入等待 TIME_WAIT 状态。被动方收到发起方的报文段以后关闭连接。发起方等待一定时间未收到回复，则正常关闭。(第四次挥手：由浏览器发起，告诉服务器，我响应报文接受完了，我准备关闭了，你也准备吧)</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2021/04/22/%E9%9D%A2%E8%AF%95/%E4%BB%8EURL%E8%BE%93%E5%85%A5%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%A4%BA/" data-id="cksjtyq7y002jo0dx2gh4383d" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-面试/作用域-作用域链" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/04/22/%E9%9D%A2%E8%AF%95/%E4%BD%9C%E7%94%A8%E5%9F%9F-%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/" class="article-date">
  <time datetime="2021-04-22T07:51:22.476Z" itemprop="datePublished">2021-04-22</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a>►<a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95/%E4%BD%9C%E7%94%A8%E5%9F%9F-%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/">作用域-作用域链</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/04/22/%E9%9D%A2%E8%AF%95/%E4%BD%9C%E7%94%A8%E5%9F%9F-%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/">作用域-作用域链</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h1><p>作用域是运行时代码的某些特定部分中变量，函数和对象的可访问性。即作用域决定了代码区块中变量和其他资源的可见性。<br>函数作用域在函数定义的时候就决定了。函数内部有个内部属性[[scope]],当函数创建的时候，就会保存所有父变量对象到其中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function outFun2()&#123;</span><br><span class="line">  var inVariable &#x3D; &#39;内层变量2&#39;</span><br><span class="line">&#125;</span><br><span class="line">outFun2()</span><br><span class="line">console.log(inVariable)  &#x2F;&#x2F; Uncaught ReferenceError: inVariable is not defined</span><br></pre></td></tr></table></figure>

<p>作用域最大的用处是隔离变量，不同作用域下同名变量不会有冲突。Es6 之前 JavaScript 没有块级作用域，只有全局作用域和函数作用域。</p>
<h2 id="全局作用域和函数作用域"><a href="#全局作用域和函数作用域" class="headerlink" title="全局作用域和函数作用域"></a>全局作用域和函数作用域</h2><ul>
<li><p>最外层的函数和在最外层函数外面定义的变量拥有全局作用域</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var outVariable &#x3D; &#39;我是最外层变量&#39;</span><br><span class="line">function outFun() &#123;</span><br><span class="line">  var inVariable &#x3D; &#39;内层变量&#39;;</span><br><span class="line">  function innerFun() &#123;</span><br><span class="line">    console.log(inVariable)</span><br><span class="line">  &#125;</span><br><span class="line">  innerFun()</span><br><span class="line">&#125;</span><br><span class="line">console.log(outVariable)   &#x2F;&#x2F; 我是外层变量</span><br><span class="line">outFun()                   &#x2F;&#x2F; 内层变量</span><br><span class="line">console.log(inVariable)    &#x2F;&#x2F; inVariable is not defined</span><br><span class="line">innerFun()                 &#x2F;&#x2F; innerFun is not defined</span><br></pre></td></tr></table></figure></li>
<li><p>所有未定义直接赋值的变量自动声明为拥有全局作用域</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function outFun2()&#123;</span><br><span class="line">  variable &#x3D; &#39;未定义直接赋值的变量&#39;;</span><br><span class="line">  var inVariable2 &#x3D; &#39;内层变量2&#39;</span><br><span class="line">&#125;</span><br><span class="line">outFun2()</span><br><span class="line">console.log(variable)      &#x2F;&#x2F; 未定义直接赋值的变量</span><br><span class="line">console.log(inVariable2)   &#x2F;&#x2F; inVariable2 is not defined</span><br></pre></td></tr></table></figure>
</li>
<li><p>所有 window 对象的属性拥有全局作用域<br>一般情况下，window 对象的内置属性都拥有全局作用域，eg:window.name、window.location 等。</p>
</li>
</ul>
<p>全局作用域有个弊端：如果我们写了很多行 JS 代码，变量定义都没有用函数包括，那么他们就全部都在全局作用域中。这样就会污染全局命名空间，容易起命名冲突。</p>
<p>注意：全局作用域在页面打开时被创建，页面关闭时被销毁。</p>
<h2 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a>函数作用域</h2><p>函数作用域，是指声明在函数内部的变量，和全局作用域相反，局部作用域一般只在固定的代码片段内可以访问到</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function doSomeThing()&#123;</span><br><span class="line">  var blogName &#x3D; &#39;blogName&#39;</span><br><span class="line">  function innerSay()&#123;</span><br><span class="line">    alert(blogName)</span><br><span class="line">  &#125;</span><br><span class="line">  innerSay()</span><br><span class="line">&#125;</span><br><span class="line">console.log(blogName) &#x2F;&#x2F; blogName is not defined</span><br><span class="line">innerSay()            &#x2F;&#x2F; innerSay is not defined</span><br></pre></td></tr></table></figure>

<ul>
<li>调用函数时，函数作用域被创建，函数执行完毕，函数作用域被销毁。</li>
<li>每调用一次函数就会创建一个新的函数作用域，他们之间是互相独立的。</li>
<li>函数作用域中可以访问到全局作用域的变量，在函数外部无法访问函数内部的变量。</li>
<li>在函数作用域中访问变量、函数会先在自身作用域中寻找，若是没有找到会到函数上一级作用域中寻找，一直到全局作用域，若是还没有找到返回 undefined。</li>
<li>函数作用域中也有声明提前的特性，对于变量和函数都起作用。</li>
<li>在函数中定义形参，等同于声明变量。</li>
</ul>
<p>作用域是分层的，内层作用域可以访问外层作用域的变量。</p>
<h2 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h2><p>块级作用域可通过新增命令 let 和 const 声明，所声明的变量在指定块的作用域外无法被访问。</p>
<ul>
<li>块级作用域的特点<ul>
<li>变量声明不会提前到代码顶部<br>let/const 声明并不会被提升到当前代码块的顶部，因此需要手动将 let/const 声明放置到顶部，以便让变量在整个代码块内部可用。</li>
<li>禁止重复声明，如果一个标识符已经在代码块内声明过，那么在此代码块内使用同一个标进行 let 声明就会抛出错误。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var count &#x3D; 30</span><br><span class="line">let count &#x3D; 40  &#x2F;&#x2F; Uncaught SyntaxError: Identifier &#39;count&#39; has already been declare</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h1 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h1><h2 id="Scopr-Chain-作用域链"><a href="#Scopr-Chain-作用域链" class="headerlink" title="[[Scopr Chain]] 作用域链"></a>[[Scopr Chain]] 作用域链</h2><p>当查找变量的时候，会先从当前上下文的变量对象中查找，如果没有找到就会从父级执行上下文的变量对象中查找，一直找到全局上下文的变量对象(全局对象)。这样由多个执行上下文的变量对象构成的链表就是作用域链。<br>根据在内部函数可以访问外部函数变量的这种机制，用链式查找决定哪些数据能被内部函数访问，这就时作用域链。</p>
<h1 id="JS-执行环境"><a href="#JS-执行环境" class="headerlink" title="JS 执行环境"></a>JS 执行环境</h1><p>执行环境(Execution context，EC) 或执行上下文。分为三种( 全局执行环境、函数执行环境、eval()执行环境)<br>js 为每一个执行环境关联了一个变量对象。环境中定义的所有变量和函数都保存在这个对象中。</p>
<h2 id="EC-的组成"><a href="#EC-的组成" class="headerlink" title="EC 的组成"></a>EC 的组成</h2><p>当 JavaScript 代码执行的时候，会进入不同的执行环境(执行上下文)，这些执行环境会构成了一个执行环境栈(执行上下文栈)(Execution context stack,ECS)<br><img src="https://segmentfault.com/img/bVbenRf?w=881&h=466" alt="执行环境"></p>
<h3 id="变量对象-VO-和-活动对象-AO"><a href="#变量对象-VO-和-活动对象-AO" class="headerlink" title="变量对象(VO) 和 活动对象(AO)"></a>变量对象(VO) 和 活动对象(AO)</h3><p><code>变量对象(VO)</code>: 变量对象即包含变量的对象，除了我们无法访问它外，和普通对象没有区别。变量对象存储了在<code>上下文中定义的变量</code>和<code>函数声明</code>。</p>
<p><code>活动对象(AO)</code>: 活动对象和变量对象是一个东西，变量对象是规范上的或者说是引擎上实现的，不可在 JavaScript 环境中访问，只有到当进入一个执行上下文中，这个执行上下文的变量对象才会被激活，activation object <code>只有被激活的变量对象，也就是活动对象上的各种属性才能被访问</code>。<br>活动对象是在进入函数执行环境时刻被创建的，它通过函数的 argument 属性初始化</p>
<h3 id="执行环境"><a href="#执行环境" class="headerlink" title="执行环境"></a>执行环境</h3><p>全局执行环境是最外围的执行环境，全局执行环境被认为是 window 对象，因此所有的全局变量和函数都作为 window 对象的属性和方法创建的。<br>js 的执行顺序是根据函数的调用来决定的，当一个函数被调用时，该函数环境变量对象就被压入一个环境栈中。在函数执行之后，栈将该函数的变量对象弹出，把控制权交给之前的执行环境变量对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var scope &#x3D; &#39;global&#39;</span><br><span class="line">  function fn1()&#123;</span><br><span class="line">    return scope</span><br><span class="line">  &#125;</span><br><span class="line">  function fn2()&#123;</span><br><span class="line">    return scope</span><br><span class="line">  &#125;</span><br><span class="line">  fn1()</span><br><span class="line">  fn2()</span><br></pre></td></tr></table></figure>

<p><img src="https://segmentfault.com/img/bVbenRt?w=1042&h=436" alt></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2021/04/22/%E9%9D%A2%E8%AF%95/%E4%BD%9C%E7%94%A8%E5%9F%9F-%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/" data-id="cksjtyq80002lo0dxamuc9vxk" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-面试/vue生命周期知识" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/04/22/%E9%9D%A2%E8%AF%95/vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9F%A5%E8%AF%86/" class="article-date">
  <time datetime="2021-04-22T07:51:22.475Z" itemprop="datePublished">2021-04-22</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a>►<a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95/vue%E7%9F%A5%E8%AF%86%E7%82%B9/">vue知识点</a>►<a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95/vue%E7%9F%A5%E8%AF%86%E7%82%B9/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9F%A5%E8%AF%86/">生命周期知识</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/04/22/%E9%9D%A2%E8%AF%95/vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9F%A5%E8%AF%86/">生命周期知识</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>var app = new Vue({})</p>
<p>第一个钩子函数就是 beforeCreate，在这之前组件还没有真正的初始化。<br>在 beforeCreate 之后，Vue 对 data 对象作了 getter/setter 处理，并且将对象放在一个 Observe 里面以便监控对象。还使用 initEvents 绑定事件。</p>
<p><code>此时不能访问data的属性以及绑定的事件</code></p>
<p>组件初始化完成后，遇到 created。在这个阶段我们可以访问到了 data 的属性以及绑定的事件。</p>
<p>通过 created 阶段后组件的生命周期到了 beforemount,在这个阶段 DOM 结构还没有生成。但是已经创建了 el，组件挂载的根节点。在 beforemount 执行之后开始渲染 DOM。执行_render 方法，_mount 方法，然后会有 new 出一个 watcher 对象，形成 VNode 节点，然后更新 DOM。</p>
<p>渲染完毕后组件就会到下一个声明周期 mounted，一般的异步请求都会写在这里。这个阶段 DOM 已经渲染出来了。</p>
<p>Q: 什么是生命周期</p>
<p>A: Vue 实例从创建到销毁的过程，就是生命周期。也就是从开始创建、初始化数据、编译模板、挂载 DOM-&gt;渲染、更新-&gt;渲染、卸载等一系列过程。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2021/04/22/%E9%9D%A2%E8%AF%95/vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9F%A5%E8%AF%86/" data-id="cksjtyq7u002go0dxc2ed2cm2" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-面试/vue路由模式" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/04/22/%E9%9D%A2%E8%AF%95/vue%E8%B7%AF%E7%94%B1%E6%A8%A1%E5%BC%8F/" class="article-date">
  <time datetime="2021-04-22T07:51:22.475Z" itemprop="datePublished">2021-04-22</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a>►<a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95/vue%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%8C%E8%B7%AF%E7%94%B1%E6%A8%A1%E5%BC%8F%E5%8E%9F%E7%90%86/">vue知识点，路由模式原理</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/04/22/%E9%9D%A2%E8%AF%95/vue%E8%B7%AF%E7%94%B1%E6%A8%A1%E5%BC%8F/">路由模式原理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="路由的实现"><a href="#路由的实现" class="headerlink" title="路由的实现"></a>路由的实现</h2><p>前端路由的实现：本质上是检测 url 的变化，截获 url 地址，然后解析来匹配路由规则。但是 url 每次变化都会刷新页面，页面刷新 JavaScript 怎么检测和截获 url?2014 年之前，大家是通过 hash 来实现路由 url hash 类似于 <code>https://ssss.com/a/#file</code> <code>#</code> 后面 hash 值的变化，并不会导致浏览器向服务器发出请求，也就不会刷新页面，而 hash 值的变化都会触发 <code>hashchange</code>事件，通过这个事件我们就可以知道 hash 值发生了那些改变。</p>
<p>14 年后，HTML5 标准发布，多了两个 API <code>pushState 和 replaceState</code>,通过两个 API 可以改变 url 地址且不会发送请求。还有 <code>onpopstate</code>事件。用了 HTMl5 的实现，单页路由的 url 就不会多出一个 <code>#</code> 变得更加美观。但没有 # 所以当用户刷新页面之类的操作时，浏览器还是会给服务器发送请求，需要后台配置支持因为是单页面应用，如果后台没有正确的配置，当用户在浏览器直接访问 <code>htpp://oursit.com/user/id</code>就会返回 404</p>
<p>所以要在服务端增加一个覆盖所有情况的候选资源：如果 url 匹配不到任何静态资源，则应该返回一个 <code>index.html</code> ,这个 页面就是你 app 依赖的页面。</p>
<h2 id="hash-模式"><a href="#hash-模式" class="headerlink" title="hash 模式"></a>hash 模式</h2><p>hash 模式的工作原理是 hashchange 事件，可以在 window 监听 hash 的变化。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">window.onhashchange &#x3D; function(event)&#123;</span><br><span class="line">  console.log(event)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有两个属性 newURL 和 oldURL。根据 hash 值的变化加载对应的动态页面数据。</p>
<h2 id="history-模式"><a href="#history-模式" class="headerlink" title="history 模式"></a>history 模式</h2><p>HTML5 新增的 API</p>
<ul>
<li>history.pushState():往历史记录堆栈顶部添加一条记录</li>
<li>history.replaceState():更改当前的历史记录。</li>
<li>history.state: 用于存储以上方法的 data 数据</li>
<li>window.onpopstate : 响应 pushState 或 replaceState 的调用</li>
</ul>
<p>当使用 history 模式时，还需要后台配置支持，因为我们的应用是单页面应用，如果后台没有正确的配置，当用户在浏览器直接访问 <code>http://www.xxxxxx/detail</code> 就会返回 404 。所以需要在服务器增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html。服务器就不在返回 404 错误页面，因为会对所有路径返回 index.html 文件。为了避免这种情况，应该在 Vue 应用里面覆盖所有的路由情况，然后给出一个 404 页面。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2021/04/22/%E9%9D%A2%E8%AF%95/vue%E8%B7%AF%E7%94%B1%E6%A8%A1%E5%BC%8F/" data-id="cksjtyq7x002io0dx3dms07d2" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-面试/SPA" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/04/22/%E9%9D%A2%E8%AF%95/SPA/" class="article-date">
  <time datetime="2021-04-22T07:51:22.474Z" itemprop="datePublished">2021-04-22</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a>►<a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95/vue%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%8CSPA%E5%8D%95%E9%A1%B5%E9%9D%A2/">vue知识点，SPA单页面</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/04/22/%E9%9D%A2%E8%AF%95/SPA/">SPA单页面</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="SPA-单页面，优缺点是"><a href="#SPA-单页面，优缺点是" class="headerlink" title="SPA 单页面，优缺点是"></a>SPA 单页面，优缺点是</h3><p>SPA ( single-page-application ) 仅在页面初始化时加载相应的 HTML、JavaScript 和 CSS。页面加载完成，SPA 不会因为用户的操作而进行页面的重新加载或者跳转;取而代之的是利用路由机制实现 HTML 内容的变换，UI 与用户的交互，避免页面的重新加载。</p>
<p>单页面</p>
<p><code>单页面应用，就是只有一个页面的应用，页面的刷新和内部子页面的跳转完全由js来控制。</code></p>
<ul>
<li><p>单页面应用的特点</p>
<ul>
<li>本地路由，由 js 定义路由、根据路由渲染页面、控制页面的跳转。</li>
<li>所有的文件只会加载一次，最大限度重用文件，并且极大提升加载速度。</li>
<li>按需加载<br>根据业务逻辑拆分代码为独立的异步 js 文件(不存在于 html 的 Script 中)，在触发对应逻辑(如路由跳转，组件使用等)时通过 js 代码进行下载并使用。</li>
</ul>
</li>
<li><p>优点：</p>
<ul>
<li>有良好的交互体验<br>能提升页面切换体验，用户在访问应用页面是不会频繁的去切换浏览页面，从而避免了页面的重新加载。</li>
<li>前后端分离开发<br>前端进行交互逻辑，后端负责数据处理。</li>
<li>减轻服务器压力<br>服务器只用出数据就可以，不用管展示逻辑和页面合成。</li>
<li>共有一套后端代码<br>不用修改后端程序代码就可以同时用于多种客户端。</li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li>初次加载很耗时多<br>为实现单页面 Web 应用功能及显示效果，需要在加载页面的时候将 JavaScript、CSS 统一加载，部分页面可以在需要的时候加载</li>
<li>SEO 难度较高<br>由于所有的内容都会在一个页面中动态替换显示，</li>
<li>前进后退路由管理<br>由于单页面应用在一个页面显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理。</li>
</ul>
</li>
<li><p>性能优化</p>
<ul>
<li>加载优化<br>通常一开始就会加载所必需的的代码(JavaScript HTML CSS),首屏加载太慢会按需加载。<br><code>按需加载</code>就是按照当前呈现的不同页面加载不同的文件，<br>当首屏加载完毕后，设备&amp;网络处于空闲状态，可以对其他路由组件进行预加载。<br>根据路由拆分减少初始化加载体积，利用异步加载方式，在路由注册时提供拉取组件的方法，仅在需要进入对应路由时，组件才会被加载进来。</li>
<li>SEO 优化</li>
</ul>
</li>
<li><p>体验优化</p>
<ul>
<li>构建骨架图。</li>
<li>页面切换<br>页面切换前：在确保组件数据加载完毕前，可保证页面可交互，减少用户阻塞感。<br>切换时增加动画</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2021/04/22/%E9%9D%A2%E8%AF%95/SPA/" data-id="cksjtyq7n0029o0dx6vg621ny" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&amp;laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/JavaScript-%E9%AB%98%E7%BA%A7/">JavaScript 高级</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Vue-js/">Vue.js</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Vue-js/Props%E4%B8%8EData%E7%9A%84%E5%8C%BA%E5%88%AB/">Props与Data的区别</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Vue-js-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/">Vue.js 源码解读</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Vue-js-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E5%8F%98%E5%8C%96%E4%BE%A6%E6%B5%8B/">变化侦测</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Vue-js-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E5%8F%98%E5%8C%96%E4%BE%A6%E6%B5%8B/%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8F%98%E5%8C%96%E4%BE%A6%E5%90%AC/">数据的变化侦听</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Vue-js-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E5%90%8D%E8%AF%8D/">名词</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Vue-js-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E6%A8%A1%E6%9D%BF%E7%BC%96%E8%AF%91/">模板编译</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Vue-js-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/">生命周期</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Vue-js-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/%E5%88%9D%E5%A7%8B%E5%8C%96-initState-%E9%98%B6%E6%AE%B5/">初始化 initState 阶段</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Vue-js-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E8%99%9A%E6%8B%9FDOM/">虚拟DOM</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Vue-js-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E8%99%9A%E6%8B%9FDOM/Diff/">Diff</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Vue-js-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E8%99%9A%E6%8B%9FDOM/Vue%E4%B8%AD%E7%9A%84%E8%99%9A%E6%8B%9FDom/">Vue中的虚拟Dom</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Vue-js-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E8%99%9A%E6%8B%9FDOM/%E6%9B%B4%E6%96%B0%E5%AD%90%E8%8A%82%E7%82%B9/">更新子节点</a></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/elementUI%E5%A5%87%E6%80%AA%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/">elementUI奇怪问题解决办法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/element%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/">element使用不常用方法总结</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/import-%E5%92%8C-export/">import 和 export</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/js%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/">js知识体系</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/js%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/js-%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/">js 代码执行过程分析</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/js%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/js-%E8%AF%AD%E8%A8%80%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7/">js 语言的三大特性</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/js%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/%E4%BA%8B%E4%BB%B6/">事件</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/js%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/%E6%95%B0%E6%8D%AE/">数据</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/">正则表达式</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E6%B6%89%E5%8F%8A%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9/">浏览器渲染涉及的知识点</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%99%BB%E5%BD%95%E8%AE%A4%E8%AF%81%E7%9F%A5%E8%AF%86/">登录认证知识</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9D%A2%E8%AF%95/vue%E7%9F%A5%E8%AF%86%E7%82%B9/">vue知识点</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9D%A2%E8%AF%95/vue%E7%9F%A5%E8%AF%86%E7%82%B9/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9F%A5%E8%AF%86/">生命周期知识</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9D%A2%E8%AF%95/vue%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%8CSPA%E5%8D%95%E9%A1%B5%E9%9D%A2/">vue知识点，SPA单页面</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9D%A2%E8%AF%95/vue%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%8C%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86-MVVM/">vue知识点，双向数据绑定原理& MVVM</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9D%A2%E8%AF%95/vue%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%8C%E8%B7%AF%E7%94%B1%E6%A8%A1%E5%BC%8F%E5%8E%9F%E7%90%86/">vue知识点，路由模式原理</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9D%A2%E8%AF%95/%E4%BB%8EURL%E8%BE%93%E5%85%A5%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%8E%B0%E6%B6%89%E5%8F%8A%E7%9A%84%E7%9F%A5%E8%AF%86%E3%80%82/">从URL输入到页面展现涉及的知识。</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9D%A2%E8%AF%95/%E4%BD%9C%E7%94%A8%E5%9F%9F-%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/">作用域-作用域链</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9D%A2%E8%AF%95/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/">浏览器缓存</a></li></ul></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">August 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">July 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">June 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">May 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/08/20/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/">正则表达式,</a>
          </li>
        
          <li>
            <a href="/2021/07/10/%E8%AF%B7%E6%B1%82%E5%88%B0%E8%BE%BEweb%E6%9C%8D%E5%8A%A1%E5%99%A8/">请求到达web服务器</a>
          </li>
        
          <li>
            <a href="/2021/07/06/TCP/">TCP</a>
          </li>
        
          <li>
            <a href="/2021/06/29/js%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/js%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/">JS代码执行过程分析</a>
          </li>
        
          <li>
            <a href="/2021/06/24/js%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7/">js 语言的三大特性</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2021 sxhMxd<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>