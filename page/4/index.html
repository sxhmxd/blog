<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>有理想的笛子</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="有理想的笛子">
<meta property="og:url" content="http://yoursite.com/page/4/index.html">
<meta property="og:site_name" content="有理想的笛子">
<meta property="og:locale" content="zh">
<meta property="article:author" content="sxhMxd">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="有理想的笛子" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">有理想的笛子</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-vue源码4" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/04/13/vue%E6%BA%90%E7%A0%814/" class="article-date">
  <time datetime="2022-04-13T07:41:31.026Z" itemprop="datePublished">2022-04-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Vue-js-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/">Vue.js 源码解读</a>►<a class="article-category-link" href="/categories/Vue-js-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E6%A8%A1%E6%9D%BF%E7%BC%96%E8%AF%91/">模板编译</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/04/13/vue%E6%BA%90%E7%A0%814/">Vue.js 源码解读, 模板编译</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="什么是模板编译"><a href="#什么是模板编译" class="headerlink" title="什么是模板编译"></a>什么是模板编译</h2><p><code>Vue</code> 会把用户在<code>&lt;template&gt;&lt;/template&gt;</code>标签中写的类似于原生 HTML 的内容进行编译，把原生 HTML 的内容找出来，再把非原生 HTML 找出来，经过一系列的逻辑处理生成渲染函数，也就是 render 函数，而 render 函数会将模板内容生成对应的 VNode，而 VNode 再经过前几篇文章介绍的 patch 过程从而得到将要渲染的视图中的 VNode，最后根据 VNode 创建真实的 DOM 节点并插入到视图中， 最终完成视图的渲染更新。<br>而把用户在<template></template>标签中写的类似于原生 HTML 的内容进行编译，把原生 HTML 的内容找出来，再把非原生 HTML 找出来，经过一系列的逻辑处理生成渲染函数，也就是 render 函数的这一段过程称之为模板编译过程。</p>
<h2 id="整体渲染流程"><a href="#整体渲染流程" class="headerlink" title="整体渲染流程"></a>整体渲染流程</h2><p>渲染流程，就是把用户写的类似于原生 HTML 的模板经过一系列处理最终反应到视图中称之为整个渲染流程。</p>
<p><img src="https://vue-js.com/learn-vue/assets/img/1.f0570125.png" alt="渲染流程"></p>
<h2 id="模板编译内部流程"><a href="#模板编译内部流程" class="headerlink" title="模板编译内部流程"></a>模板编译内部流程</h2><h3 id="抽象语法树-AST"><a href="#抽象语法树-AST" class="headerlink" title="抽象语法树 AST"></a>抽象语法树 AST</h3><p>抽象语法树，在计算机科学中，抽象语法树（AbstractSyntaxTree，AST），或简称语法树（Syntax tree），是源代码语法结构的一种抽象表示。它以树状的形式表现编程语言的语法结构，树上的每个节点都表示源代码中的一种结构。之所以说语法是“抽象”的，是因为这里的语法并不会表示出真实语法中出现的每个细节。</p>
<h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p>分为三个阶段:</p>
<ul>
<li>模板解析阶段:将一堆模板字符串用正则等方式解析成抽象语法树 AST</li>
<li>优化阶段: 遍历 AST ,找出其中的静态节点, 并打上标记;</li>
<li>代码生成阶段：将 AST 转换成渲染函数;</li>
</ul>
<p><img src="https://vue-js.com/learn-vue/assets/img/3.15d9566b.png" alt="模板内部流程图"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2022/04/13/vue%E6%BA%90%E7%A0%814/" data-id="cl83x4cse000hwgdx7jt2476b" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-vue源码3" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/04/13/vue%E6%BA%90%E7%A0%813/" class="article-date">
  <time datetime="2022-04-13T07:41:31.025Z" itemprop="datePublished">2022-04-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Vue-js-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/">Vue.js 源码解读</a>►<a class="article-category-link" href="/categories/Vue-js-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E8%99%9A%E6%8B%9FDOM/">虚拟DOM</a>►<a class="article-category-link" href="/categories/Vue-js-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E8%99%9A%E6%8B%9FDOM/%E6%9B%B4%E6%96%B0%E5%AD%90%E8%8A%82%E7%82%B9/">更新子节点</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/04/13/vue%E6%BA%90%E7%A0%813/">Vue.js 源码解读, 更新子节点</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="更新子节点"><a href="#更新子节点" class="headerlink" title="更新子节点"></a>更新子节点</h2><p>当新的 VNode 与旧的 oldVNode 都是元素节点并且都包含子节点时，那么这两个节点的 VNode 实例上的 children 属性就是所包含的子节点数组。我们把新的 VNode 上的子节点数组记为 newChildren，把旧的 oldVNode 上的子节点数组记为 oldChildren，我们把 newChildren 里面的元素与 oldChildren 里的元素一一进行对比，对比两个子节点数组肯定是要通过循环，外层循环 newChildren 数组，内层循环 oldChildren 数组，每循环外层 newChildren 数组里的一个子节点，就去内层 oldChildren 数组里找看有没有与之相同的子节点</p>
<p>以上这个过程存在四种情况: 创建子节点、删除字节点、移动子节点、更新节点。</p>
<h2 id="创建子节点"><a href="#创建子节点" class="headerlink" title="创建子节点"></a>创建子节点</h2><p>newChildren 里面的某个子节点在 oldChildren 里找不到与之相同的子节点，说明 newChildren 里面的这个子节点是之前没有的，是需要此次新增的节点，创建这个节点，创建之后把它插入到 DOM 中合适的位置。</p>
<p><img src="https://vue-js.com/learn-vue/assets/img/4.cb62f1aa.png" alt="avatar"></p>
<h2 id="删除子节点"><a href="#删除子节点" class="headerlink" title="删除子节点"></a>删除子节点</h2><p>把 newChildren 里面的每一个子节点都循环一遍，能在 oldChildren 数组里找到的就处理它，找不到的就新增，直到把 newChildren 里面所有子节点都遍历一遍后，发现 oldChildren 还存在未处理的子节点，说明未处理的子节点是需要被废弃的，那么就将这些节点删除。</p>
<h2 id="更新子节点-1"><a href="#更新子节点-1" class="headerlink" title="更新子节点"></a>更新子节点</h2><p>如果 newChildren 里面的某个子节点在 oldChildren 里找到与之相同的子节点，并且所处的位置也相同，那么就更新 oldChildren 里该节点使之与 newChildren 里的该节点相同。</p>
<h2 id="移动子节点"><a href="#移动子节点" class="headerlink" title="移动子节点"></a>移动子节点</h2><p>如果 newChildren 里面的某个子节点在 oldChildren 里找到与之相同的子节点，但是所处的位置不同，则此次变化需要调整该子节点的位置，以 newChildren 的位置为准，调整 oldChildren 里改节点的位置。</p>
<p><img src="https://vue-js.com/learn-vue/assets/img/6.b9621b4d.png" alt="avatar"></p>
<p>在上图中，绿色的两个节点是相同节点但是所处位置不同，按照上面所说的，我们应该以 newChildren 里子节点的位置为基准，调整 oldChildren 里该节点的位置，所以我们应该把真实 DOM 即 oldChildren 里面的第四个节点移动到第三个节点的位置</p>
<h2 id="更新子节点的优化"><a href="#更新子节点的优化" class="headerlink" title="更新子节点的优化"></a>更新子节点的优化</h2><p>根据之前的跟新逻辑，可以解决问题，存在可以优化的地方。如果当包含的子节点数量很多时，循环算法的时间复杂度会变的很大，不利于性能的提升。</p>
<h3 id="优化策略"><a href="#优化策略" class="headerlink" title="优化策略"></a>优化策略</h3><p>我们不按照顺序去循环 newChildren 和 oldChildren 这两个数组，可以先比较这两个数组里特殊位置的子节点。</p>
<ul>
<li>新前与旧前<br>先把 newChildren 数组里面的所有未处理子节点的第一个和 oldChildren 数组里面所有未处理子节点的第一个做对比，如果相同，就直接进入更新子节点的操作。</li>
</ul>
<p><img src="https://vue-js.com/learn-vue/assets/img/9.e017b452.png" alt="avatar"></p>
<ul>
<li>新后与旧后<br>把 newChildren 数组里面的所有未处理子节点的最后一个和 oldChildren 数组里面所有未处理子节点的最后一个做对比，如果相同，就直接进入更新子节点的操作。</li>
</ul>
<p><img src="https://vue-js.com/learn-vue/assets/img/10.cf98adc0.png" alt="avatar"></p>
<ul>
<li>新后与旧前<br>把 newChildren 数组里面的所有未处理子节点的最后一个和 oldChildren 数组里面所有未处理子节点的第一个做对比，如果相同，就直接进入更新子节点的操作，更新完成后再将 oldChildren 数组里的该节点移动到与 newChildren 数组节点相同的位置。</li>
</ul>
<p><img src="https://vue-js.com/learn-vue/assets/img/12.bace2f7f.png" alt="avatar"></p>
<ul>
<li>新前与旧后<br>把 newChildren 数组里面的所有未处理子节点的第一个和 oldChildren 数组里面所有未处理子节点的最后一个做对比，如果相同，就直接进入更新子节点的操作，更新完成后再将 oldChildren 数组里的该节点移动到与 newChildren 数组节点相同的位置。</li>
</ul>
<p><img src="https://vue-js.com/learn-vue/assets/img/14.18c1c6dd.png" alt="avatar"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2022/04/13/vue%E6%BA%90%E7%A0%813/" data-id="cl83x4csf000kwgdxht280np7" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-vue源码2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/04/13/vue%E6%BA%90%E7%A0%812/" class="article-date">
  <time datetime="2022-04-13T07:41:31.024Z" itemprop="datePublished">2022-04-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Vue-js-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/">Vue.js 源码解读</a>►<a class="article-category-link" href="/categories/Vue-js-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E8%99%9A%E6%8B%9FDOM/">虚拟DOM</a>►<a class="article-category-link" href="/categories/Vue-js-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E8%99%9A%E6%8B%9FDOM/Diff/">Diff</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/04/13/vue%E6%BA%90%E7%A0%812/">Vue.js 源码解读, Diff</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="DOM-Diff"><a href="#DOM-Diff" class="headerlink" title="DOM-Diff"></a>DOM-Diff</h1><p><code>VNode</code> 最大的用途就是在数据变化前后生成真实<code>DOM</code> 对应虚拟<code>DOM</code>节点，然后就可以对比新旧两份<code>VNode</code>，找出差异所在，然后更新有差异的<code>DOM</code> 节点，最终达到以最少操作真实<code>DOM</code>更新视图的目的。新旧<code>DOM</code>树的对比找出差异的过程就是所谓的<code>DOM-Diff</code>过程，该过程是整个虚拟<code>DOM</code>核心所在。</p>
<h2 id="patch"><a href="#patch" class="headerlink" title="patch"></a>patch</h2><p>在 vue 中，把 DOM-Diff 过程叫做 patch 过程。patch 意为”补丁”,即对旧的 VNode 修补，打补丁从而得到新的 VNode。<br>patch 的过程：<br>旧的 VNode(oldVNode)数据变化之前视图对应的虚拟 DOM 节点， 新的 VNode 是数据变化之后将要渲染的新的视图所对应的虚拟 DOM 节点，所以我们以新的 VNode 为基准，对比旧的 oldVNode ,如果新的 VNode 上有的节点而旧的 oldVNode 上没有，那么就在旧 oldVNode 上加上去；如果新<br>VNode 上没有而 oldVNode 上有，那么就在旧节点上去掉；如果新旧节点上都有，那么以新的 VNode 为基准，更新旧的 oldVNode，从而让新旧相同。</p>
<p>一句话：以新的 VNode 为基准改造旧的 oldVNode 使之成为跟新的 VNode 一样。</p>
<h2 id="创建节点"><a href="#创建节点" class="headerlink" title="创建节点"></a>创建节点</h2><p>VNode 类可以描述 6 种类型的节点，但是只有三种类型的节点能够被创建并插入到 DOM 中，即 元素节点、文本节点、注释节点。vue 在创建时会判断这个节点是什么类型，从而调用不同的方法创建并插入到 DOM 中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function createElm(vnode,parentElm,refElm)&#123;</span><br><span class="line">  const data &#x3D; vnode.data</span><br><span class="line">  const children &#x3D; vnode.children</span><br><span class="line">  const tag &#x3D; vnode.tag</span><br><span class="line">  if (isDef(tag)) &#123;</span><br><span class="line">  	vnode.elm &#x3D; nodeOps.createElement(tag, vnode)   &#x2F;&#x2F; 创建元素节点</span><br><span class="line">    createChildren(vnode, children, insertedVnodeQueue) &#x2F;&#x2F; 创建元素节点的子节点</span><br><span class="line">    insert(parentElm, vnode.elm, refElm)       &#x2F;&#x2F; 插入到DOM中</span><br><span class="line">  &#125; else if (isTrue(vnode.isComment)) &#123;</span><br><span class="line">    vnode.elm &#x3D; nodeOps.createComment(vnode.text)  &#x2F;&#x2F; 创建注释节点</span><br><span class="line">    insert(parentElm, vnode.elm, refElm)           &#x2F;&#x2F; 插入到DOM中</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    vnode.elm &#x3D; nodeOps.createTextNode(vnode.text)  &#x2F;&#x2F; 创建文本节点</span><br><span class="line">    insert(parentElm, vnode.elm, refElm)           &#x2F;&#x2F; 插入到DOM中</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>判断是否是元素节点只需要判断 VNode 节点是否有 tag 标签即可。</li>
<li>判断是否是注释节点，只需要判断 VNode 的 isComment 属性是否为 true 即可。</li>
<li>如果既不是元素节点又不是注释节点，那就认为是文本节点</li>
</ul>
<p>创建节点的流程图</p>
<p><img src="https://vue-js.com/learn-vue/assets/img/2.02d5c7b1.png" alt="avatar"></p>
<h2 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h2><p>删除节点，只需要在要删除节点的父元素上调用 removeChild 方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function removeNode (el) &#123;</span><br><span class="line">  cosnt parent &#x3D; nodeOps.parentNode(el) &#x2F;&#x2F; 获取父节点</span><br><span class="line">  if (isDef(parent)) &#123;</span><br><span class="line">    nodeOps.removeChild(parent,el) &#x2F;&#x2F;调用父节点的removeChild 方法</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="更新节点"><a href="#更新节点" class="headerlink" title="更新节点"></a>更新节点</h2><p>更新节点需要在新的 VNode 和 oldVNode 进行细致的比较，找出不一样的地方进行更新。</p>
<ul>
<li>静态节点</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;不会变的文字&lt;&#x2F;p&gt;</span><br></pre></td></tr></table></figure>

<p>上面的节点只包含了纯文字，没有绑定变量，所以不管数据怎么变化，这个节点渲染后，那么它永远不会发生变化。 把这种节点称之为静态节点。</p>
<p>更新节点需要对三种情况进行判断并分别处理</p>
<ul>
<li><p>如果 VNode 和 oldVNode 均为静态节点</p>
<p>两者如果都是静态节点，则直接跳过，无需处理</p>
</li>
<li><p>如果 VNode 是文本节点</p>
<p>如果 VNode 是文本节点，则表示这个节点值包含纯文本，那么只需看 oldVNode 是否也是文本节点，如果是，那就比较两个文本是否不同，如若不同则把 oldVNode 里的文本改成和 VNode 的文本一样。如果 oldVNode 不是文本节点，那么不论是什么，直接调用 setTextNode 方法把它改变成文本节点，内容跟 VNode 相同。</p>
</li>
<li><p>如果 VNode 是元素节点</p>
<p>元素节点又分两种情况</p>
<ul>
<li>该节点包含子节点</li>
</ul>
<p>如果新的节点内包含子节点，那么此时就要看旧的节点是否包含子节点，如果旧的节点里也包含了子节点，那就需要递归对比更新子节点。如果旧的节点里不包含子节点，那么这个旧节点有可能是空节点或者是文本节点，如果旧的节点是空节点就把新的节点里的子节点创建一份插入到旧的节点里面。如果旧的节点是文本节点，则把文本清空，然后把新的节点里的子节点创建一份然后插入到旧的节点里面。</p>
<ul>
<li>该节点不包含子节点</li>
</ul>
<p>如果该节点不包含子节点，同时它又不是文本节点，那就说明该节点是个空节点不管旧节点里面有啥，直接清空即可。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 更新节点</span><br><span class="line">function patchVnode (oldVnode, vnode, insertedVnodeQueue, removeOnly) &#123;</span><br><span class="line">  &#x2F;&#x2F; vnode与oldVnode是否完全一样？若是，退出程序</span><br><span class="line">  if (oldVnode &#x3D;&#x3D;&#x3D; vnode) &#123;</span><br><span class="line">    return</span><br><span class="line">  &#125;</span><br><span class="line">  const elm &#x3D; vnode.elm &#x3D; oldVnode.elm</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; vnode与oldVnode是否都是静态节点？若是，退出程序</span><br><span class="line">  if (isTrue(vnode.isStatic) &amp;&amp;</span><br><span class="line">    isTrue(oldVnode.isStatic) &amp;&amp;</span><br><span class="line">    vnode.key &#x3D;&#x3D;&#x3D; oldVnode.key &amp;&amp;</span><br><span class="line">    (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))</span><br><span class="line">  ) &#123;</span><br><span class="line">    return</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  const oldCh &#x3D; oldVnode.children</span><br><span class="line">  const ch &#x3D; vnode.children</span><br><span class="line">  &#x2F;&#x2F; vnode有text属性？若没有：</span><br><span class="line">  if (isUndef(vnode.text)) &#123;</span><br><span class="line">    &#x2F;&#x2F; vnode的子节点与oldVnode的子节点是否都存在？</span><br><span class="line">    if (isDef(oldCh) &amp;&amp; isDef(ch)) &#123;</span><br><span class="line">      &#x2F;&#x2F; 若都存在，判断子节点是否相同，不同则更新子节点</span><br><span class="line">      if (oldCh !&#x3D;&#x3D; ch) updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly)</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 若只有vnode的子节点存在</span><br><span class="line">    else if (isDef(ch)) &#123;</span><br><span class="line">      &#x2F;**</span><br><span class="line">       * 判断oldVnode是否有文本？</span><br><span class="line">       * 若没有，则把vnode的子节点添加到真实DOM中</span><br><span class="line">       * 若有，则清空Dom中的文本，再把vnode的子节点添加到真实DOM中</span><br><span class="line">       *&#x2F;</span><br><span class="line">      if (isDef(oldVnode.text)) nodeOps.setTextContent(elm, &#39;&#39;)</span><br><span class="line">      addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue)</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 若只有oldnode的子节点存在</span><br><span class="line">    else if (isDef(oldCh)) &#123;</span><br><span class="line">      &#x2F;&#x2F; 清空DOM中的子节点</span><br><span class="line">      removeVnodes(elm, oldCh, 0, oldCh.length - 1)</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 若vnode和oldnode都没有子节点，但是oldnode中有文本</span><br><span class="line">    else if (isDef(oldVnode.text)) &#123;</span><br><span class="line">      &#x2F;&#x2F; 清空oldnode文本</span><br><span class="line">      nodeOps.setTextContent(elm, &#39;&#39;)</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 上面两个判断一句话概括就是，如果vnode中既没有text，也没有子节点，那么对应的oldnode中有什么就清空什么</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 若有，vnode的text属性与oldVnode的text属性是否相同？</span><br><span class="line">  else if (oldVnode.text !&#x3D;&#x3D; vnode.text) &#123;</span><br><span class="line">    &#x2F;&#x2F; 若不相同：则用vnode的text替换真实DOM的文本</span><br><span class="line">    nodeOps.setTextContent(elm, vnode.text)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更新节点的流程</p>
<p><img src="https://vue-js.com/learn-vue/assets/img/3.7b0442aa.png" alt="avatar"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2022/04/13/vue%E6%BA%90%E7%A0%812/" data-id="cl83x4csd000gwgdx1nq271x8" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-vue源码1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/04/13/vue%E6%BA%90%E7%A0%811/" class="article-date">
  <time datetime="2022-04-13T07:41:31.022Z" itemprop="datePublished">2022-04-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Vue-js-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/">Vue.js 源码解读</a>►<a class="article-category-link" href="/categories/Vue-js-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E8%99%9A%E6%8B%9FDOM/">虚拟DOM</a>►<a class="article-category-link" href="/categories/Vue-js-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E8%99%9A%E6%8B%9FDOM/Vue%E4%B8%AD%E7%9A%84%E8%99%9A%E6%8B%9FDom/">Vue中的虚拟Dom</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/04/13/vue%E6%BA%90%E7%A0%811/">Vue.js 源码解读, 虚拟Dom</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="虚拟-Dom"><a href="#虚拟-Dom" class="headerlink" title="虚拟 Dom"></a>虚拟 Dom</h1><ul>
<li>什么是虚拟 DOM ？<br>虚拟 Dom,就是用一个 <code>JS</code> 对象来描述一个<code>DOM</code>节点。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;a&quot; id&#x3D;&quot;b&quot;&gt;内容&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  tag: &#39;div&#39;,   &#x2F;&#x2F; 元素标签</span><br><span class="line">  attrs:&#123;       &#x2F;&#x2F; 属性</span><br><span class="line">    class:&#39;a&#39;,</span><br><span class="line">    id:&#39;b&#39;</span><br><span class="line">  &#125;,</span><br><span class="line">  text:&#39;内容&#39;,  &#x2F;&#x2F; 文本内容</span><br><span class="line">  children:[]  &#x2F;&#x2F; 子元素</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>把组成一个<code>DOM</code>节点的必要东西通过一个 <code>JS</code> 对象表示出来，那么这个<code>JS</code> 对象就可以用来藐视这个<code>DOM</code>节点，我们把这个<code>JS</code>对象就称为是这个真实<code>DOM</code>节点的虚拟<code>DOM</code>节点。</p>
<ul>
<li>为什么要有虚拟 DOM ？<br><code>Vue</code> 是数据驱动视图的，数据发生变化视图就要随之更新，在更新视图的时候难免要操作<code>DOM</code>,操作<code>DOM</code>又是非常耗费性能的。但是我们逃不掉操作<code>DOM</code>,所以只能尽可能的减少操作<code>DOM</code> 。<br>最直观的方法就是不要盲目的去更新视图，而是通过对比数据变化的前后的状态，计算出视图中那些地方需要更新，只更新需要更新的地方。就是用<code>JS</code>的计算性能来换取操作<code>DOM</code>的性能。</li>
</ul>
<h2 id="Vue-中的虚拟-DOM"><a href="#Vue-中的虚拟-DOM" class="headerlink" title="Vue 中的虚拟 DOM"></a>Vue 中的虚拟 DOM</h2><h3 id="VNode-类"><a href="#VNode-类" class="headerlink" title="VNode 类"></a>VNode 类</h3><p>在<code>Vue</code>中就存在一个<code>VNode</code>类，通过这个类，我们就可以实例化出不同类型的虚拟<code>DOM</code>节点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">export default class VNode &#123;</span><br><span class="line">  constructor (</span><br><span class="line">    tag?: string,</span><br><span class="line">    data?: VNodeData,</span><br><span class="line">    children?: ?Array&lt;VNode&gt;,</span><br><span class="line">    text?: string,</span><br><span class="line">    elm?: Node,</span><br><span class="line">    context?: Component,</span><br><span class="line">    componentOptions?: VNodeComponentOptions,</span><br><span class="line">    asyncFactory?: Function</span><br><span class="line">  ) &#123;</span><br><span class="line">    this.tag &#x3D; tag                                &#x2F;*当前节点的标签名*&#x2F;</span><br><span class="line">    this.data &#x3D; data        &#x2F;*当前节点对应的对象，包含了具体的一些数据信息，是一个VNodeData类型，可以参考VNodeData类型中的数据信息*&#x2F;</span><br><span class="line">    this.children &#x3D; children  &#x2F;*当前节点的子节点，是一个数组*&#x2F;</span><br><span class="line">    this.text &#x3D; text     &#x2F;*当前节点的文本*&#x2F;</span><br><span class="line">    this.elm &#x3D; elm       &#x2F;*当前虚拟节点对应的真实dom节点*&#x2F;</span><br><span class="line">    this.ns &#x3D; undefined            &#x2F;*当前节点的名字空间*&#x2F;</span><br><span class="line">    this.context &#x3D; context          &#x2F;*当前组件节点对应的Vue实例*&#x2F;</span><br><span class="line">    this.fnContext &#x3D; undefined       &#x2F;*函数式组件对应的Vue实例*&#x2F;</span><br><span class="line">    this.fnOptions &#x3D; undefined</span><br><span class="line">    this.fnScopeId &#x3D; undefined</span><br><span class="line">    this.key &#x3D; data &amp;&amp; data.key           &#x2F;*节点的key属性，被当作节点的标志，用以优化*&#x2F;</span><br><span class="line">    this.componentOptions &#x3D; componentOptions   &#x2F;*组件的option选项*&#x2F;</span><br><span class="line">    this.componentInstance &#x3D; undefined       &#x2F;*当前节点对应的组件的实例*&#x2F;</span><br><span class="line">    this.parent &#x3D; undefined           &#x2F;*当前节点的父节点*&#x2F;</span><br><span class="line">    this.raw &#x3D; false         &#x2F;*简而言之就是是否为原生HTML或只是普通文本，innerHTML的时候为true，textContent的时候为false*&#x2F;</span><br><span class="line">    this.isStatic &#x3D; false         &#x2F;*静态节点标志*&#x2F;</span><br><span class="line">    this.isRootInsert &#x3D; true      &#x2F;*是否作为跟节点插入*&#x2F;</span><br><span class="line">    this.isComment &#x3D; false             &#x2F;*是否为注释节点*&#x2F;</span><br><span class="line">    this.isCloned &#x3D; false           &#x2F;*是否为克隆节点*&#x2F;</span><br><span class="line">    this.isOnce &#x3D; false                &#x2F;*是否有v-once指令*&#x2F;</span><br><span class="line">    this.asyncFactory &#x3D; asyncFactory</span><br><span class="line">    this.asyncMeta &#x3D; undefined</span><br><span class="line">    this.isAsyncPlaceholder &#x3D; false</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  get child (): Component | void &#123;</span><br><span class="line">    return this.componentInstance</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="VNode-的类型"><a href="#VNode-的类型" class="headerlink" title="VNode 的类型"></a>VNode 的类型</h3><ul>
<li>注释节点</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 创建注释节点</span><br><span class="line">export const createEmptyVNode &#x3D; (text: string &#x3D; &#39;&#39;) &#x3D;&gt; &#123;</span><br><span class="line">  const node &#x3D; new VNode()</span><br><span class="line">  node.text &#x3D; text          &#x2F;&#x2F; 表示具体的注释信息，</span><br><span class="line">  node.isComment &#x3D; true     &#x2F;&#x2F; 是一个标志，用来标识一个节点是否是注释节点。</span><br><span class="line">  return node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>文本节点</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 创建文本节点</span><br><span class="line"> export function createTextVNode (val: string | number)&#123;</span><br><span class="line">   return new VNode(undefined,undefined,undefined,String(val))</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>克隆节点</li>
</ul>
<p>克隆节点就是把一个已经存在的节点复制一份，主要是为了做模板编译优化时使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 创建克隆节点</span><br><span class="line">export function cloneVNode (vnode: VNode): VNode &#123;</span><br><span class="line">  const cloned &#x3D; new VNode(</span><br><span class="line">    vnode.tag,</span><br><span class="line">    vnode.data,</span><br><span class="line">    vnode.children,</span><br><span class="line">    vnode.text,</span><br><span class="line">    vnode.elm,</span><br><span class="line">    vnode.context,</span><br><span class="line">    vnode.componentOptions,</span><br><span class="line">    vnode.asyncFactory</span><br><span class="line">  )</span><br><span class="line">  cloned.ns &#x3D; vnode.ns</span><br><span class="line">  cloned.isStatic &#x3D; vnode.isStatic</span><br><span class="line">  cloned.key &#x3D; vnode.key</span><br><span class="line">  cloned.isComment &#x3D; vnode.isComment</span><br><span class="line">  cloned.fnContext &#x3D; vnode.fnContext</span><br><span class="line">  cloned.fnOptions &#x3D; vnode.fnOptions</span><br><span class="line">  cloned.fnScopeId &#x3D; vnode.fnScopeId</span><br><span class="line">  cloned.asyncMeta &#x3D; vnode.asyncMeta</span><br><span class="line">  cloned.isCloned &#x3D; true</span><br><span class="line">  return cloned</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>克隆节点就是把已有节点的属性全部复制到新节点中，而现有节点和新克隆得到的节点之间唯一的不同就是克隆得到的节点<code>isCloned</code> 为 <code>true</code>。</p>
<ul>
<li>元素节点</li>
</ul>
<p>元素节点更贴近我们通常看到的真实<code>DOM</code> 节点，有描述节点标签名词的<code>tag</code> 属性，描述节点属性<code>class</code>、<code>attributes</code>、等的<code>Data</code> 属性，有描述子节点信息的<code>children</code> 属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 真实Dom节点</span><br><span class="line">&lt;div id&#x3D;&#39;a&#39;&gt;&lt;span&gt;难凉热血&lt;&#x2F;span&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&#x2F;&#x2F;VNode节点</span><br><span class="line">&#123;</span><br><span class="line">  tag:&#39;div&#39;,</span><br><span class="line">  data:&#123;&#125;,</span><br><span class="line">  children:[</span><br><span class="line">    &#123;</span><br><span class="line">      tag:&#39;span&#39;,</span><br><span class="line">      text:&#39;难凉热血&#39;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>组件节点</li>
</ul>
<p>组件节点除了有元素节点的属性之外，还有两个特有属性:<br>componentOptions:组件的 option 选项，如组件的 <code>props</code> 等<br>componentInstance:当前组件节点对应的<code>vue</code> 实例</p>
<ul>
<li>函数式组件节点</li>
</ul>
<p>函数式节点相较于组件节点，它又有两个特有的属性：<br>fnContext:函数组件对应的 Vue 实例<br>fnOptions:组件的 options 选项</p>
<h3 id="VNode-的作用"><a href="#VNode-的作用" class="headerlink" title="VNode 的作用"></a>VNode 的作用</h3><p>我们在视图渲染之前，把写好的<code>template</code> 模板先编译成<code>VNode</code> 并缓存下来，等到数据发生变化页面需要重新渲染的时候，我们把数据发生变化后生成的<code>VNode</code>与前一次缓存下来的<code>VNode</code>进行对比,找出差异，然后有差异的<code>VNode</code>对应的真实<code>DOM</code>节点就是需要重新渲染的节点，然后根据有差异的<code>VNode</code> 创建出真实的<code>DOM</code>节点再插入到视图中，最终完成一次视图更新。</p>
<p>总结：就是以<code>JS</code>的计算性能来换取操作真实<code>DOM</code>所消耗的性能。从源码角度我们知道了在 Vue 中是通过 VNode 类来实例化出不同类型的虚拟 DOM 节点，并且学习了不同类型节点生成的属性的不同，所谓不同类型的节点其本质还是一样的，都是 VNode 类的实例，只是在实例化时传入的属性参数不同罢了。最后探究了 VNode 的作用，有了数据变化前后的 VNode，我们才能进行后续的 DOM-Diff 找出差异，最终做到只更新有差异的视图，从而达到尽可能少的操作真实 DOM 的目的，以节省性能。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2022/04/13/vue%E6%BA%90%E7%A0%811/" data-id="cl83x4csc000dwgdx72hpbn9s" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-vue源码" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/04/13/vue%E6%BA%90%E7%A0%81/" class="article-date">
  <time datetime="2022-04-13T07:41:31.005Z" itemprop="datePublished">2022-04-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Vue-js-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/">Vue.js 源码解读</a>►<a class="article-category-link" href="/categories/Vue-js-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E5%8F%98%E5%8C%96%E4%BE%A6%E6%B5%8B/">变化侦测</a>►<a class="article-category-link" href="/categories/Vue-js-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E5%8F%98%E5%8C%96%E4%BE%A6%E6%B5%8B/%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8F%98%E5%8C%96%E4%BE%A6%E5%90%AC/">数据的变化侦听</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/04/13/vue%E6%BA%90%E7%A0%81/">Vue.js 源码解读,数据的变化侦听</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="变化侦听"><a href="#变化侦听" class="headerlink" title="变化侦听"></a>变化侦听</h1><p>数据驱动视图的关键在于怎么知道数据发生了变化。<code>js</code> 为我们提供了 <code>Object.defineProperty</code> 方法。该方法可以知道数据在什么时候发生变化。</p>
<h2 id="使-Object-数据变得可观测"><a href="#使-Object-数据变得可观测" class="headerlink" title="使 Object 数据变得可观测"></a>使 Object 数据变得可观测</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">let car &#x3D; &#123;&#125;</span><br><span class="line">let val &#x3D; 3000</span><br><span class="line">Object.defineProperty(car,&#39;price&#39;,&#123;</span><br><span class="line">  enumber: true,</span><br><span class="line">  configurable: true,</span><br><span class="line">  get()&#123;</span><br><span class="line">    console.log(&#39;price 属性被读取&#39;)</span><br><span class="line">    return val</span><br><span class="line">  &#125;,</span><br><span class="line">  set(newVal)&#123;</span><br><span class="line">    console.log(&#39;price 属性值被修改)</span><br><span class="line">    val &#x3D; newVal</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">car.price</span><br><span class="line">  &#x2F;&#x2F; price属性被读取了</span><br><span class="line">  &#x2F;&#x2F; 3000</span><br><span class="line">car.price &#x3D; 4000</span><br><span class="line">  &#x2F;&#x2F; price属性值被修改了</span><br><span class="line">  &#x2F;&#x2F; 4000</span><br></pre></td></tr></table></figure>

<p>经过上面的方法，car 数据对象已经是 <code>可观测</code> 的了。<br>为了把 car 对象所有的属性都变得可观测</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Observer类会通过递归的方式把一个对象的所有属性都转化成可观测对象</span><br><span class="line"> *&#x2F;</span><br><span class="line">export class Observer &#123;</span><br><span class="line">  constructor (value) &#123;</span><br><span class="line">    this.value &#x3D; value</span><br><span class="line">    &#x2F;&#x2F; 给value新增一个__ob__属性，值为该value的Observer实例</span><br><span class="line">    &#x2F;&#x2F; 相当于为value打上标记，表示它已经被转化成响应式了，避免重复操作</span><br><span class="line">    def(value,&#39;__ob__&#39;,this)</span><br><span class="line">    if (Array.isArray(value)) &#123;</span><br><span class="line">      &#x2F;&#x2F; 当value为数组时的逻辑</span><br><span class="line">      &#x2F;&#x2F; ...</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      this.walk(value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  walk (obj: Object) &#123;</span><br><span class="line">    const keys &#x3D; Object.keys(obj)</span><br><span class="line">    for (let i &#x3D; 0; i &lt; keys.length; i++) &#123;</span><br><span class="line">      defineReactive(obj, keys[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;**</span><br><span class="line"> * 使一个对象转化成可观测对象</span><br><span class="line"> * @param &#123; Object &#125; obj 对象</span><br><span class="line"> * @param &#123; String &#125; key 对象的key</span><br><span class="line"> * @param &#123; Any &#125; val 对象的某个key的值</span><br><span class="line"> *&#x2F;</span><br><span class="line">function defineReactive (obj,key,val) &#123;</span><br><span class="line">  &#x2F;&#x2F; 如果只传了obj和key，那么val &#x3D; obj[key]</span><br><span class="line">  if (arguments.length &#x3D;&#x3D;&#x3D; 2) &#123;</span><br><span class="line">    val &#x3D; obj[key]</span><br><span class="line">  &#125;</span><br><span class="line">  if(typeof val &#x3D;&#x3D;&#x3D; &#39;object&#39;)&#123;</span><br><span class="line">      new Observer(val)</span><br><span class="line">  &#125;</span><br><span class="line">  Object.defineProperty(obj, key, &#123;</span><br><span class="line">    enumerable: true,</span><br><span class="line">    configurable: true,</span><br><span class="line">    get()&#123;</span><br><span class="line">      console.log(&#96;$&#123;key&#125;属性被读取了&#96;);</span><br><span class="line">      return val;</span><br><span class="line">    &#125;,</span><br><span class="line">    set(newVal)&#123;</span><br><span class="line">      if(val &#x3D;&#x3D;&#x3D; newVal)&#123;</span><br><span class="line">          return</span><br><span class="line">      &#125;</span><br><span class="line">      console.log(&#96;$&#123;key&#125;属性被修改了&#96;);</span><br><span class="line">      val &#x3D; newVal;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="依赖收集"><a href="#依赖收集" class="headerlink" title="依赖收集"></a>依赖收集</h2><h3 id="什么是依赖收集"><a href="#什么是依赖收集" class="headerlink" title="什么是依赖收集"></a>什么是依赖收集</h3><p>通过上面的方法，让<code>object</code>变的可观测，我们知道数据什么时候发生了变化，我们去通知视图更新，我们到底通知那个模块发生变化？ 不能一个数据发生变化，整个视图就发生更新，因此我们只更新视图中用到这个数据就发生更新。也就是 <code>谁依赖了这个数据</code>，我们为每个数据都建一个依赖数组，谁依赖这个数据，我们就将谁放入这个依赖数组中，那么当该数据发生变化时我们就去它对应的依赖数组中，把每个依赖都通知一遍，发生更新。</p>
<h3 id="什么时候收集依赖，什么时候通知以此来更新"><a href="#什么时候收集依赖，什么时候通知以此来更新" class="headerlink" title="什么时候收集依赖，什么时候通知以此来更新"></a>什么时候收集依赖，什么时候通知以此来更新</h3><p>在 getter 中收集依赖，在 setter 中通知依赖更新</p>
<h3 id="依赖收集到哪里"><a href="#依赖收集到哪里" class="headerlink" title="依赖收集到哪里"></a>依赖收集到哪里</h3><p>我们给每个数据都建一个依赖数组，蛋蛋用一个数组的来存放依赖的话，功能欠缺并且代码过于耦合。更好的做法是我们为每一个依赖数据都建立一个依赖管理器，将该数据的依赖都管理起来。 依赖管理器 <code>Dep</code>类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 源码位置：src&#x2F;core&#x2F;observer&#x2F;dep.js</span><br><span class="line">export default class Dep &#123;</span><br><span class="line">  constructor () &#123;</span><br><span class="line">    this.subs &#x3D; []</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  addSub (sub) &#123;</span><br><span class="line">    this.subs.push(sub)</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 删除一个依赖</span><br><span class="line">  removeSub (sub) &#123;</span><br><span class="line">    remove(this.subs, sub)</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 添加一个依赖</span><br><span class="line">  depend () &#123;</span><br><span class="line">    if (window.target) &#123;</span><br><span class="line">      this.addSub(window.target)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 通知所有依赖更新</span><br><span class="line">  notify () &#123;</span><br><span class="line">    const subs &#x3D; this.subs.slice()</span><br><span class="line">    for (let i &#x3D; 0, l &#x3D; subs.length; i &lt; l; i++) &#123;</span><br><span class="line">      subs[i].update()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Remove an item from an array</span><br><span class="line"> *&#x2F;</span><br><span class="line">export function remove (arr, item) &#123;</span><br><span class="line">  if (arr.length) &#123;</span><br><span class="line">    const index &#x3D; arr.indexOf(item)</span><br><span class="line">    if (index &gt; -1) &#123;</span><br><span class="line">      return arr.splice(index, 1)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有了依赖管理器后，在 getter 中收集依赖，在 setter 中通知依赖更新，代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">function defineReactive (obj,key,val)&#123;</span><br><span class="line">  if (arguments.length &#x3D;&#x3D;&#x3D; 2) &#123;</span><br><span class="line">    val &#x3D; obj[key]</span><br><span class="line">  &#125;</span><br><span class="line">  if (typeof val &#x3D;&#x3D;&#x3D; &#39;Object&#39;) &#123;</span><br><span class="line">    new Observer(val)</span><br><span class="line">  &#125;</span><br><span class="line">  cosnt dep &#x3D; new Dep() &#x2F;&#x2F; 实例化一个依赖管理器，生成一个依赖管理数组 dep</span><br><span class="line">  Object.defineProperty(obj,key,&#123;</span><br><span class="line">    enumberable:true,</span><br><span class="line">    configurable:true,</span><br><span class="line">    get () &#123;</span><br><span class="line">      dep.depend() &#x2F;&#x2F; 在getter中收集依赖</span><br><span class="line">      return val</span><br><span class="line">    &#125;,</span><br><span class="line">    set (newVal) &#123;</span><br><span class="line">      if(val &#x3D;&#x3D; newVal) &#123;</span><br><span class="line">        return</span><br><span class="line">      &#125;</span><br><span class="line">      val &#x3D; newVal</span><br><span class="line">      dep.notify()  &#x2F;&#x2F; 在setter中通知依赖更新</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="依赖到底是-Who"><a href="#依赖到底是-Who" class="headerlink" title="依赖到底是 Who"></a>依赖到底是 Who</h4><p>一直在说 <code>谁用到了这个数据谁就是依赖</code>，在代码层面上该如何来描述这个<code>谁</code>。<br>在 <code>Vue</code> 中有一个叫 <code>Watcher</code> 的类，该类的实例就是我们上面说的那个<code>谁</code>，也就是谁用到了数据，谁就是依赖，我们为谁创建一个<code>Watcher</code>实例，在之后数据发生变化时，我们不直接通知依赖更新，而是通知依赖对应的 <code>watch</code> 实例，由 <code>Watchr</code>实例去通知真正的视图。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">export default class Watcher &#123;</span><br><span class="line">  constructor (vm,expOrFn,cb) &#123;</span><br><span class="line">    this.vm &#x3D; vm;</span><br><span class="line">    this.cb &#x3D; cb;</span><br><span class="line">    this.getter &#x3D; parsePath(expOrFn)</span><br><span class="line">    this.value &#x3D; this.get()</span><br><span class="line">  &#125;</span><br><span class="line">  get () &#123;</span><br><span class="line">    window.target &#x3D; this;</span><br><span class="line">    const vm &#x3D; this.vm</span><br><span class="line">    let value &#x3D; this.getter.call(vm,vm)</span><br><span class="line">    window.target &#x3D; undefined;</span><br><span class="line">    return value</span><br><span class="line">  &#125;</span><br><span class="line">  update () &#123;</span><br><span class="line">    const oldVlaue &#x3D; this.value</span><br><span class="line">    this.value &#x3D; this.get()</span><br><span class="line">    this.cb.call(this.vm,this.value,oldValue)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">const bailRE &#x3D; &#x2F;[^\w.$]&#x2F;</span><br><span class="line">export function parsePath (path) &#123;</span><br><span class="line">  if (bailRE.test(path)) &#123;</span><br><span class="line">    return</span><br><span class="line">  &#125;</span><br><span class="line">  const segments &#x3D; path.split(&#39;.&#39;)</span><br><span class="line">  return function (obj) &#123;</span><br><span class="line">    for (let i &#x3D; 0; i &lt; segments.length; i++) &#123;</span><br><span class="line">      if (!obj) return</span><br><span class="line">      obj &#x3D; obj[segments[i]]</span><br><span class="line">    &#125;</span><br><span class="line">    return obj</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Watcher</code>类代码实现逻辑</p>
<ul>
<li><p>当实例化<code>Watcher</code>类时，会先执行其构造函数；</p>
</li>
<li><p>在构造函数中调用了<code>this.get()</code>实例方法</p>
</li>
<li><p>在<code>get()</code>方法中，首先通过 <code>window.target = this</code> 把实例自身赋值给了一个全局<br>的一个唯一对象<code>window.target</code> 上，然后通过 <code>let value = this.getter.call(vm,vm)</code> 获取一下被依赖的数据，获取被依赖数据的目的是触发该数据上面的<code>getter</code>,在<code>getter</code> 里会调用<code>dep.depend()</code> 收集依赖，而在<code>dep.depend()</code>中取到挂<code>window.target</code> 上的值并将其存入依赖数组中，在<code>get()</code>方法最后将<code>window.target</code>释放掉。</p>
</li>
<li><p>当数据变化时，会触发数据的<code>setter</code>，在<code>setter</code>中调用<code>dep.notify()</code>方法，在<code>dep.notify()</code> 方法中，遍历所有依赖(即 watcher 实例)，执行依赖的<code>update()</code>方法，也就时 <code>Watcher</code>类中的<code>update()</code>实例方法，在<code>update()</code> 方法中调用数据变化的更新回调函数，从而更新视图。</p>
<p><img src="https://vue-js.com/learn-vue/assets/img/3.0b99330d.jpg" alt="avatar"></p>
</li>
</ul>
<p>以上的流程是</p>
<ul>
<li><p><code>Data</code> 通过 <code>observer</code> 转换成了 <code>getter/setter</code>的形式来追踪变化</p>
</li>
<li><p>当外界通过<code>Watcher</code>读取数据时，会触发<code>getter</code>从而将 <code>Watcher</code> 添加到依赖中。</p>
</li>
<li><p>当数据发生了变化时，会触发<code>setter</code>, 从而向 <code>Dep</code> 中的依赖(即 Watcher) 发送通知。</p>
</li>
<li><p><code>Watcher</code> 接收到通知后，会向外界发送通知，变化通知到外界后可能会触发视图更新，也有可能触发用户的某个回调函数等。</p>
</li>
</ul>
<h2 id="Array-的变化侦测"><a href="#Array-的变化侦测" class="headerlink" title="Array 的变化侦测"></a>Array 的变化侦测</h2><h3 id="收集依赖的地方"><a href="#收集依赖的地方" class="headerlink" title="收集依赖的地方"></a>收集依赖的地方</h3><p><code>Array</code> 型数据的依赖收集方式和 <code>Object</code> 数据的依赖收集方式相同，都是在<code>getter</code>中收集。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data()&#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    arr:[1,2,3]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在组件<code>data</code>中，<code>arr</code>这个数据始终存在于一个<code>Object</code>数据对象中，谁用到了数据谁就是依赖，那么用到<code>arr</code>这个数据，得先从<code>Object</code>数据对象中获取一下，从<code>Object</code>数据对象中获取<code>arr</code>数据自然会触发 <code>arr</code>的 <code>getter</code><br><code>Array型数据还是在getter中收集依赖</code></p>
<h3 id="使-Array-型数据可观测"><a href="#使-Array-型数据可观测" class="headerlink" title="使 Array 型数据可观测"></a>使 Array 型数据可观测</h3><ul>
<li>实现思路<br>要想让<code>Array</code> 型数据发生变化，必然是操作了 <code>Array</code> , 而 <code>js</code> 中提供的操作数组的方法是固定的，可以将这些方法都重写一遍，在不改变原有功能的前提下，为其新增一些其他功能，</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let arr &#x3D; [1,2,3]</span><br><span class="line">arr.push(4)</span><br><span class="line">Array.prototype.newPush &#x3D; function(val)&#123;</span><br><span class="line">  console.log(&#39;arr 数组被改变了&#39;)</span><br><span class="line">  this.push(val)</span><br><span class="line">&#125;</span><br><span class="line">arr.newPush(4) &#x2F;&#x2F; [1,2,3,4]</span><br></pre></td></tr></table></figure>

<ul>
<li>数组方法拦截器</li>
</ul>
<p>在<code>Vue</code>中创建一个数组方法拦截器，拦截在数组实例与<code>Array.prototype</code>之间，在拦截器内部重写操作数组的一些方法，当数组实例使用操作数组方法时，其实使用的是拦截器中重写的方法，不再使用<code>Array.prototype</code> 上的原生方法</p>
<p><img src="https://vue-js.com/learn-vue/assets/img/2.b446ab83.png" alt="avatar"></p>
<p>源码中的拦截器代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">const arrayProto &#x3D; Array.prototype</span><br><span class="line">export const arrayMethods &#x3D; Object.create(arrayProto)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 改变数组自身内容的7个方法</span><br><span class="line">const methodsToPatch &#x3D; [</span><br><span class="line">  &#39;push&#39;,</span><br><span class="line">  &#39;pop&#39;,</span><br><span class="line">  &#39;shift&#39;,</span><br><span class="line">  &#39;unshift&#39;,</span><br><span class="line">  &#39;splice&#39;,</span><br><span class="line">  &#39;sort&#39;,</span><br><span class="line">  &#39;reverse&#39;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Intercept mutating methods and emit events</span><br><span class="line"> *&#x2F;</span><br><span class="line">methodsToPatch.forEach(function (method) &#123;</span><br><span class="line">  const original &#x3D; arrayProto[method]      &#x2F;&#x2F; 缓存原生方法</span><br><span class="line">  Object.defineProperty(arrayMethods, method, &#123;</span><br><span class="line">    enumerable: false,</span><br><span class="line">    configurable: true,</span><br><span class="line">    writable: true,</span><br><span class="line">    value:function mutator(...args)&#123;</span><br><span class="line">      const result &#x3D; original.apply(this, args)</span><br><span class="line">      return result</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>拦截器的使用</li>
</ul>
<p>源码实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">export default Observer &#123;</span><br><span class="line">  constructor (value) &#123;</span><br><span class="line">    this.value &#x3D; value</span><br><span class="line">    if (Array.isArray(value)) &#123;</span><br><span class="line">      const augment &#x3D; hasProto ? protoAugment : copyAugment</span><br><span class="line">      augment(value,arrayMethods,arrayKeys)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      this.walk(value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 能力检测： 判断 __proto__ 是否可用，有浏览器不支持该属性</span><br><span class="line">export const hasProto &#x3D; &#39;__proto__&#39; in &#123;&#125;</span><br><span class="line">const arrayKeys &#x3D; Object.getOwnPropertyNames(arrayMethods)</span><br><span class="line">&#x2F;**</span><br><span class="line"> * Augment an target Object or Array by intercepting</span><br><span class="line"> * the prototype chain using __proto__</span><br><span class="line"> *&#x2F;</span><br><span class="line">function protoAugment (target, src: Object, keys: any) &#123;</span><br><span class="line">  target.__proto__ &#x3D; src</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Augment an target Object or Array by defining</span><br><span class="line"> * hidden properties.</span><br><span class="line"> *&#x2F;</span><br><span class="line">&#x2F;* istanbul ignore next *&#x2F;</span><br><span class="line">function copyAugment (target: Object, src: Object, keys: Array&lt;string&gt;) &#123;</span><br><span class="line">  for (let i &#x3D; 0, l &#x3D; keys.length; i &lt; l; i++) &#123;</span><br><span class="line">    const key &#x3D; keys[i]</span><br><span class="line">    def(target, key, src[key])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="依赖收集-1"><a href="#依赖收集-1" class="headerlink" title="依赖收集"></a>依赖收集</h3><p>数组的依赖收集也在<code>getter</code> 中收集，而给数组数据添加<code>getter/setter</code> 都是在<code>Observer</code>类中完成的，在<code>Observer</code>类中收集依赖。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">export class Observer &#123;</span><br><span class="line">  constructor (value) &#123;</span><br><span class="line">    this.value &#x3D; value</span><br><span class="line">    this.dep &#x3D; new Dep()</span><br><span class="line">    if (Array.isArray(value)) &#123;</span><br><span class="line">      const augment &#x3D; hasProto</span><br><span class="line">        ? protoAugment</span><br><span class="line">        : copyAugment</span><br><span class="line">      augment(value, arrayMethods, arrayKeys)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      this.walk(value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>怎样收集依赖</li>
</ul>
<p>依赖管理器定义在<code>Observer</code> 类中，而我们需要在<code>getter</code>中收集依赖，也就是说我们必须在<code>getter</code>中能够访问到<code>Observer</code>类中的依赖管理器，才能把依赖存进去。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">function defineReactive (obj,key,val) &#123;</span><br><span class="line">  let childOb &#x3D; observe(val)</span><br><span class="line">  Object.defineProperty(obj, key, &#123;</span><br><span class="line">    enumerable: true,</span><br><span class="line">    configurable: true,</span><br><span class="line">    get()&#123;</span><br><span class="line">      if (childOb) &#123;</span><br><span class="line">        childOb.dep.depend()</span><br><span class="line">      &#125;</span><br><span class="line">      return val;</span><br><span class="line">    &#125;,</span><br><span class="line">    set(newVal)&#123;</span><br><span class="line">      if(val &#x3D;&#x3D;&#x3D; newVal)&#123;</span><br><span class="line">        return</span><br><span class="line">      &#125;</span><br><span class="line">      val &#x3D; newVal;</span><br><span class="line">      dep.notify()   &#x2F;&#x2F; 在setter中通知依赖更新</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Attempt to create an observer instance for a value,</span><br><span class="line"> * returns the new observer if successfully observed,</span><br><span class="line"> * or the existing observer if the value already has one.</span><br><span class="line"> * 尝试为value创建一个0bserver实例，如果创建成功，直接返回新创建的Observer实例。</span><br><span class="line"> * 如果 Value 已经存在一个Observer实例，则直接返回它</span><br><span class="line"> *&#x2F;</span><br><span class="line">export function observe (value, asRootData)&#123;</span><br><span class="line">  if (!isObject(value) || value instanceof VNode) &#123;</span><br><span class="line">    return</span><br><span class="line">  &#125;</span><br><span class="line">  let ob</span><br><span class="line">  if (hasOwn(value, &#39;__ob__&#39;) &amp;&amp; value.__ob__ instanceof Observer) &#123;</span><br><span class="line">    ob &#x3D; value.__ob__</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    ob &#x3D; new Observer(value)</span><br><span class="line">  &#125;</span><br><span class="line">  return ob</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>怎样通知依赖</li>
</ul>
<p>要想通知依赖，首先能访问到依赖，即只要能访问到被转化成响应式的数据 <code>value</code> 即可，因为<code>value</code> 上的 <code>__ob__</code>就是其对应的<code>Observer</code> 类实例，有了该实例我们就能访问到它上面的依赖管理器，然后只需要调用依赖管理的 <code>dep.notify()</code> 方法，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 源码</span><br><span class="line">methodsToPatch.forEach(function (method) &#123;</span><br><span class="line">  const original &#x3D; arrayProto[method]</span><br><span class="line">  def(arrayMethods, method, function mutator (...args) &#123;</span><br><span class="line">    const result &#x3D; original.apply(this, args)</span><br><span class="line">    const ob &#x3D; this.__ob__</span><br><span class="line">    &#x2F;&#x2F; notify change</span><br><span class="line">    ob.dep.notify()</span><br><span class="line">    return result</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="深度侦测"><a href="#深度侦测" class="headerlink" title="深度侦测"></a>深度侦测</h3><p>在前文所有讲的 Array 型数据的变化侦测都仅仅说的是数组自身变化的侦测，比如给数组新增一个元素或删除数组中一个元素，而在 Vue 中，不论是 Object 型数据还是 Array 型数据所实现的数据变化侦测都是深度侦测，所谓深度侦测就是不但要侦测数据自身的变化，还要侦测数据中所有子数据的变化。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let arr &#x3D; [</span><br><span class="line">  &#123;</span><br><span class="line">    name:&#39;NLRX&#39;，</span><br><span class="line">    age:&#39;18&#39;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>数组中包含一个对象，如果该对象的某个属性发生了变化也应该被侦测到，就是深度侦测。<br>实现逻辑</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">export class Observer &#123;</span><br><span class="line">  value: any;</span><br><span class="line">  dep: Dep;</span><br><span class="line"></span><br><span class="line">  constructor (value: any) &#123;</span><br><span class="line">    this.value &#x3D; value</span><br><span class="line">    this.dep &#x3D; new Dep()</span><br><span class="line">    def(value, &#39;__ob__&#39;, this)</span><br><span class="line">    if (Array.isArray(value)) &#123;</span><br><span class="line">      const augment &#x3D; hasProto</span><br><span class="line">        ? protoAugment</span><br><span class="line">        : copyAugment</span><br><span class="line">      augment(value, arrayMethods, arrayKeys)</span><br><span class="line">      this.observeArray(value)   &#x2F;&#x2F; 将数组中的所有元素都转化为可被侦测的响应式</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      this.walk(value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;**</span><br><span class="line">   * Observe a list of Array items.</span><br><span class="line">   *&#x2F;</span><br><span class="line">  observeArray (items: Array&lt;any&gt;) &#123;</span><br><span class="line">    for (let i &#x3D; 0, l &#x3D; items.length; i &lt; l; i++) &#123;</span><br><span class="line">      observe(items[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function observe (value, asRootData)&#123;</span><br><span class="line">  if (!isObject(value) || value instanceof VNode) &#123;</span><br><span class="line">    return</span><br><span class="line">  &#125;</span><br><span class="line">  let ob</span><br><span class="line">  if (hasOwn(value, &#39;__ob__&#39;) &amp;&amp; value.__ob__ instanceof Observer) &#123;</span><br><span class="line">    ob &#x3D; value.__ob__</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    ob &#x3D; new Observer(value)</span><br><span class="line">  &#125;</span><br><span class="line">  return ob</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数组新增元素的侦测"><a href="#数组新增元素的侦测" class="headerlink" title="数组新增元素的侦测"></a>数组新增元素的侦测</h3><p>向数组内新增的方法有 3 个，分别是：push、unshift、splice。我们只需对这 3 中方法分别处理，拿到新增的元素，再将其转化即可</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Intercept mutating methods and emit events</span><br><span class="line"> *&#x2F;</span><br><span class="line">methodsToPatch.forEach(function (method) &#123;</span><br><span class="line">  &#x2F;&#x2F; cache original method</span><br><span class="line">  const original &#x3D; arrayProto[method]</span><br><span class="line">  def(arrayMethods, method, function mutator (...args) &#123;</span><br><span class="line">    const result &#x3D; original.apply(this, args)</span><br><span class="line">    const ob &#x3D; this.__ob__</span><br><span class="line">    let inserted</span><br><span class="line">    switch (method) &#123;</span><br><span class="line">      case &#39;push&#39;:</span><br><span class="line">      case &#39;unshift&#39;:</span><br><span class="line">        inserted &#x3D; args   &#x2F;&#x2F; 如果是push或unshift方法，那么传入参数就是新增的元素</span><br><span class="line">        break</span><br><span class="line">      case &#39;splice&#39;:</span><br><span class="line">        inserted &#x3D; args.slice(2) &#x2F;&#x2F; 如果是splice方法，那么传入参数列表中下标为2的就是新增的元素</span><br><span class="line">        break</span><br><span class="line">    &#125;</span><br><span class="line">    if (inserted) ob.observeArray(inserted) &#x2F;&#x2F; 调用observe函数将新增的元素转化成响应式</span><br><span class="line">    &#x2F;&#x2F; notify change</span><br><span class="line">    ob.dep.notify()</span><br><span class="line">    return result</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2022/04/13/vue%E6%BA%90%E7%A0%81/" data-id="cl83x4csb000cwgdx0gbk9nfa" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-props与Data的区别" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/04/13/props%E4%B8%8EData%E7%9A%84%E5%8C%BA%E5%88%AB/" class="article-date">
  <time datetime="2022-04-13T07:41:31.003Z" itemprop="datePublished">2022-04-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Vue-js/">Vue.js</a>►<a class="article-category-link" href="/categories/Vue-js/Props%E4%B8%8EData%E7%9A%84%E5%8C%BA%E5%88%AB/">Props与Data的区别</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/04/13/props%E4%B8%8EData%E7%9A%84%E5%8C%BA%E5%88%AB/">Vue.js 源码解读, 虚拟Dom</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Vue-中的Props-与-Data-细微差别。"><a href="#Vue-中的Props-与-Data-细微差别。" class="headerlink" title="Vue 中的Props 与 Data 细微差别。"></a>Vue 中的Props 与 Data 细微差别。</h1><p>Vue 提供了两种不同的存储变量: <code>props</code> 和 <code>data</code>。</p>
<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p><code>data</code> 是每个组件的私有内存，可以在其中存储需要的任何变量。<code>props</code>是将数据从父组件传递到子组件的方式。</p>
<h2 id="什么是-props"><a href="#什么是-props" class="headerlink" title="什么是 props"></a>什么是 props</h2><p>在 <code>Vue</code> 中 <code>props</code> 是我们将数据从父组件向下传递到其子组件的方式。<br>当我们从组件内部访问<code>props</code>时，我们并不拥有他们，我们不能更改他们。</p>
<h2 id="什么是-Data"><a href="#什么是-Data" class="headerlink" title="什么是 Data"></a>什么是 Data</h2><p><code>data</code> 是每个组件的内存，这就是存储数据和希望跟踪的任何其他变量的地方。</p>
<h2 id="props-和-data-都是响应式的"><a href="#props-和-data-都是响应式的" class="headerlink" title="props 和 data 都是响应式的"></a>props 和 data 都是响应式的</h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2022/04/13/props%E4%B8%8EData%E7%9A%84%E5%8C%BA%E5%88%AB/" data-id="cl83x4csa000awgdxhryga66z" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-js知识体系/数据" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/04/13/js%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/%E6%95%B0%E6%8D%AE/" class="article-date">
  <time datetime="2022-04-13T07:41:31.001Z" itemprop="datePublished">2022-04-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/js%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/">js知识体系</a>►<a class="article-category-link" href="/categories/js%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/%E6%95%B0%E6%8D%AE/">数据</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/04/13/js%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/%E6%95%B0%E6%8D%AE/">JS 数据</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="原始数据"><a href="#原始数据" class="headerlink" title="原始数据"></a>原始数据</h1><p>原始数据类型共有六种：Number 、String 、Boolean 、 Undefined 、 Null 、Symbol</p>
<h2 id="Number-数据类型"><a href="#Number-数据类型" class="headerlink" title="Number 数据类型"></a>Number 数据类型</h2><p>Number 数据类型包含数字和 NaN</p>
<h3 id="NaN"><a href="#NaN" class="headerlink" title="NaN"></a>NaN</h3><p><code>NaN</code> 非数字，不是一个数但是隶属于数字类型 NaN 和任何值(包括自己)相比较，不大于、不小于、不等于任何值。</p>
<p>判断是不是数字类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">isNaN(&#39;1243&#39;)   &#x2F;&#x2F; false 虽然&#39;123&#39; 是字符串类型，但是由于是纯数字组成可以转换成一个数字</span><br><span class="line"></span><br><span class="line">isNaN(123)    &#x2F;&#x2F; false 说明是数字</span><br><span class="line"></span><br><span class="line">isNaN(&#39;123ffff&#39;) &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<h3 id="数字不同进制"><a href="#数字不同进制" class="headerlink" title="数字不同进制"></a>数字不同进制</h3><p>Number 可以使用四种数字进制：十进制，二进制，八进制和十六进制<br>二进制：以零为开头，后面接一个小写或大写的拉丁文字母 B(0b 或者 0B)<br>八进制：以零为开头，假如 0 后面的数字不在 0 到 7 的范围内，改数字会被转换成十进制数字<br>十六进制：以零为开头，后面接一个小写或大写的拉丁文字母(0x 或者 0X)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 十进制</span><br><span class="line">1234566</span><br><span class="line">12</span><br><span class="line">&#x2F;&#x2F; 二进制</span><br><span class="line">0b1100    &#x2F;&#x2F; 12</span><br><span class="line">0b0001    &#x2F;&#x2F; 1</span><br><span class="line">&#x2F;&#x2F; 八进制</span><br><span class="line">0755    &#x2F;&#x2F; 493</span><br><span class="line">0644    &#x2F;&#x2F; 420</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 十六进制</span><br><span class="line">0xA     &#x2F;&#x2F; 10</span><br></pre></td></tr></table></figure>

<h3 id="转换成数字方法"><a href="#转换成数字方法" class="headerlink" title="转换成数字方法"></a>转换成数字方法</h3><p>Number()、parseInt()、parseFloat()</p>
<h4 id="Number"><a href="#Number" class="headerlink" title="Number()"></a>Number()</h4><p>可以用于任何数据类型，</p>
<ul>
<li><p>转换规则</p>
<ul>
<li><p>Boolean 值，true 转换成 1，false 转换成 0</p>
</li>
<li><p>null 值，返回 0。</p>
</li>
<li><p>undefined，返回 NaN</p>
</li>
<li><p>如果是字符串，遵循的规则</p>
<ul>
<li><p>只包含数字(包括带正负号的情况)，则转换为十进制，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Number(&#39;1&#39;)   &#x2F;&#x2F; 1</span><br><span class="line">Number(&#39;+1&#39;)  &#x2F;&#x2F; 1</span><br><span class="line">Number(&#39;011&#39;) &#x2F;&#x2F; 11   前导的零被忽略</span><br></pre></td></tr></table></figure></li>
<li><p>字符是有效的浮点数格式，则将其转换成相对应的浮点数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Number(&#39;-1.1&#39;)   &#x2F;&#x2F; -1.1</span><br><span class="line">Number(&#39;01.1&#39;)   &#x2F;&#x2F; 1.1</span><br><span class="line">Number(&#39;-01.12&#39;) &#x2F;&#x2F; 1.12</span><br></pre></td></tr></table></figure></li>
<li><p>字符串包含有效的十六进制或者二进制格式，则将其转换为相同大小的十进制整数值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Number(&#39;0xF&#39;)   &#x2F;&#x2F; 15</span><br><span class="line">Number(&#39;0b1000&#39;) &#x2F;&#x2F; 8</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果是空字符串，则将其转换为 0 Number(‘’) // 0</p>
</li>
<li><p>如果不符合上面的，将其转换成 NaN Number(‘0www’) // NaN</p>
</li>
</ul>
</li>
<li><p>如果是对象，则调用 valueOf() 方法，然后依照前面的规则转换返回的值，如果转换的值是 NaN ,则调用对象的 toString() 方法，然后再按照前面的规则转换字符串。</p>
</li>
</ul>
</li>
</ul>
<h4 id="parseInt"><a href="#parseInt" class="headerlink" title="parseInt()"></a>parseInt()</h4><p>处理整数的时候，更常用 parseInt()函数<br>在转换字符串时是看其是否符合数值模式，会忽略字符串前面的空格，如果第一个字符不是数字或者符号就会返回 NaN</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">parseInt(&#39;123456blue&#39;)   &#x2F;&#x2F; 123456</span><br><span class="line">parseInt(&#39;&#39;)             &#x2F;&#x2F; NaN</span><br><span class="line">parseInt(&#39;22.34&#39;)        &#x2F;&#x2F; 22</span><br><span class="line">parseInt(&#39;0xa&#39;)          &#x2F;&#x2F; 10  符合十六进制，转换成十进制</span><br><span class="line">parseInt(&#39;070&#39;)          &#x2F;&#x2F; 56  符合八进制，</span><br><span class="line">parseInt(&#39;70&#39;)           &#x2F;&#x2F; 70</span><br><span class="line">parseInt(&#39;0b1100&#39;)       &#x2F;&#x2F; 0</span><br></pre></td></tr></table></figure>

<p>在包含进制的时候，parseInt(),可以有第二个参数，说明是几进制</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">parseInt(&#39;10&#39;,2) &#x2F;&#x2F;2 按二进制解析转换为十进制</span><br><span class="line">parseInt(&#39;10&#39;,8) &#x2F;&#x2F;8 按八进制解析转换为十进制</span><br><span class="line">parseInt(&#39;10&#39;,10) &#x2F;&#x2F;10 按八进制解析转换为十进制</span><br><span class="line">parseInt(&#39;10&#39;,16) &#x2F;&#x2F;16 按十六进制解析转换为十进制</span><br></pre></td></tr></table></figure>

<h4 id="parseFloat"><a href="#parseFloat" class="headerlink" title="parseFloat()"></a>parseFloat()</h4><p>parseFloat() 与 parseInt() 的解析方法基本一样，对浮点数和进制数不同<br>parseFloat 会忽略前置零</p>
<p>parseFloat() 对于二进制，十六进制的转换都是 0</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">parseFloat(&#39;123456blue&#39;)   &#x2F;&#x2F; 123456</span><br><span class="line">parseFloat(&#39;&#39;)             &#x2F;&#x2F; NaN</span><br><span class="line">parseFloat(&#39;22.34&#39;)        &#x2F;&#x2F; 22.34</span><br><span class="line">parseFloat(&#39;0xa&#39;)          &#x2F;&#x2F; 0  十六进制字符串始终为零</span><br><span class="line">parseFloat(&#39;070&#39;)          &#x2F;&#x2F; 70</span><br><span class="line">parseFloat(&#39;70&#39;)           &#x2F;&#x2F; 70</span><br><span class="line">parseFloat(&#39;0b1100&#39;)       &#x2F;&#x2F; 0</span><br></pre></td></tr></table></figure>

<h2 id="String-类型"><a href="#String-类型" class="headerlink" title="String 类型"></a>String 类型</h2><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let strObject &#x3D; new String(&#39;hello word&#39;)</span><br><span class="line">let strs &#x3D; &#39;hello word&#39;</span><br><span class="line"></span><br><span class="line">typeof (strObject)   &#x2F;&#x2F; object</span><br><span class="line">typeof(strs)  &#x2F;&#x2F; String</span><br></pre></td></tr></table></figure>

<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p>string 具有长度属性，字符串长度(空格也占位),可以通过 string[index]来访问对应的字符</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let str &#x3D; &#39;today is good day&#39;</span><br><span class="line">str.length &#x2F;&#x2F; 17</span><br><span class="line">str[2]     &#x2F;&#x2F; d</span><br></pre></td></tr></table></figure>

<h3 id="string-方法"><a href="#string-方法" class="headerlink" title="string 方法"></a>string 方法</h3><ul>
<li><p>charAt(n)<br>传入数值，返回该位置对应字符</p>
</li>
<li><p>charCodeAt(n)<br>传入数值，返回该位置对应字符编码</p>
</li>
<li><p>slice(n,m) 字符串截取，接受一个或者两个值<br>从 index 为 n 开始(包括 n),到 index 为 m 结束(不包括 m) 返回一个新的字符串，不改变原字符串。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var str &#x3D; &#39;DaShu.yang&#39;</span><br><span class="line">str.charAt(2) &#x2F;&#x2F; 3</span><br><span class="line">str.charCodeAt(2) &#x2F;&#x2F; 83</span><br><span class="line">str.slice(2)   &#x2F;&#x2F; Shu.yang</span><br><span class="line">str.slice(2,3) &#x2F;&#x2F; S</span><br></pre></td></tr></table></figure>

<ul>
<li><p>indexOf()<br>搜索给定字符串，然后返回字符串的位置(找到返回该字符串的 index 值，反之返回 -1)，可以接受第二个参数，表示从字符串中的哪个位置开始搜索。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let str &#x3D; &#39;qwertyuiop&#39;;</span><br><span class="line">str.indexOf(&#39;w&#39;) &#x2F;&#x2F; 1</span><br><span class="line">str.indexOf(&#39;m&#39;)  &#x2F;&#x2F; -1</span><br></pre></td></tr></table></figure>
</li>
<li><p>match()<br>字符串的模式匹配方法，接收一个正则表达式或者 RegExp 对象，返回一个数组，如果没匹配值返回 null<br>该方法可在字符串内检索指定的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var str &#x3D; &#39;asdfghajk&#39;</span><br><span class="line">str.match(&#39;a&#39;)    &#x2F;&#x2F; [a] 查找是惰性的只会返回一个a,即查找到了第一个就返回查找结果。</span><br><span class="line">str.amtch(&#x2F;a&#x2F;g)   &#x2F;&#x2F; [ a,a ]</span><br></pre></td></tr></table></figure></li>
<li><p>replace()<br>字符串替换，接收两个参数，第一个参数为字符串或者正则表达式，第二个参数是字符串或者是一个函数，返回一个字符串。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var text &#x3D; &#39;cat,bat,sat,fat&#39;</span><br><span class="line">var reg &#x3D; &#x2F;at&#x2F;g</span><br><span class="line">str.replace(reg,&#39;&#39;)</span><br><span class="line">var str &#x3D; &#39;abcdefg&#39;</span><br><span class="line">var reg &#x3D; &#x2F;(c)d&#x2F;g</span><br><span class="line">str.replace(reg,&#39;$$d&#39;) &#x2F;&#x2F; ab$defg</span><br><span class="line">var reg1 &#x3D; &#x2F;(c)d(e)&#x2F;g</span><br><span class="line">str.replace(reg,&#39;$2$1&#39;)  &#x2F;&#x2F; abedcfg</span><br><span class="line">&#x2F;&#x2F;这里把匹配的第一个内容和第二个内容替换位置($1匹配第一个位置，$2匹配第二个位置，然后再替换整个匹配到的cde)</span><br></pre></td></tr></table></figure>
</li>
<li><p>split<br>字符串分割，接收两个参数，第一个字符串或者正则表达式，第二个是返回数组的最大长度，返回一个数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var text &#x3D; &#39;cat,bat,sat,fat&#39;</span><br><span class="line">text.split(&#39;,&#39;)       &#x2F;&#x2F; [&#39;cat&#39;,&#39;bat&#39;,&#39;sat&#39;,&#39;fat&#39;]</span><br><span class="line">text.split(&#39;,&#39;,3)     &#x2F;&#x2F; [&#39;cat&#39;,&#39;bat&#39;,&#39;sat&#39;]</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h2><h3 id="创建-1"><a href="#创建-1" class="headerlink" title="创建"></a>创建</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var boo &#x3D; new Boolean()    &#x2F;&#x2F; false 未对boo进行赋值，默认值为 false</span><br><span class="line">var boo new Boolean(true)  &#x2F;&#x2F; true</span><br><span class="line">var boo &#x3D; true&#x2F;false</span><br></pre></td></tr></table></figure>

<p>如果逻辑对象无初始值或者其值为 0 -0 null ‘’ false undefined NaN,那么对象的值为 false,否则其值为 true</p>
<ul>
<li>! 一个叹号是取反，首先将值转化为布尔类型的，然后再取反</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">!3 &#x2F;&#x2F; false -&gt;先把3转化为 boolean 此时为 true,然后再取反为 false</span><br><span class="line">!0 &#x2F;&#x2F; true -&gt; 先把 0 转化为 boolean 此时为 false,然后再取反为 true</span><br></pre></td></tr></table></figure>

<p>!! 将其他的数据类型转化为 boolean 类型，相当于 Boolean()</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Boolean(&#39;dddd&#39;) &#x2F;&#x2F; true</span><br><span class="line">!!&#39;dddd&#39;        &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<h3 id="不同数据类型的比较"><a href="#不同数据类型的比较" class="headerlink" title="不同数据类型的比较"></a>不同数据类型的比较</h3><ul>
<li><p>两个不同类型数据比较时隐式转换规则</p>
<ul>
<li><p>数字和字符串、布尔类型、数组进行比较时，字符串(或者布尔、或数组)先转换为数字(Number),再进行比较。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">123 &#x3D;&#x3D; &#39;1234a&#39;  &#x2F;&#x2F; false</span><br><span class="line">123 &#x3D;&#x3D; &#39;123&#39;    &#x2F;&#x2F; true</span><br><span class="line">123 &#x3D;&#x3D; false    &#x2F;&#x2F; false</span><br><span class="line">123 &#x3D;&#x3D; true     &#x2F;&#x2F; false</span><br></pre></td></tr></table></figure></li>
<li><p>字符串和布尔类型比较，进行比较的两个数据同时经过 Number() 的转换后再进行比较，数组和布尔类型的比较也如此</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#39;qwe&#39; &#x3D;&#x3D;  false   &#x2F;&#x2F; false   Number(&#39;qwe&#39;) -&gt; NaN ; Number(false) -&gt; 0</span><br><span class="line">&#39;qwe&#39; &#x3D;&#x3D; true     &#x2F;&#x2F; false</span><br><span class="line">&#39;&#39;  &#x3D;&#x3D;  false     &#x2F;&#x2F; true    Number(&#39;&#39;) -&gt; 0 ; Number(false) -&gt; 0</span><br><span class="line">&#39;&#39;  &#x3D;&#x3D;  true      &#x2F;&#x2F; false</span><br><span class="line">[]  &#x3D;&#x3D;  false     &#x2F;&#x2F; true    Number([]) -&gt; 0</span><br><span class="line">[0]  &#x3D;&#x3D;  false    &#x2F;&#x2F; true    Number([0]) -&gt; 0</span><br><span class="line">[00]  &#x3D;&#x3D;  false   &#x2F;&#x2F; true    Number([00]) -&gt; 0</span><br><span class="line">[0,0] &#x3D;&#x3D;  false   &#x2F;&#x2F; false   Number([0,0]) -&gt; NaN</span><br></pre></td></tr></table></figure></li>
<li><p>undefined 除了和 Null 进行非全等比较返回 true，其它均返回 false。</p>
</li>
<li><p>null 除了和 undefined 进行非全等比较返回 true，其它均返回 false。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">undefined &#x3D;&#x3D; nll    &#x2F;&#x2F; true</span><br><span class="line">undefined &#x3D;&#x3D; 124    &#x2F;&#x2F; false</span><br><span class="line">undefined &#x3D;&#x3D; &#39;123&#39;  &#x2F;&#x2F; false</span><br><span class="line">undefined &#x3D;&#x3D; false  &#x2F;&#x2F; false</span><br><span class="line">undefined &#x3D;&#x3D; true   &#x2F;&#x2F; false</span><br><span class="line"></span><br><span class="line">null &#x3D;&#x3D; undefined   &#x2F;&#x2F; true</span><br><span class="line">null &#x3D;&#x3D; 124         &#x2F;&#x2F; false</span><br><span class="line">null &#x3D;&#x3D; &#39;124&#39;       &#x2F;&#x2F; false</span><br><span class="line">null &#x3D;&#x3D; false       &#x2F;&#x2F; false</span><br><span class="line">null &#x3D;&#x3D; true        &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>
</li>
<li><p>数组(或对象) 和字符串进行比较时，数组(或对象) 会转换成字符串再进行比较</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[] &#x3D;&#x3D; &#39;&#39;   &#x2F;&#x2F; true</span><br><span class="line">[0] &#x3D;&#x3D; &#39;&#39;  &#x2F;&#x2F; false</span><br><span class="line">[0] &#x3D;&#x3D; &#39;0&#39; &#x2F;&#x2F; true</span><br><span class="line"></span><br><span class="line">var obj &#x3D; &#123;a:0&#125;</span><br><span class="line">obj &#x3D;&#x3D; &#39;&#39;  &#x2F;&#x2F; false</span><br><span class="line">obj &#x3D;&#x3D; &#39;[object Object]&#39; &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h2 id="Undefined-和-Null"><a href="#Undefined-和-Null" class="headerlink" title="Undefined 和 Null"></a>Undefined 和 Null</h2><p>undefined 表示 “缺少值”，就是此处应该有一个值，但是还没有定义。<br>用法:</p>
<ul>
<li>变量被声明了，但没有赋值时，就等于 undefined。</li>
<li>调用函数时，应该提供的参数没有提供，该参数等于 undefined。</li>
<li>对象没有赋值的属性，该属性的值为 undefined。</li>
<li>函数没有返回值时，默认返回 undefined。<br>null 表示 “没有对象”，即该处不应该有值<br>用法</li>
<li>作为函数的参数，表示该函数的参数不是对象。</li>
<li>作为原型链的终点。</li>
</ul>
<h2 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h2><p>本质上是一种唯一标识符，可作为对象的唯一属性名，别就不会改写或覆盖你设置的属性值</p>
<ul>
<li>创建</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let id &#x3D; Symbol(&#39;id&#39;)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>特点</p>
<ul>
<li><p>唯一性，即使是用同一个变量生成的值也不相等。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let id1 &#x3D; Symbol(&#39;id&#39;)</span><br><span class="line">let id2 &#x3D; Symbol(&#39;id&#39;)</span><br><span class="line">id1 &#x3D;&#x3D; id2                &#x2F;&#x2F; false</span><br></pre></td></tr></table></figure>
</li>
<li><p>隐藏性 for in Object.keys() 不能访问</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let id &#x3D; Symbol(&#39;id&#39;)</span><br><span class="line">let obj &#x3D; &#123;</span><br><span class="line">  [id]:&#39;symbol&#39;</span><br><span class="line">&#125;;</span><br><span class="line">for(let option in obj)&#123;</span><br><span class="line">  console.log(obj[option])   &#x2F;&#x2F; 空</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>Symbol.for()，Symbol.keyFor()</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let name1 &#x3D; Symbol.for(&#39;name&#39;)  &#x2F;&#x2F; 检测到未创建后返回</span><br><span class="line">let name2 &#x3D; Symbol.for(&#39;name&#39;)  &#x2F;&#x2F; 检测到已创建后返回</span><br><span class="line">name1 &#x3D;&#x3D;&#x3D; name2</span><br><span class="line">&#x2F;&#x2F; 访问值</span><br><span class="line">Symbol.keyFor(&#39;name1&#39;)  &#x2F;&#x2F; name</span><br><span class="line">Symbol.keyFor(&#39;name2&#39;)  &#x2F;&#x2F; name</span><br></pre></td></tr></table></figure>

<h1 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h1><ul>
<li>引用数据类型也就是对象数据类型 object (Object，Array,Function, data )</li>
<li>JavaScript 的引用数据类型是保存在堆内存中的对象，不可以直接访问堆内存空间中的位置和操作堆内存空间，只能操作对象在栈内存中的对象。</li>
<li>引用数据类型在栈内存中实际上保存的是对象在堆内存中的引用地址，通过该地址可以快速的查找到保存在堆内存中的对象。</li>
</ul>
<h2 id="数组-Array"><a href="#数组-Array" class="headerlink" title="数组(Array)"></a>数组(Array)</h2><p>数组是一组数据的集合，在内存中是一段连续的内存空间。<br>数组定义时可以无需指定数组长度<br>存储数据时无需指定具体的数据类型，可以存储任意类型。</p>
<h2 id="创建-2"><a href="#创建-2" class="headerlink" title="创建"></a>创建</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let arr1 &#x3D; []</span><br><span class="line">let arr2 &#x3D; new Array()</span><br><span class="line">let arr3 &#x3D; new Array(3) &#x2F;&#x2F; [empty*3]   创建一个数组，长度为三，值都为空。</span><br></pre></td></tr></table></figure>

<h2 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h2><h3 id="length-属性"><a href="#length-属性" class="headerlink" title="length 属性"></a>length 属性</h3><ul>
<li>length 属性表示数组的长度，即其中元素的个数。</li>
<li>当 length 属性被设置得更大时，数组将增大，新的元素将被添加到数组的尾部，他们的值为空(empty)</li>
<li>当 length 设置的值小于数组的长度时，数组将被截断，其尾部的元素将丢失。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let arr &#x3D; [1,2,3,4]</span><br><span class="line">arr.length &#x2F;&#x2F; 4</span><br><span class="line">arr.length &#x3D; 6 &#x2F;&#x2F; [1,2,3,4,expty*2]</span><br><span class="line">arr.length &#x3D; 2 &#x2F;&#x2F; [1,2]</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="数组的方法"><a href="#数组的方法" class="headerlink" title="数组的方法"></a>数组的方法</h3><h4 id="改变数组自身内容的方法"><a href="#改变数组自身内容的方法" class="headerlink" title="改变数组自身内容的方法"></a>改变数组自身内容的方法</h4><p><code>push() 、 pop()、 unshift()、 shift()、 reserve()、 splice()、 sort()、 fill()</code></p>
<ul>
<li><p>push() 和 pop()<br>push() 将某些值加入到数组的最后一个位置，不限制添加的数量，添加多项内容使用逗号隔开。<br>pop() 会移除数组的最后一个元素。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let a &#x3D; [1,2,3,4,5]</span><br><span class="line">a.push(6)       &#x2F;&#x2F; [1,2,3,4,5,6]</span><br><span class="line">a.push(7,8,9)   &#x2F;&#x2F; [1,2,3,4,5,6,7,8,9]</span><br><span class="line">a.pop()         &#x2F;&#x2F; [1,2,3,4,5,6,7,8]</span><br></pre></td></tr></table></figure></li>
<li><p>unshift(),shift()<br>unshift() 会将指定的元素添加到数组的第一个位置。<br>shift() 会移除数组的第一个元素。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let arr &#x3D; [1,2,3,4,5]</span><br><span class="line">arr.unshift(6)      &#x2F;&#x2F; [6,1,2,3,4,5]</span><br><span class="line">arr.unshit(7,8,9)   &#x2F;&#x2F; [7,8,9,6,1,2,3,4,5]</span><br><span class="line">arr.shift()         &#x2F;&#x2F; [8,9,6,1,2,3,4,5]</span><br></pre></td></tr></table></figure>
</li>
<li><p>reverse()<br>将数组反转</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let a &#x3D; [1,2,3,4,5,6]</span><br><span class="line">a.reverse()   &#x2F;&#x2F; [6,5,4,3,2,1]</span><br></pre></td></tr></table></figure></li>
<li><p>splice()<br>该方法可以移除或新增数列的元素，包含三个参数，一个是要移除或要添加的序列号(必填)，第二个是要移除的长度(选填。若不填则从第一个参数位置开始，后面的元素都会被移除，设为 0 表示不会有元素删除，第三个是要替换的内容)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let arr &#x3D; [1,2,3,4,5,6,7]</span><br><span class="line">arr.splice(1,1) &#x2F;&#x2F; [1,3,4,5,6,7]</span><br><span class="line">arr.splice(3,1,100) &#x2F;&#x2F; [1,3,4,100.6,7]</span><br><span class="line">arr.splice(2,0,200) &#x2F;&#x2F; [1,3,200,4,100,6,7]</span><br></pre></td></tr></table></figure></li>
<li><p>sort()<br>该方法可以针对数组的元素进行排序，里头包含一个排序的判断函数，函数内必须包含的两个参数，两个参数分别代表数组里第 n 个和第 n+1 个元素，通过比较第 n 个和第 n+1 个元素的大小来进行排序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let a &#x3D; [3,2,4,5,1,6,7,8]</span><br><span class="line">a.sort((a,b)&#x3D;&gt;a-b)  &#x2F;&#x2F; [1,2,3,4,5,6,7,8]</span><br><span class="line">a.sort((a,b)&#x3D;&gt;b-a)  &#x2F;&#x2F; [8,7,6,5,4,3,2,1]</span><br></pre></td></tr></table></figure>
<p>若不使用判断函数，<code>默认会将元素换成字符串，并采用 unicode 来判断，这也会造成某些数字的排序错误</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let a &#x3D; [1,2,3,4,5,6,7,8,9,10,11,12]</span><br><span class="line">a.sort()  &#x2F;&#x2F; [1,10,11,12,2,3,4,5,6,7,8,9]</span><br></pre></td></tr></table></figure></li>
<li><p>fill()<br>该方法会把数组中所有元素，置换为指定的值，fill() 有三个参数，第一个是准备要置换的内容(必填)，第二个是从什么位置开始置换(选填，不设定就全部置换)，第三个是停止置换的元素的前一个位置(选填，默认等于数组长度)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let a &#x3D; [1,2,3,4,5,6,7,8,9]</span><br><span class="line">a.fill(&#39;a&#39;)  &#x2F;&#x2F; [&#39;a&#39;,&#39;a&#39;,&#39;a&#39;,&#39;a&#39;,&#39;a&#39;,&#39;a&#39;,&#39;a&#39;,&#39;a&#39;,&#39;a&#39;]</span><br><span class="line">let b &#x3D; [1,2,3,4,5]</span><br><span class="line">b.fill(&#39;b&#39;,2,3) &#x2F;&#x2F; [1,2,&#39;b&#39;,4,5]</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="获取数组属性或索引值"><a href="#获取数组属性或索引值" class="headerlink" title="获取数组属性或索引值"></a>获取数组属性或索引值</h3><p><code>length() 、indexOf() 、lastIndexOf() 、 find()、 findIndex() 、filter()</code></p>
<ul>
<li><p>length()<br>可以取得数组的长度。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let a &#x3D; [1,2,3,4,5,6]</span><br><span class="line">a.length() &#x2F;&#x2F; 6</span><br></pre></td></tr></table></figure></li>
<li><p>indexOf()、lastIndexOf()<br>indexOf()会判断数组中是否包含某个值(从左往右)，如果包含就返回这个值在数组中的索引值，若没有找到返回 -1 。有两个参数一个是要找的的值，另外一个是表示数组数组从哪个位置开始判断。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let a &#x3D; [1,2,3,4,5]</span><br><span class="line">a.indexOf(3)   &#x2F;&#x2F; 2</span><br><span class="line">a.indexOf(7)   &#x2F;&#x2F; -1</span><br><span class="line">a.indexOf(3,6) &#x2F;&#x2F; -1</span><br></pre></td></tr></table></figure>
<p>lastIndexOf()会判断数组中是否包含某个值(从右往左)，查找方式 indexOf()一样。</p>
</li>
<li><p>find()<br>find() 会将数组中的每一个元素带入指定的函数内做判断，并会返回一个符号判断条件的元素，若没有元素符合则会返回 undefined.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let a &#x3D; [1,2,3,4,5,6]</span><br><span class="line">a.find((e)&#x3D;&gt;e&gt;3)  &#x2F;&#x2F; 4</span><br><span class="line">a.find((e)&#x3D;&gt;e&lt;1)  &#x2F;&#x2F; undefined</span><br></pre></td></tr></table></figure></li>
<li><p>findIndex()<br>findIndex() 会将数组中的每一个元素带入指定的函数内做判断，并返回第一个符合条件元素的位置索引。</p>
</li>
<li><p>filter()<br>filter() 会将数组中的每一个元素带入指定的函数内部做判断，如果符合条件则会返回，组成一个新的数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let a &#x3D; [1,2,3,4,5,6,7]</span><br><span class="line">a.filter(e &#x3D;&gt; e&gt;3)  &#x2F;&#x2F; [4,5,6,7]</span><br><span class="line">a.filter(e &#x3D; &gt;e%2 &#x3D;&#x3D; 0)  &#x2F;&#x2F; [2,4,6]</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="针对每一项处理"><a href="#针对每一项处理" class="headerlink" title="针对每一项处理"></a>针对每一项处理</h3><ul>
<li>forEach()<br>该方法会将数组中每一个元素用指定的函数里进行运算，函数有三个参数，第一个参数表示每个元素的值(必填),第二个参数为该元素的索引值(选填)，第三个参数则表示原本的数组(选填)。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let a &#x3D; [1,2,3,4,5]</span><br><span class="line">a.forEach((item,index,arr)&#x3D;&gt;&#123;</span><br><span class="line">  arr[index] &#x3D; item*10</span><br><span class="line">&#125;)</span><br><span class="line">&#x2F;&#x2F; [10,20,30,40,50]</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="产生新的数组或新的值"><a href="#产生新的数组或新的值" class="headerlink" title="产生新的数组或新的值"></a>产生新的数组或新的值</h3><p><code>join() concat() slice() map() reduce() reduceRight() flat() flatMap() Array.from() Array.of() toString()</code></p>
<ul>
<li><p>join()<br>可以将数组中所有元素，变成由指定的字符串分割合并在一起组成字符串进行呈现，若没有指定字符默认会用逗号合并。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let a &#x3D; [1,2,3,4,5]</span><br><span class="line">a.join()  &#x2F;&#x2F; 1,2,3,4,5</span><br><span class="line">a.join(&#39;&#39;) &#x2F;&#x2F; 12345</span><br></pre></td></tr></table></figure>
</li>
<li><p>concat() 可以将两个数组合并在一起，可以使用扩展运算符 … 来代替。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let a &#x3D; [1,2,3,4,5]</span><br><span class="line">let b &#x3D; [6,7,8,9]</span><br><span class="line">let c &#x3D; a.concat(b)   &#x2F;&#x2F; [1,2,3,4,5,6,7,8,9]</span><br><span class="line">let d &#x3D; [...a,...b]   &#x2F;&#x2F; [1,2,3,4,5,6,7,8,9]</span><br></pre></td></tr></table></figure></li>
<li><p>slice()<br>可以截取出数组某部分的元素为一个新的数组，有两个必填的参数，一个是起始位置，一个是结束位置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let a &#x3D; [1,2,3,4,5,6]</span><br><span class="line">let b &#x3D; a.slice(2,4)  &#x2F;&#x2F; [3,4]</span><br></pre></td></tr></table></figure></li>
<li><p>map()<br>会处理数组中每一个元素，最后返回一个新的数组，里面是一个函数和一个返回函数里的 this 参数，函数包含三个参数，第一个是每一个元素的值(必填)，第二个是当前元素的索引值，第三个是当前的数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let a &#x3D; [1,2,3,4,5,6]</span><br><span class="line">let b &#x3D; a.map((e)&#x3D;&gt;&#123;</span><br><span class="line">  return e+2</span><br><span class="line">&#125;)</span><br><span class="line">&#x2F;&#x2F; [3,4,5,6,7,8]</span><br></pre></td></tr></table></figure></li>
<li><p>reduce()<br>可以将数组中每一个元素进行计算，每次计算的结果再与下一个元素计算，直到结束为止，里头包含一个函数(必填)和初始计算的数值(选填)，函数内有四个参数，第一个是计算的值(必填)，第二个是取得的元素(必填)，第三个是该元素的索引值(选填)，第四个是原本的数组(选填)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let a &#x3D; [1,2,3,4,5,6,7,8]</span><br><span class="line">let b &#x3D; a.reduce((total,e)&#x3D;&gt;&#123;</span><br><span class="line">  total + e</span><br><span class="line">&#125;)</span><br><span class="line">&#x2F;&#x2F; 36 (1+2+3+4+5+6+7+8)</span><br></pre></td></tr></table></figure>
</li>
<li><p>flat()<br>可以将一个多维数组的深度转换成一维(扁平化数组或成为降维)，有一个选填的参数代表要转换的深度数字，默认值为 1 ，如果是很多层可以使用 Infinity 来全部展开成一维数组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let a &#x3D; [1,[2],[3,4,[8,9]]]</span><br><span class="line">let b &#x3D; a.flat()   &#x2F;&#x2F; [1,2,3,4,[8,9]]</span><br><span class="line">let c &#x3D; a.flat(2)  &#x2F;&#x2F; [1,2,3,4,8,9]</span><br><span class="line">let d &#x3D; a.flat(Infinity) &#x2F;&#x2F; [1,2,3,4,8,9]</span><br></pre></td></tr></table></figure></li>
<li><p>Array.form()<br>会将类数组或是可迭代的对象转换成数组，有两个参数，第一个参数为类数组对象或可迭代的对象(必填)，第二个参数则是改变转换成数组元素的函数。<br>类数组对象具有 length 属性以及索引化 index 的元素，可迭代对象表示具有可以利用迭代的方式取得它自己本身的元素，如 Map 和 Set</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let a &#x3D; &#39;abcd&#39;</span><br><span class="line">Array.from(a) &#x2F;&#x2F; [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;]</span><br><span class="line">let obj &#x3D; &#123;</span><br><span class="line">  &#39;0&#39;:12,</span><br><span class="line">  &#39;2&#39;:11,</span><br><span class="line">  &#39;1&#39;:10,</span><br><span class="line">  length:3</span><br><span class="line">&#125;</span><br><span class="line">let objb &#x3D; Array.from(obj) &#x2F;&#x2F; [12,11.10]</span><br></pre></td></tr></table></figure></li>
<li><p>Array.of()<br>可以快速将数字、字符串等内容，转换成数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let a &#x3D; Array.of(1,&#39;q&#39;,3)</span><br><span class="line">a &#x2F;&#x2F; [1,&#39;q&#39;,3]</span><br></pre></td></tr></table></figure></li>
<li><p>toString()<br>会把整个数组转换成字符串</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let a &#x3D; [1,2,3,4]</span><br><span class="line">a.toString() &#x2F;&#x2F; &#39;1,2,3,4&#39;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="布尔判断"><a href="#布尔判断" class="headerlink" title="布尔判断"></a>布尔判断</h3><p><code>every() some() includes() Array.isArray()</code></p>
<ul>
<li><p>every()<br>会将数组中的每一个元素带入指定的函数内部进行判断，只要有一个元素不符合判断条件,会返回 false，如果全部符合，就会返回 true</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let a &#x3D; [1,2,3,4,5]</span><br><span class="line">a.every((e) &#x3D;&gt; e &gt; 3)   &#x2F;&#x2F; false</span><br><span class="line">a.every((e) &#x3D;&gt; e &gt; 0)   &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>
</li>
<li><p>some()<br>会将数组中的每一个函数放入指定的函数内部做判断，只要有任何一个符合判断条件，就会返回 true,如果全部不符合，才会返回 false。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let a &#x3D; [1,2,3,4]</span><br><span class="line">a.some((e) &#x3D;&gt; e &gt; 3)  &#x2F;&#x2F; true</span><br><span class="line">a.some((e) &#x3D;&gt; e &gt; 4)  &#x2F;&#x2F; false</span><br></pre></td></tr></table></figure>
</li>
<li><p>includes()<br>会判断数组中是否包含某个值，如果包含就返回 true 否则返回 false。有两个参数，第一个参数表示要判断的值，第二个参数是表示从数组的哪个位置开始判断。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let a &#x3D; [1,2,3,4,5,6]</span><br><span class="line">a.includes(2)     &#x2F;&#x2F; true</span><br><span class="line">a.includes(2,2)   &#x2F;&#x2F; false</span><br></pre></td></tr></table></figure>
</li>
<li><p>Array.isArray()<br>Array.isArray() 能判断一个元素是否为数组，如果是就返回 true,不然就返回 false。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let a &#x3D; [1,2,3]</span><br><span class="line">Array.isArray(a)  &#x2F;&#x2F; true</span><br><span class="line">Array.isArray(124) &#x2F;&#x2F; false</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p><code>valueOf() keys</code></p>
<ul>
<li><p>valueOf()<br>会返回数组的原始值，如果数组原本有修改，返回的原始值也会跟着改变(相当于浅复制)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let a &#x3D; [1,2,3,4,5]</span><br><span class="line">let b &#x3D; a.valueOf()   &#x2F;&#x2F; [1,2,3,4,5]</span><br><span class="line">let c &#x3D; a.valueOf()</span><br><span class="line">a.shift()</span><br><span class="line">b  &#x2F;&#x2F; [2,3,4,5]</span><br><span class="line">c  &#x2F;&#x2F; [2,3,4,5]</span><br></pre></td></tr></table></figure>
</li>
<li><p>keys<br>keys 会返回数组中的每一个索引值(key) 成一个新的 Array Iterator 对象，可以用 for of 进行迭代</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let a &#x3D; [1,2,3,4,5,6]</span><br><span class="line">let b &#x3D; a.keys()</span><br><span class="line">for(let key of b)&#123;</span><br><span class="line">  console.log(key)    &#x2F;&#x2F; 1,2,3,4,5,6</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="Oject"><a href="#Oject" class="headerlink" title="Oject"></a>Oject</h2><h3 id="创建-3"><a href="#创建-3" class="headerlink" title="创建"></a>创建</h3><ul>
<li><p>new 构造函数法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var person &#x3D; new Object()</span><br><span class="line">person.name &#x3D; &#39;张三&#39;;</span><br><span class="line">person.age &#x3D; 25</span><br></pre></td></tr></table></figure>
</li>
<li><p>对象字面量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var person &#x3D; &#123;</span><br><span class="line">  name:&#39;张三&#39;,</span><br><span class="line">  age: 25</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="属性和方法"><a href="#属性和方法" class="headerlink" title="属性和方法"></a>属性和方法</h3><ul>
<li><p>constructor<br>constructor 属性是保存当前对象的构造函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var obj1 &#x3D; new Object()</span><br><span class="line">obj1.id &#x3D; &#39;obj1&#39;</span><br><span class="line">var obj2 &#x3D; &#123;</span><br><span class="line">  id:&#39;obj2&#39;</span><br><span class="line">&#125;</span><br><span class="line">obj1.constructor &#x2F;&#x2F; function Object()&#123;&#125;</span><br><span class="line">obj2.constructor &#x2F;&#x2F; function Object()&#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>hasOwnProperty(‘属性名字’) 方法<br>该方法接收一个字符串参数(属性名)，用来判断该属性是否是当前对象实例中，而不是来自对象的原型链中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var obj &#x3D; &#123;</span><br><span class="line">  name:&#39;ddd&#39;</span><br><span class="line">&#125;</span><br><span class="line">obj.hasOwnProperty(&#39;name&#39;)      &#x2F;&#x2F; true</span><br><span class="line">obj.hasOwnProperty(&#39;toString&#39;)  &#x2F;&#x2F; false</span><br></pre></td></tr></table></figure>
</li>
<li><p>toLocaleString() 方法<br>该方法返回对象的字符串表示，和代码的执行环境有关。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var obj &#x3D; &#123;&#125;</span><br><span class="line">obj.toLocalString()    &#x2F;&#x2F; &#39;[object object]&#39;</span><br></pre></td></tr></table></figure></li>
<li><p>toString() 方法<br>返回对象的字符串表示</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var obj &#x3D; &#123;&#125;</span><br><span class="line">obj.toString()  &#x2F;&#x2F; &#39;[object object]&#39;</span><br></pre></td></tr></table></figure></li>
<li><p>valueOf() 方法<br>该方法返回对象的原始值。可能是字符串、数值或者布尔值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var obj &#x3D; &#123;</span><br><span class="line">  name:&#39;obj&#39;</span><br><span class="line">&#125;</span><br><span class="line">var arr &#x3D; [1]</span><br><span class="line">var bool &#x3D; new Boolean(1)</span><br><span class="line">var date &#x3D; new Date()</span><br><span class="line"></span><br><span class="line">obj.valueOf()     &#x2F;&#x2F; Object &#123;name:&#39;obj&#39;&#125;</span><br><span class="line">arr.valueOf()     &#x2F;&#x2F; [1]</span><br><span class="line">bool.valueOf()    &#x2F;&#x2F; true</span><br><span class="line">data.valueOf()    &#x2F;&#x2F; 145556666666</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="属性的类型"><a href="#属性的类型" class="headerlink" title="属性的类型"></a>属性的类型</h3><p>在 JavaScript 中，属性有两种类型，分别是数据属性和访问器属性</p>
<h4 id="数据属性"><a href="#数据属性" class="headerlink" title="数据属性"></a>数据属性</h4><p>数据属性可以理解为我们平时定义对象赋予的属性，可以进行读和写。但在 ES5 中定义了一些特性，这些特性用来描述属性的各种特征，特性是内部值，不能直接访问。需要通过 Object.defineProperty 方法来修改。</p>
<ul>
<li><p>[[Configurable]]<br>该特性表示是否可以通过 delete 操作符来删除属性，默认值为 true。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var obj &#x3D; &#123;</span><br><span class="line">  name:&#39;obj&#39;,</span><br><span class="line">  age:25</span><br><span class="line">&#125;</span><br><span class="line">obj.name         &#x2F;&#x2F; obj</span><br><span class="line">delete obj.name</span><br><span class="line">obj.name         &#x2F;&#x2F; undefined</span><br><span class="line">Object.defineProperty(obj,&#39;age&#39;,&#123;</span><br><span class="line">  configurable:false</span><br><span class="line">&#125;)</span><br><span class="line">obj.age          &#x2F;&#x2F; 25</span><br><span class="line">delete obj.age</span><br><span class="line">obj.age          &#x2F;&#x2F; 25</span><br></pre></td></tr></table></figure>

<p>通过 configurable 特性设置成 false 之后，delete 就无法删除 age 属性，如果是在严格模式下，使用 delete 去删除就会报错。</p>
</li>
<li><p>[[Enumerable]]<br>表示是否能够通过 for in 语句来枚举出属性。默认是 true</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var obj &#x3D; &#123;</span><br><span class="line">  name:&#39;objName&#39;</span><br><span class="line">&#125;</span><br><span class="line">for( var key in obj)&#123;</span><br><span class="line">  console.log(key)      &#x2F;&#x2F; name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Object.defineProperty(obj,&#39;constructor&#39;,&#123;</span><br><span class="line">  enumerable:true</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">for ( var key in obj)&#123;</span><br><span class="line">  console.log(key)       &#x2F;&#x2F; name constructor</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>[[Writable]] 和 [[Value]]<br>Writable：表示属性值是否可以修改，默认为 true，若设为 false，修改属性值的时候没有效果，在严格模式下会报错。<br>Value：表示属性的值，默认为 undefined</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var obj &#x3D; &#123;</span><br><span class="line">  name:&#39;name&#39;</span><br><span class="line">&#125;</span><br><span class="line">obj.name &#x2F;&#x2F; name</span><br><span class="line">Object.defineProperty(obj,&#39;name&#39;,&#123;</span><br><span class="line">  value:&#39;newVlaue&#39;,</span><br><span class="line">  writable:false</span><br><span class="line">&#125;)</span><br><span class="line">obj.name  &#x2F;&#x2F; newValue</span><br><span class="line">obj.name &#x3D; &#39;oldValue&#39;</span><br><span class="line">obj.name &#x2F;&#x2F; newValue</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="访问器属性"><a href="#访问器属性" class="headerlink" title="访问器属性"></a>访问器属性</h4><p>[[get]] 读取属性时调用的函数,[[set]] 给属性设置值的时候调用的函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var person &#x3D; &#123;</span><br><span class="line">  age:15</span><br><span class="line">&#125;</span><br><span class="line">Object.defineProperty(person,&#39;type&#39;,&#123;</span><br><span class="line">  get:function()&#123;</span><br><span class="line">    if(person.age&gt;17)&#123;</span><br><span class="line">      return &#39;成人&#39;</span><br><span class="line">    &#125;</span><br><span class="line">    return &#39;小孩&#39;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">person.type &#x2F;&#x2F; 小孩</span><br><span class="line">person.age &#x3D; 20</span><br><span class="line">person.type &#x2F;&#x2F; 成人</span><br></pre></td></tr></table></figure>

<h2 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h2><p>函数的本身就是对象。函数是第一类对象。<br>第一类对象又称第一类公民。具有的的特性</p>
<ul>
<li>能够作为参数被传递。</li>
<li>能够从一个函数结果中返回。</li>
<li>能够被修改和赋值给变量。<br><code>在js 里函数也是对象，可以拥有自己的属性和方法，而它和一般js对象的区别是：可以被调用，即可以执行。</code></li>
</ul>
<h3 id="创建-4"><a href="#创建-4" class="headerlink" title="创建"></a>创建</h3><p>函数创建方法:<code>函数定义表达式、函数声明语句和 new Function()</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 函数声明</span><br><span class="line">function fun() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 函数表达式</span><br><span class="line">var  fun &#x3D; function() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; new Function</span><br><span class="line">var  fun1 &#x3D; new Function()</span><br></pre></td></tr></table></figure>

<ul>
<li><p>变量提升<br>JavaScript 中由 var 关键字声明的变量存在变量提升：将变量声明提升到作用域的顶部，但赋值仍保留在原处。函数表达式和函数声明有本质的区别。</p>
<ul>
<li>函数声明语句<br>将函数声明和函数的赋值都提升到作用域的顶部，在同一个作用域中可以出现调用在函数之前。</li>
<li>函数表达式<br>与 var 声明的普通变量相同，只是将变量声明提升到作用域顶部，但赋值仍然留在原处，不能在定义前使用</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">fun()                       &#x2F;&#x2F; 函数声明</span><br><span class="line">fun1()                      &#x2F;&#x2F; undefined</span><br><span class="line">function fun() &#123;</span><br><span class="line">  var name &#x3D; &#39;函数声明&#39;</span><br><span class="line">  console.log(name)</span><br><span class="line">&#125;</span><br><span class="line">var fun1 &#x3D; function() &#123;</span><br><span class="line">  var name &#x3D; &#39;函数表达式&#39;</span><br><span class="line">  console.log(name)</span><br><span class="line">&#125;</span><br><span class="line">fun()                     &#x2F;&#x2F; 函数声明</span><br><span class="line">fun1()                    &#x2F;&#x2F; 函数表达式</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="函数的调用"><a href="#函数的调用" class="headerlink" title="函数的调用"></a>函数的调用</h3><p>在定义函数时，函数体中的代码不会执行，只有在调用函数时，才会执行函数体中的语句。函数的调用方式有四种</p>
<h4 id="作为普通函数"><a href="#作为普通函数" class="headerlink" title="作为普通函数"></a>作为普通函数</h4><p>使用调用表达式来调用普通函数，每个调用表达式由多个函数表达式组成。每个函数表达式包括函数对象、括号和传入的实参组成。</p>
<ul>
<li><p>每次调用会拥有本次调用的上下文 this；在 ES5 非严格模式下，普通函数的 this 值是全局对象；在严格模式下是 undefined</p>
</li>
<li><p>以函数形式调用的函数通常不使用 this 关键字</p>
</li>
<li><p>如果函数没有显式 return 语句返回一个值，默认返回 undefined</p>
</li>
<li><p>传入的实参是由逗号分隔的 0 个或多个函数表达式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function printPrps(o) &#123;</span><br><span class="line">  for(var prop in o) &#123;</span><br><span class="line">    console.log(prop + &quot;: &quot; + o[prop] + &quot;\n&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(this)   &#x2F;&#x2F; window</span><br><span class="line">&#125;</span><br><span class="line">printPrps(&#123;x:1&#125;)      &#x2F;&#x2F; x:1</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="作为对象的方法"><a href="#作为对象的方法" class="headerlink" title="作为对象的方法"></a>作为对象的方法</h4><p>方法是保存在 JavaScript 对象中的函数</p>
<ul>
<li>对方法调用的参数和返回值处理与函数调用相同</li>
<li>方法调用由两部分组成：<code>对象.属性名()</code>，其中属性名是值为函数的属性</li>
<li>方法调用中：调用上下文指调用方法的对象，使用 this 关键字引用<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var obj &#x3D;&#123;</span><br><span class="line">  num1: 12,</span><br><span class="line">  num2: 11,</span><br><span class="line">  add: function() &#123;</span><br><span class="line">    this.result &#x3D; this.num1 + this.num2</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.add()   &#x2F;&#x2F; 调用 add 方法</span><br><span class="line">obj.result  &#x2F;&#x2F; 23</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="作为构造器函数"><a href="#作为构造器函数" class="headerlink" title="作为构造器函数"></a>作为构造器函数</h4><p>函数或者方法调用前有关键字 new，函数或者方法便作为构造函数来调用。构造函数会创建一个新对象，新对象继承构造函数的 prototype 属性。<br>作为构造函数的调用，会将新创建的对象作为其调用上下文(this 指向新创建的对象)，在构造函数中使用 this 引用新创建的对象。</p>
<h4 id="使用函数的-call-和-apply-方法间接调用"><a href="#使用函数的-call-和-apply-方法间接调用" class="headerlink" title="使用函数的 call() 和 apply() 方法间接调用"></a>使用函数的 call() 和 apply() 方法间接调用</h4><p>函数是对象，每个函数都有 call() 和 apply() 两个方法，作用是改变函数运行时的上下文–改变函数体内部 this 的指向。<br>call()和 apply()作用都是动态改变函数体内 this 指向。只是接受参数形式不太一样。<br>call() 需要将参数按顺序传递进函数，并且知道参数的数量。<br>apply() 将参数放在数组中传进函数。(参数数量不确定时使用)</p>
<h3 id="函数的实参和形参"><a href="#函数的实参和形参" class="headerlink" title="函数的实参和形参"></a>函数的实参和形参</h3><p>实参和形参是相对的概念，在函数定义时指定的参数叫做形参；在函数调用时传入的参数叫做实参。对于需要省略的实参，可以使用 null 或 undefined 作为占位符。</p>
<h4 id="参数对象"><a href="#参数对象" class="headerlink" title="参数对象"></a>参数对象</h4><p>函数体内，标识符 argument 指向实参对象的引用，实参对象是一个类数组对象，可以通过下标访问每个传入的参数。</p>
<ul>
<li>callee 和 caller 属性。<br>callee 是 ECMAScript 规范中 arguments 对象的属性：代表当前正在执行的函数。<br>caller 是非标准的，只是浏览器基本实现了这个属性：代表调用当前函数的函数。<br>在严格模式中，对这个两个属性读写都会产生错误。</li>
</ul>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>闭包在 JavaScript 中，指内部函数总是可以访问其所在的外部函数中声明的变量和参数，即是外部函数被返回(调用结束)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var scope &#x3D; &#39;global scope&#39;</span><br><span class="line">function checkScope() &#123;</span><br><span class="line">  var scope &#x3D; &#39;local scope&#39;</span><br><span class="line">  function f() &#123; return scope&#125;</span><br><span class="line">  return f</span><br><span class="line">&#125;</span><br><span class="line">checkScope()()</span><br></pre></td></tr></table></figure>

<ul>
<li>在 Js 中，每个函数在定义时会创建一个与之相关的作用域链，并且在程序执行期间一直存在<br>外部函数有自身的作用域链，内部函数有自身单独的作用域链。</li>
<li>每次调用函数都会创建一个新对象来保存参数和局部变量，并将其添加到作用域链。<ul>
<li>当函数返回时，将绑定的新对象从作用域链上删除。如果没有其他变量引用该对象、或该对象没有保存在某个对象的属性中，它会被当做垃圾回收。</li>
<li>如果没有外部变量引用，调用函数时创建的临时对象，函数 return 后便被垃圾回收。</li>
</ul>
</li>
<li>如果 checkScope 定义有嵌套函数 f,并将 f 作为返回值保存在某个对象的属性中。相当于有一个外部引用指向嵌套函数。</li>
</ul>
<p>JavaScript 中的函数，通过作用域和词法作用域两者的特性，将该函数定义时所处的作用域中的相关函数进行补货和保存，从而可以在完全不同的上下文中进行引用。</p>
<h2 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h2><h3 id="时区"><a href="#时区" class="headerlink" title="时区"></a>时区</h3><pre><code>javaScript 中，我们只关心两个，本地时间和协调世界时(UTC)
  - 本地时间 是指自己计算机所在的时区
  - UTC 实际上是格林威治时间</code></pre><h3 id="创建-5"><a href="#创建-5" class="headerlink" title="创建"></a>创建</h3><pre><code>`new Date()` 来创建日期，传入的参数通常有四种
- 使用日期字符串参数
- 使用一系列的参数
  可以传入七个参数来创建日期和时间
  - Year: 四位数年份
  - Month: 一年中的某一个月(0-11)
  - Day: 每月的某一天(1-31)，如果省略，则默认为 1
  - Hour: 一天中的小时(0-23)，如果省略，则默认为 0
  - Minutes: 分钟(0-59)，如果省略，则默认为0
  - Seconds: 秒(0-59)，默认为0 
  - Milliseconds: 毫秒(0-999)，默认为零。
- 时间戳参数
  时间戳是自 1970年1月1日以来经过的毫秒数
- 不带参数
  会将日期设置为当前时间</code></pre>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 使用日期字符串参数</span><br><span class="line">  new Date(&#39;2021-10-21&#39;)</span><br><span class="line">  </span><br><span class="line">&#x2F;&#x2F; 使用一系列参数来创建</span><br><span class="line">  </span><br><span class="line">  new Date(2020,1,23,5,30,39)</span><br></pre></td></tr></table></figure>
<h3 id="日期提供的方法"><a href="#日期提供的方法" class="headerlink" title="日期提供的方法"></a>日期提供的方法</h3><ul>
<li><p>编写自定义日期格式化<br>Date 中获取 年月日时分秒的方法</p>
<ul>
<li>getFullYear: 获取当地时间四位数的年份</li>
<li>getMonth: 获取月份，月份从零开始</li>
<li>getDate: 获取月中的某一天(1-31)</li>
<li>getDay: 获取星期几(0-6)，星期日(0)开始，到星期六(6)结束。</li>
<li>getHours: 获取小时数(0-23)</li>
<li>getMinutes: 获取分钟数(0-59)</li>
<li>getSeconds: 获取秒数(0-59)</li>
<li>getMilliseconds: 获取毫秒数(0-999)</li>
</ul>
<p>Date 设置另一个日期特定的日期/时间值</p>
<ul>
<li>setFullYear: 设置年份</li>
<li>setMonth: 设置月份</li>
<li>setDate: 设置每月中的某一天</li>
<li>setHours: 设置时</li>
<li>setMinutes: 设置分</li>
<li>setSeconds: 设置秒</li>
<li>setMilliseconds: 设置毫秒<h4 id="日期添加-减去增量"><a href="#日期添加-减去增量" class="headerlink" title="日期添加/减去增量"></a>日期添加/减去增量</h4></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">当前日期 2019年3月28日，获取三天后的日期</span><br><span class="line"></span><br><span class="line">let today &#x3D; new Date(2019,2,28)</span><br><span class="line">let finalDate &#x3D; new Date(today)</span><br><span class="line">finalDate.setDate(today.getDate()+3)</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h1 id="引用类型与原始类型的区别"><a href="#引用类型与原始类型的区别" class="headerlink" title="引用类型与原始类型的区别"></a>引用类型与原始类型的区别</h1><h3 id="声明变量时不同的内存分配"><a href="#声明变量时不同的内存分配" class="headerlink" title="声明变量时不同的内存分配"></a>声明变量时不同的内存分配</h3><ul>
<li>原始值：存储在栈内存(stack) 中的简单数据段，即他们的值直接存储在变量访问的位置。</li>
<li>引用值：存储在堆内存中，栈内存中存储的是该对象的指针，指向存储对象的内存地址<br>为什么引用类型的值不能放在栈中，引用类型的值大小会发生改变，放在栈内存中会降低变量查询的速度。</li>
</ul>
<h3 id="访问机制"><a href="#访问机制" class="headerlink" title="访问机制"></a>访问机制</h3><ul>
<li>原始类型，值是可以直接访问</li>
<li>引用类型，访问一个对象时，首先得到的是这个对象在内存中的地址，然后再按照这个地址去获得这个对象中的值，即<code>按应用访问</code></li>
</ul>
<h3 id="复制变量"><a href="#复制变量" class="headerlink" title="复制变量"></a>复制变量</h3><ul>
<li>原始类型：将保存原始值的变量复制给另一个变量时，会将原始值的副本赋值给新变量，此后这两个变量是完全独立的。</li>
<li>引用类型：是将内存地址赋值给新变量，即这两个变量都指向同一个堆内存中的同一个对象，任何一个改变都会反映在另一个身上。</li>
</ul>
<h3 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h3><p>ECMAScript 中所有的函数的参数都是<code>按值传递</code>。<br>但是涉及到原始和引用类型的值时是有差异的，因为内存分配时的差异。</p>
<ul>
<li>原始值：把变量的值传递给参数，之后参数和这个变量互不影响。</li>
<li>引用值：传递的值是内存地址，所以在函数内部对参数修改会体现在外部，因为他们指向的是同一个对象。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2022/04/13/js%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/%E6%95%B0%E6%8D%AE/" data-id="cl83x4ctp002rwgdxamz587an" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-js知识体系/事件" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/04/13/js%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/%E4%BA%8B%E4%BB%B6/" class="article-date">
  <time datetime="2022-04-13T07:41:30.950Z" itemprop="datePublished">2022-04-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/js%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/">js知识体系</a>►<a class="article-category-link" href="/categories/js%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/%E4%BA%8B%E4%BB%B6/">事件</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/04/13/js%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/%E4%BA%8B%E4%BB%B6/">JS 事件</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="什么是事件"><a href="#什么是事件" class="headerlink" title="什么是事件"></a>什么是事件</h2><p>  JavaScript 和 HTML 之间交互是通过事件实现的，事件就是文档或浏览器窗口中发生的一些特定的交互瞬间。事件在浏览器中是以对象的形式存在</p>
<h2 id="怎样添加事件"><a href="#怎样添加事件" class="headerlink" title="怎样添加事件"></a>怎样添加事件</h2><h3 id="DOM-元素事件属性"><a href="#DOM-元素事件属性" class="headerlink" title="DOM 元素事件属性"></a>DOM 元素事件属性</h3><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onClick&#x3D;&quot;clickFun()&quot;&gt;添加事件&lt;&#x2F;button&gt;</span><br></pre></td></tr></table></figure></code></pre><h3 id="脚本添加事件"><a href="#脚本添加事件" class="headerlink" title="脚本添加事件"></a>脚本添加事件</h3>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;button id&#x3D;&quot;myBtn&quot;&gt;点击这里&lt;&#x2F;button&gt;</span><br><span class="line"></span><br><span class="line">document.getElementById(&#39;myBtn&#39;).onclick &#x3D; function()&#123;</span><br><span class="line">  clickFun()</span><br><span class="line">&#125;</span><br><span class="line">document.getElementById(&#39;myBtn&#39;).addEventListener(&#39;clcik&#39;,function()&#123;</span><br><span class="line">  clickFun()</span><br><span class="line">&#125;,false)</span><br></pre></td></tr></table></figure>

<h2 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h2><pre><code>`事件捕获、事件冒泡、原事件`</code></pre><h3 id="事件捕获"><a href="#事件捕获" class="headerlink" title="事件捕获"></a>事件捕获</h3><p>  事件捕获：事件从最不具体的节点开始接收(document),传递到最具体的节点,事件捕获的本意时当事件到达预定目标前捕获它。</p>
<p>当我们点击页面代码中id为box的div块，点击事件会按照如下顺序传播<br>document —&gt; html —&gt; body —&gt; div</p>
<p><img src="https://segmentfault.com/img/bVYi7V?w=394&h=324" alt="事件捕获"></p>
<h3 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h3><p>  IE 的事件流称为事件冒泡<br>  事件冒泡：事件由最具体的元素接收，逐级向上传播到不具体的节点(document)</p>
<p>  当我们点击id 为box 的代码块时，点击事件会按照如下顺序传播</p>
<p>  div —&gt; body —&gt; html —&gt; document</p>
<p>  <img src="https://segmentfault.com/img/bVYi6Y?w=435&h=368" alt="事件冒泡"></p>
<h3 id="DOM2-级事件流"><a href="#DOM2-级事件流" class="headerlink" title="DOM2 级事件流"></a>DOM2 级事件流</h3><p>  为了能够兼容上述两种事件模型，又提出了一个 DOM2级事件模型，它规定了事件流包含三个阶段</p>
<ul>
<li>事件捕获阶段: 为事件捕获提供机会</li>
<li>处于目标阶段: 事件的目标接收到事件(但并不会做出响应)</li>
<li>事件冒泡阶段: 事件响应阶段</li>
</ul>
<h3 id="事件流的典型应用-————-事件代理"><a href="#事件流的典型应用-————-事件代理" class="headerlink" title="事件流的典型应用 ———— 事件代理"></a>事件流的典型应用 ———— 事件代理</h3><p> 事件代理的原理就是事件冒泡和目标元素，把事件处理添加到父元素，等待子元素事件冒泡，并且父元素能够通过 target 判断是哪个子元素，从而做相应的处理。</p>
<ul>
<li>事件代理的好处<ul>
<li>将多个事件处理器减少到一个，事件处理器需要驻留在内存，这样提高了性能</li>
<li>DOM 更新无需重新绑定事件处理器，如果新增子元素，直接修改事件代理的事件处理函数即可，不需要重新绑定处理器，不需要再次循环遍历。</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2022/04/13/js%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/%E4%BA%8B%E4%BB%B6/" data-id="cl83x4cto002qwgdxepei72dj" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-js知识体系/三大特性" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/04/13/js%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7/" class="article-date">
  <time datetime="2022-04-13T07:41:30.922Z" itemprop="datePublished">2022-04-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/js%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/">js知识体系</a>►<a class="article-category-link" href="/categories/js%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/js-%E8%AF%AD%E8%A8%80%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7/">js 语言的三大特性</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/04/13/js%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7/">js 语言的三大特性</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>  JavaScript 是一种基于对象的语言，我们所遇到的东西几乎都是对象。<br>  在 JS中，封装的过程就是把一些属性和方法放到对象中 “包裹” 起来，<br>  封装：就是把事务封装成类，隐藏事物的属性和方法的实现细节，仅对外公开接口。<br>  封装的好处：使用封装，可以达到代码的复用，使代码更加简洁<br>  <code>将属性和方法组成一个类的过程就是封装</code></p>
<ul>
<li><p>通过构造函数添加<br>JavaScript 提供了一个构造函数模式，用来创建对象时初始化对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">functuon Cat(name,color) &#123;</span><br><span class="line">  this.name &#x3D; name</span><br><span class="line">  this.colot &#x3D; color</span><br><span class="line">  this.eat &#x3D; ( () &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;🐟&#39;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 生成实例</span><br><span class="line">var cat1 &#x3D; new Cat(&#39;tom&#39;,&#39;gray&#39;)</span><br></pre></td></tr></table></figure></li>
<li><p>通过原型 prototype 封装</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function Cat(name,color) &#123;</span><br><span class="line">  this.name &#x3D; name</span><br><span class="line">  this.color &#x3D; color</span><br><span class="line">&#125;</span><br><span class="line">Cat.prototype.type &#x3D; &#39;英短&#39;</span><br><span class="line">Cat.prototype.eat &#x3D; ( () &#x3D;&gt; &#123;</span><br><span class="line">  alert(&#39;🐟&#39;)</span><br><span class="line">&#125;)</span><br><span class="line">&#x2F;&#x2F; 生成实例</span><br><span class="line">var cat1 &#x3D; new Cat(&#39;Tom&#39;,&#39;gray&#39;)</span><br><span class="line">var cat2 &#x3D; new Cat(&#39;Kobe&#39;,&#39;purple&#39;)</span><br><span class="line">console.log(cat1.type)</span><br><span class="line">cat2.eat()</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>继承：我们想要一个对象能够访问另一个对象的属性，同时，这个对象还能够添加新的属性或者覆盖可访问的另一个对象的属性。<br>继承就是子类可以使用父类的所有功能，并且对这些功能进行扩展。</p>
<ul>
<li><p>类式继承<br>就是使用原型的方式，将方法添加在父类的原型上，然后子类的原型是父类的一个实例化对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 声明父类</span><br><span class="line">var SuperClass &#x3D; function() &#123;</span><br><span class="line">  let id &#x3D; 1</span><br><span class="line">  this.name &#x3D; [&#39;java&#39;]</span><br><span class="line">  this.superValue &#x3D; function() &#123;</span><br><span class="line">    console.log(&#39;this is superValue&#39;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 为父类添加共有方法</span><br><span class="line">SuperClass.prototype.getSuperVlaue &#x3D; function() &#123;</span><br><span class="line">  return this.superValue()</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 声明子类</span><br><span class="line">var SubClass &#x3D; function() &#123;</span><br><span class="line">  this.subValue &#x3D; (() &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;this is subValue)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 继承父类</span><br><span class="line">SubClass.prototype &#x3D; new SuperClass()</span><br><span class="line">&#x2F;&#x2F; 为子类添加共有方法</span><br><span class="line">SubClass.prototype.getSubValue &#x3D; function()&#123;</span><br><span class="line">  return this.subValue()</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 生成实例</span><br><span class="line">var sub1 &#x3D; new SubClass()</span><br><span class="line">var sub2 &#x3D; new SubClass()</span><br><span class="line">sub1.getSuperValue() &#x2F;&#x2F; this is superValue</span><br><span class="line">sub1.getSubValue()   &#x2F;&#x2F; this is subValue</span><br><span class="line"></span><br><span class="line">console.log(sub1.id)   &#x2F;&#x2F; undefined</span><br><span class="line">console.log(sub1.name) &#x2F;&#x2F; [&#39;java&#39;]</span><br><span class="line"></span><br><span class="line">sub1.name.push(&#39;php&#39;)</span><br><span class="line">console.log(sub1.name) &#x2F;&#x2F;[&#39;java&#39;,&#39;php&#39;]</span><br><span class="line">console.log(sub1.name) &#x2F;&#x2F;[&#39;java&#39;,&#39;php&#39;]</span><br></pre></td></tr></table></figure>

<p><code>使用类继承的方法缺陷，如果父类的构造函数中有引用数据类型，就会在子类中被所有实例共用，因此一个子类的实例如果更改了这个引用数据类型，就会影响到其他子类的实例</code></p>
</li>
<li><p>构造函数继承<br>构造函数继承的核心思想就是 直接改变this的指向，使通过this创建的属性和方法在子类中复制一份，因为是单独复制，所以各个实例的子类互不影响。但是会造成内存浪费的问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 声明父类</span><br><span class="line">  function SuperClass(id) &#123;</span><br><span class="line">    var name &#x3D; &#39;js&#39;</span><br><span class="line">    this.languages &#x3D; [&#39;JavaScript&#39;,&#39;Python&#39;]</span><br><span class="line">    this.id &#x3D; id</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 声明子类</span><br><span class="line">  function SubClass(id) &#123;</span><br><span class="line">    SuperClass.call(this,id)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 生成实例</span><br><span class="line">  var sub1 &#x3D; new SubClass(1)</span><br><span class="line">  var sub2 &#x3D; new SubClass(2)</span><br><span class="line"></span><br><span class="line">  console.log(sub2.id)   &#x2F;&#x2F; 2</span><br><span class="line">  console.log(sub2.name) &#x2F;&#x2F; undefined</span><br><span class="line"></span><br><span class="line">  sub1.languages.push(&#39;node&#39;) </span><br><span class="line">  console.log(sub1.languages)  &#x2F;&#x2F; [&#39;JavaScript&#39;,&#39;Python&#39;,&#39;node&#39;]</span><br><span class="line">  console.log(sub2.languages)  &#x2F;&#x2F; [&#39;JavaScript&#39;,&#39;Python&#39;]</span><br></pre></td></tr></table></figure></li>
<li><p>组合继承<br>组合继承是汲取了类继承和构造函数继承的优点，即避免了内存浪费，又使得每个实例化的子类互不影响</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 声明父类</span><br><span class="line"></span><br><span class="line">function SuperClass(name) &#123;</span><br><span class="line">  this.languages &#x3D; [&#39;js&#39;,&#39;python&#39;]</span><br><span class="line">  this.name &#x3D; name</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">&#x2F;&#x2F; 声明父类原型方法</span><br><span class="line">SuperClass.prototype.showlangs &#x3D; function ()&#123;</span><br><span class="line">  console.log(this.languages)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 声明子类</span><br><span class="line">function SubClass(name)&#123;</span><br><span class="line">  SuperClass.call(this,name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 子类继承父类(链式继承)</span><br><span class="line">SubClass.prototype &#x3D; new SuperClass()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 生成实例</span><br><span class="line">var sub1 &#x3D; new SubClass(&#39;node&#39;)</span><br><span class="line">var subw &#x3D; new SubClass(&#39;go&#39;)</span><br><span class="line"></span><br><span class="line">sub2.showlangs()  &#x2F;&#x2F; [&#39;js&#39;,&#39;python&#39;]</span><br><span class="line">sub1.languages.push(sub1.name)</span><br><span class="line">sub1.languages    &#x2F;&#x2F; [&#39;js&#39;,&#39;python&#39;,&#39;node&#39;]</span><br><span class="line">sub.languages     &#x2F;&#x2F; [&#39;js&#39;,&#39;python&#39;,&#39;go&#39;]</span><br></pre></td></tr></table></figure>
<p><code>组合继承的问题，父类的构造函数会被创建两次，一次是call的时候，一次是new的时候</code></p>
</li>
<li><p>寄生组合继承</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 原型式继承</span><br><span class="line">  function inheritObject(o)&#123;</span><br><span class="line">    &#x2F;&#x2F; 声明一个过度函数</span><br><span class="line">    function F() &#123;&#125;</span><br><span class="line">    F.prototype &#x3D; 0</span><br><span class="line">    return new F()</span><br><span class="line">  &#125;</span><br><span class="line">&#x2F;&#x2F; 寄生式继承</span><br><span class="line">  function inheritPrototype(subClass,superClass)&#123;</span><br><span class="line">    var p &#x3D; inheritObject(superClass.prototype)</span><br><span class="line">    p.constructor &#x3D; subClass</span><br><span class="line">    subClass.prototype &#x3D; p</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 定义父类</span><br><span class="line">  function SuperClass(name) &#123;</span><br><span class="line">    this.name &#x3D; name</span><br><span class="line">    this.languages &#x3D; [&#39;js&#39;]</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 定义父类原型方法</span><br><span class="line">  SuperClass.prototype.showLangs &#x3D; function() &#123;</span><br><span class="line">    console.log(this.languages)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 定义子类</span><br><span class="line">  function SubClass(name) &#123;</span><br><span class="line">    SuperClass.call(this.name)</span><br><span class="line">  &#125;</span><br><span class="line">  inheritPrototype(SubClass, SuperClass);</span><br><span class="line">  var sub1 &#x3D; new SubClass(&#39;go&#39;);</span><br></pre></td></tr></table></figure>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>多态：同一操作作用于不同的对象，可以用不同的解释，产生不同的执行结果。本质上就是将做什么和谁去做以及怎么做分开，就是消除不同对象的耦合关系。</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2022/04/13/js%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7/" data-id="cl83x4ctn002owgdx01t4025e" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-js知识体系/js代码执行过程分析" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/04/13/js%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/js%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/" class="article-date">
  <time datetime="2022-04-13T07:41:30.856Z" itemprop="datePublished">2022-04-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/js%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/">js知识体系</a>►<a class="article-category-link" href="/categories/js%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/js-%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/">js 代码执行过程分析</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/04/13/js%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/js%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/">JS代码执行过程分析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="解释型语言和编译型语言"><a href="#解释型语言和编译型语言" class="headerlink" title="解释型语言和编译型语言"></a>解释型语言和编译型语言</h2><ul>
<li>编译型语言，编译步骤分为：词法分析、语法分析、语义检查、代码优化和字节生成。</li>
<li>解释型语言：通过词法分析和语法分析得到抽象语法树后，就开始解释执行，</li>
</ul>
<h2 id="js-的解释执行"><a href="#js-的解释执行" class="headerlink" title="js 的解释执行"></a>js 的解释执行</h2><p>js  作为一门解释性语言，其运行过程分为 <code>预解析</code> 和 <code>自上而下逐行解释执行</code> 两个过程。包括的步骤<br>  词法分析、语法分析、预编译、执行</p>
<h3 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h3><p>  词法分析器的作用，是将一行行的源码拆解成一个个词义单位(token)，词义单位指的是语法上不可能再分的、最小的单个字符或字符组合。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; 2 </span><br><span class="line">function addA()&#123;</span><br><span class="line">  return a </span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 词法分析后的结果</span><br><span class="line">[</span><br><span class="line">  &#123;&quot;type&quot;:&quot;Keyword&quot;,&quot;value&quot;:&quot;var&quot;&#125;,</span><br><span class="line">  &#123;&quot;type&quot;:&quot;Identifier&quot;,&quot;value&quot;:&quot;a&quot;&#125;,</span><br><span class="line">  &#123;&quot;type&quot;:&quot;Punctuator&quot;,&quot;value&quot;:&quot;&#x3D;&quot;&#125;,</span><br><span class="line">  &#123;&quot;type&quot;:&quot;Numeric&quot;,&quot;value&quot;:&quot;2&quot;&#125;,</span><br><span class="line">  &#123;&quot;type&quot;:&quot;Punctuator&quot;,&quot;value&quot;:&quot;;&quot;&#125;,</span><br><span class="line">  &#123;&quot;type&quot;:&quot;Keyword&quot;,&quot;value&quot;:&quot;function&quot;&#125;,</span><br><span class="line">  &#123;&quot;type&quot;:&quot;Identifier&quot;,&quot;value&quot;:&quot;addA&quot;&#125;,</span><br><span class="line">  &#123;&quot;type&quot;:&quot;Punctuator&quot;,&quot;value&quot;:&quot;(&quot;&#125;,</span><br><span class="line">  &#123;&quot;type&quot;:&quot;Punctuator&quot;,&quot;value&quot;:&quot;)&quot;&#125;,</span><br><span class="line">  &#123;&quot;type&quot;:&quot;Punctuator&quot;,&quot;value&quot;:&quot;&#123;&quot;&#125;,</span><br><span class="line">  &#123;&quot;type&quot;:&quot;Keyword&quot;,&quot;value&quot;:&quot;return&quot;&#125;,</span><br><span class="line">  &#123;&quot;type&quot;:&quot;Identifier&quot;,&quot;value&quot;:&quot;a&quot;&#125;,</span><br><span class="line">  &#123;&quot;type&quot;:&quot;Punctuator&quot;,&quot;value&quot;:&quot;;&quot;&#125;,</span><br><span class="line">  &#123;&quot;type&quot;:&quot;Punctuator&quot;,&quot;value&quot;:&quot;&#125;&quot;&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h3 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h3><p>  js引擎要读的是抽象语法树<br>  语法分析将上一步生成的数组，根据语法规则，转为抽象语法树(AST)。如果源码符合语法规则，这一步就会顺利完成，生成一个抽象语法树；如果源码存在语法错误，这一步就会终止，抛出一个”语法错误”，并结束整个代码块的解析。</p>
<p>这个阶段主要做了两件事情</p>
<ul>
<li><p>确定作用域，根据静态作用域的特点，这个时候每个变量的作用域已经很明确了，不会再改变</p>
</li>
<li><p>记录每个作用域的所有变量和内嵌函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">  var a &#x3D; 2</span><br><span class="line">  function addA() &#123;</span><br><span class="line">    return a </span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 生成的抽象语法树</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;type&quot;: &quot;Program&quot;,</span><br><span class="line">  &quot;body&quot;: [</span><br><span class="line">      &#123;</span><br><span class="line">          &quot;type&quot;: &quot;VariableDeclaration&quot;,</span><br><span class="line">          &quot;declarations&quot;: [</span><br><span class="line">              &#123;</span><br><span class="line">                  &quot;type&quot;: &quot;VariableDeclarator&quot;,</span><br><span class="line">                  &quot;id&quot;: &#123;</span><br><span class="line">                      &quot;type&quot;: &quot;Identifier&quot;,</span><br><span class="line">                      &quot;name&quot;: &quot;a&quot;</span><br><span class="line">                  &#125;,</span><br><span class="line">                  &quot;init&quot;: &#123;</span><br><span class="line">                      &quot;type&quot;: &quot;Literal&quot;,</span><br><span class="line">                      &quot;value&quot;: 2,</span><br><span class="line">                      &quot;raw&quot;: &quot;2&quot;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          ],</span><br><span class="line">          &quot;kind&quot;: &quot;var&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">          &quot;type&quot;: &quot;FunctionDeclaration&quot;,</span><br><span class="line">          &quot;id&quot;: &#123;</span><br><span class="line">              &quot;type&quot;: &quot;Identifier&quot;,</span><br><span class="line">              &quot;name&quot;: &quot;addA&quot;</span><br><span class="line">          &#125;,</span><br><span class="line">          &quot;params&quot;: [],</span><br><span class="line">          &quot;body&quot;: &#123;</span><br><span class="line">              &quot;type&quot;: &quot;BlockStatement&quot;,</span><br><span class="line">              &quot;body&quot;: [</span><br><span class="line">                  &#123;</span><br><span class="line">                      &quot;type&quot;: &quot;ReturnStatement&quot;,</span><br><span class="line">                      &quot;argument&quot;: &#123;</span><br><span class="line">                          &quot;type&quot;: &quot;Identifier&quot;,</span><br><span class="line">                          &quot;name&quot;: &quot;a&quot;</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">              ]</span><br><span class="line">          &#125;,</span><br><span class="line">          &quot;generator&quot;: false,</span><br><span class="line">          &quot;expression&quot;: false,</span><br><span class="line">          &quot;async&quot;: false</span><br><span class="line">      &#125;</span><br><span class="line">  ],</span><br><span class="line">  &quot;sourceType&quot;: &quot;scr</span><br></pre></td></tr></table></figure>
<h3 id="预编译"><a href="#预编译" class="headerlink" title="预编译"></a>预编译</h3><p>预编译是指 JS 引擎再执行一个函数时，会创建对应的 <code>执行上下文</code> ，它根据抽象语法树做的一些’准备工作’。这个过程包括</p>
<ul>
<li>创建变量对象<ul>
<li>创建 arguments 对象，同名的实参，形参和变量之间是 引用 关系。</li>
<li>从语法分析树中复制作用域内的内嵌函数作为属性，key 为函数name,属性值为函数的内存地址。</li>
<li>从语法分析树中复制作用域内所有变量 作为属性，key 为变量名称，此时变量值全部为 undefined ，若变量和函数存在同名，则跳过</li>
</ul>
</li>
<li>创建作用域链，根据语法分析树中函数对应的作用域，结合当前环境的变量对象和上层环境的一系列变量对象组成</li>
<li>确定this 指向。<br>全局上下文的时候，变量对象就是全局对象 window,this也指向 window </li>
</ul>
<h3 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h3><p>开始执行后，执行上下文中的变量对象转换为活动对象，可以执行一些列的操作。</p>
<ul>
<li>变量赋值，查找规则是先找自身作用域，找不到就在作用域上查找</li>
<li>函数作用域</li>
<li>执行其他代码</li>
<li>执行结束，内存回收<br><code>代码执行结束后，函数内变量的生存周期取决于函数实例是否存在引用，如果没有就销毁活动对象</code></li>
</ul>
</li>
</ul>
<h3 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h3><p>  执行上下文就是当前 JavaScript 代码被解析和执行时所在环境的抽象概念，JavaScript 中运行任何的代码都是在执行上下文中运行。<br>  每当控制器转到可执行代码的时候，就会进入一个执行上下文。执行上下文可以理解为当前代码的执行环境，它会形成一个作用域。JavaScript 中的运行环境大概包括三种情况<br>    - 全局执行上下文: JavaScript 代码运行起来会首先进入该环境，是最基础的执行上下文。不在任何函数中的代码都位于全局执行上下文中。<br>      做了两件事<br>        - 创建全局对象，在浏览器中这个全局对象就是 window 对象<br>        - 将this指针指向这个全局对象。一个程序中只能存在一个全局执行上下文。<br>    - 函数执行上下文: 每次调用函数时，都会为该函数创建一个新的执行上下文。每个函数都拥有自己的执行上下文，<br>    - eval</p>
<h4 id="执行上下文的生命周期"><a href="#执行上下文的生命周期" class="headerlink" title="执行上下文的生命周期"></a>执行上下文的生命周期</h4><p>  执行上下文的生命周期包括三个阶段：创建阶段 –&gt; 执行阶段 –&gt; 回收阶段</p>
<ul>
<li><p>创建阶段</p>
<ul>
<li>创建变量对象：首先初始化函数的参数 arguments，提升函数声明和变量声明。</li>
<li>创建作用域链：在执行期上下文的创建阶段，作用域链是在变量对象之后创建的。作用域链本身包含变量对象。作用域链拥有解析变量。当被要求解析变量时，JavaScript 始终从代码嵌套的最内层开始，如果最内层没有找到变量，就会跳到上一层父作用域中查找，直到找到该变量。</li>
<li>确定this指向</li>
<li>变量对象(Variable Object)<br>在执行上下文创建阶段会生成变量对象，生成变量对象主要有三个过程</li>
</ul>
</li>
<li><p>检索当前上下文中的参数。该过程生成Arguments 对象，并建立以形参变量名为属性名，形参变量值为属性值的属性</p>
</li>
<li><p>检索当前上下文中的函数声明，该过程建立以函数名为属性名，函数所在内存地址引用为属性的值的属性</p>
</li>
<li><p>检索当前上下文中的变量声明。该过程建立以变量名为属性名，undefined 为属性值的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">VO &#x3D; &#123;</span><br><span class="line">  Arguments:&#123;&#125;,</span><br><span class="line">  ParamVariable: 具体值  &#x2F;&#x2F; 形参变量</span><br><span class="line">  Function: &lt;Function reference&gt;,</span><br><span class="line">  Variable: undefined</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当执行上下文进入执行阶段后，变量对象会变为<code>活动对象(Active Object)</code>此时原先声明的变量会被赋值。</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2022/04/13/js%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/js%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/" data-id="cl83x4ctm002nwgdxbwln24oz" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/3/">&amp;laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/5/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/JS%E6%A8%A1%E5%9D%97%E5%8C%96%E5%8F%91%E5%B1%95/">JS模块化发展</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/JavaScript-%E9%AB%98%E7%BA%A7/">JavaScript 高级</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/TypeScript/">TypeScript</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Vue-js/">Vue.js</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Vue-js/Props%E4%B8%8EData%E7%9A%84%E5%8C%BA%E5%88%AB/">Props与Data的区别</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Vue-js-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/">Vue.js 源码解读</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Vue-js-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E5%8F%98%E5%8C%96%E4%BE%A6%E6%B5%8B/">变化侦测</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Vue-js-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E5%8F%98%E5%8C%96%E4%BE%A6%E6%B5%8B/%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8F%98%E5%8C%96%E4%BE%A6%E5%90%AC/">数据的变化侦听</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Vue-js-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E5%90%8D%E8%AF%8D/">名词</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Vue-js-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E6%A8%A1%E6%9D%BF%E7%BC%96%E8%AF%91/">模板编译</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Vue-js-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/">生命周期</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Vue-js-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/%E5%88%9D%E5%A7%8B%E5%8C%96-initState-%E9%98%B6%E6%AE%B5/">初始化 initState 阶段</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Vue-js-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E8%99%9A%E6%8B%9FDOM/">虚拟DOM</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Vue-js-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E8%99%9A%E6%8B%9FDOM/Diff/">Diff</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Vue-js-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E8%99%9A%E6%8B%9FDOM/Vue%E4%B8%AD%E7%9A%84%E8%99%9A%E6%8B%9FDom/">Vue中的虚拟Dom</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Vue-js-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E8%99%9A%E6%8B%9FDOM/%E6%9B%B4%E6%96%B0%E5%AD%90%E8%8A%82%E7%82%B9/">更新子节点</a></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/async-await/">async await</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/elementUI%E5%A5%87%E6%80%AA%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/">elementUI奇怪问题解决办法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/element%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/">element使用不常用方法总结</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/es6/">es6</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/es6/Symbol/">Symbol</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/es6/%E8%BF%90%E7%AE%97%E7%AC%A6%E6%89%A9%E5%B1%95/">运算符扩展</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/import-%E5%92%8C-export/">import 和 export</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/js%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/">js知识体系</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/js%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/js-%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/">js 代码执行过程分析</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/js%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/js-%E8%AF%AD%E8%A8%80%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7/">js 语言的三大特性</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/js%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/%E4%BA%8B%E4%BB%B6/">事件</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/js%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/%E6%95%B0%E6%8D%AE/">数据</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/vue2-%E4%B8%8E-vue3/">vue2 与 vue3</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/webpack/">webpack</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/">正则表达式</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/%E6%AD%A3%E5%88%99%E7%9F%A5%E8%AF%86%E7%82%B9/">正则知识点</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E6%B6%89%E5%8F%8A%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9/">浏览器渲染涉及的知识点</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/">状态管理</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%99%BB%E5%BD%95%E8%AE%A4%E8%AF%81%E7%9F%A5%E8%AF%86/">登录认证知识</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9D%A2%E8%AF%95/vue%E7%9F%A5%E8%AF%86%E7%82%B9/">vue知识点</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9D%A2%E8%AF%95/vue%E7%9F%A5%E8%AF%86%E7%82%B9/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9F%A5%E8%AF%86/">生命周期知识</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9D%A2%E8%AF%95/vue%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%8CSPA%E5%8D%95%E9%A1%B5%E9%9D%A2/">vue知识点，SPA单页面</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9D%A2%E8%AF%95/vue%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%8C%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86-MVVM/">vue知识点，双向数据绑定原理& MVVM</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9D%A2%E8%AF%95/vue%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%8C%E8%B7%AF%E7%94%B1%E6%A8%A1%E5%BC%8F%E5%8E%9F%E7%90%86/">vue知识点，路由模式原理</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9D%A2%E8%AF%95/%E4%BB%8EURL%E8%BE%93%E5%85%A5%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%8E%B0%E6%B6%89%E5%8F%8A%E7%9A%84%E7%9F%A5%E8%AF%86%E3%80%82/">从URL输入到页面展现涉及的知识。</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9D%A2%E8%AF%95/%E4%BD%9C%E7%94%A8%E5%9F%9F-%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/">作用域-作用域链</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9D%A2%E8%AF%95/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/">浏览器缓存</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84js%E6%93%8D%E4%BD%9C/">项目中常用的js操作</a></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/09/">September 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/08/">August 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/07/">July 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/04/">April 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">July 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/09/15/js%E6%A8%A1%E5%9D%97%E5%8C%96%E5%8F%91%E5%B1%95/index/">JS 模块化</a>
          </li>
        
          <li>
            <a href="/2022/08/12/%E5%89%8D%E7%AB%AF%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/">前端状态管理</a>
          </li>
        
          <li>
            <a href="/2022/07/27/%E9%9D%A2%E8%AF%95/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/">面试/面试问题</a>
          </li>
        
          <li>
            <a href="/2022/07/16/vue2vsvue3/beagin/">vue2 VS vue3,</a>
          </li>
        
          <li>
            <a href="/2022/04/13/TypeScript/ts/">TypeScript</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2022 sxhMxd<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>