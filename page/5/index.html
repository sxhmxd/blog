<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>有理想的笛子</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="有理想的笛子">
<meta property="og:url" content="http://yoursite.com/page/5/index.html">
<meta property="og:site_name" content="有理想的笛子">
<meta property="og:locale" content="zh">
<meta property="article:author" content="sxhMxd">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="有理想的笛子" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">有理想的笛子</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-vue源码" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/04/22/vue%E6%BA%90%E7%A0%81/" class="article-date">
  <time datetime="2021-04-22T07:51:22.463Z" itemprop="datePublished">2021-04-22</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Vue-js-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/">Vue.js 源码解读</a>►<a class="article-category-link" href="/categories/Vue-js-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E5%8F%98%E5%8C%96%E4%BE%A6%E6%B5%8B/">变化侦测</a>►<a class="article-category-link" href="/categories/Vue-js-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E5%8F%98%E5%8C%96%E4%BE%A6%E6%B5%8B/%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8F%98%E5%8C%96%E4%BE%A6%E5%90%AC/">数据的变化侦听</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/04/22/vue%E6%BA%90%E7%A0%81/">Vue.js 源码解读,数据的变化侦听</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="变化侦听"><a href="#变化侦听" class="headerlink" title="变化侦听"></a>变化侦听</h1><p>数据驱动视图的关键在于怎么知道数据发生了变化。<code>js</code> 为我们提供了 <code>Object.defineProperty</code> 方法。该方法可以知道数据在什么时候发生变化。</p>
<h2 id="使-Object-数据变得可观测"><a href="#使-Object-数据变得可观测" class="headerlink" title="使 Object 数据变得可观测"></a>使 Object 数据变得可观测</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">let car &#x3D; &#123;&#125;</span><br><span class="line">let val &#x3D; 3000</span><br><span class="line">Object.defineProperty(car,&#39;price&#39;,&#123;</span><br><span class="line">  enumber: true,</span><br><span class="line">  configurable: true,</span><br><span class="line">  get()&#123;</span><br><span class="line">    console.log(&#39;price 属性被读取&#39;)</span><br><span class="line">    return val</span><br><span class="line">  &#125;,</span><br><span class="line">  set(newVal)&#123;</span><br><span class="line">    console.log(&#39;price 属性值被修改)</span><br><span class="line">    val &#x3D; newVal</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">car.price</span><br><span class="line">  &#x2F;&#x2F; price属性被读取了</span><br><span class="line">  &#x2F;&#x2F; 3000</span><br><span class="line">car.price &#x3D; 4000</span><br><span class="line">  &#x2F;&#x2F; price属性值被修改了</span><br><span class="line">  &#x2F;&#x2F; 4000</span><br></pre></td></tr></table></figure>

<p>经过上面的方法，car 数据对象已经是 <code>可观测</code> 的了。<br>为了把 car 对象所有的属性都变得可观测</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Observer类会通过递归的方式把一个对象的所有属性都转化成可观测对象</span><br><span class="line"> *&#x2F;</span><br><span class="line">export class Observer &#123;</span><br><span class="line">  constructor (value) &#123;</span><br><span class="line">    this.value &#x3D; value</span><br><span class="line">    &#x2F;&#x2F; 给value新增一个__ob__属性，值为该value的Observer实例</span><br><span class="line">    &#x2F;&#x2F; 相当于为value打上标记，表示它已经被转化成响应式了，避免重复操作</span><br><span class="line">    def(value,&#39;__ob__&#39;,this)</span><br><span class="line">    if (Array.isArray(value)) &#123;</span><br><span class="line">      &#x2F;&#x2F; 当value为数组时的逻辑</span><br><span class="line">      &#x2F;&#x2F; ...</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      this.walk(value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  walk (obj: Object) &#123;</span><br><span class="line">    const keys &#x3D; Object.keys(obj)</span><br><span class="line">    for (let i &#x3D; 0; i &lt; keys.length; i++) &#123;</span><br><span class="line">      defineReactive(obj, keys[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;**</span><br><span class="line"> * 使一个对象转化成可观测对象</span><br><span class="line"> * @param &#123; Object &#125; obj 对象</span><br><span class="line"> * @param &#123; String &#125; key 对象的key</span><br><span class="line"> * @param &#123; Any &#125; val 对象的某个key的值</span><br><span class="line"> *&#x2F;</span><br><span class="line">function defineReactive (obj,key,val) &#123;</span><br><span class="line">  &#x2F;&#x2F; 如果只传了obj和key，那么val &#x3D; obj[key]</span><br><span class="line">  if (arguments.length &#x3D;&#x3D;&#x3D; 2) &#123;</span><br><span class="line">    val &#x3D; obj[key]</span><br><span class="line">  &#125;</span><br><span class="line">  if(typeof val &#x3D;&#x3D;&#x3D; &#39;object&#39;)&#123;</span><br><span class="line">      new Observer(val)</span><br><span class="line">  &#125;</span><br><span class="line">  Object.defineProperty(obj, key, &#123;</span><br><span class="line">    enumerable: true,</span><br><span class="line">    configurable: true,</span><br><span class="line">    get()&#123;</span><br><span class="line">      console.log(&#96;$&#123;key&#125;属性被读取了&#96;);</span><br><span class="line">      return val;</span><br><span class="line">    &#125;,</span><br><span class="line">    set(newVal)&#123;</span><br><span class="line">      if(val &#x3D;&#x3D;&#x3D; newVal)&#123;</span><br><span class="line">          return</span><br><span class="line">      &#125;</span><br><span class="line">      console.log(&#96;$&#123;key&#125;属性被修改了&#96;);</span><br><span class="line">      val &#x3D; newVal;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="依赖收集"><a href="#依赖收集" class="headerlink" title="依赖收集"></a>依赖收集</h2><h3 id="什么是依赖收集"><a href="#什么是依赖收集" class="headerlink" title="什么是依赖收集"></a>什么是依赖收集</h3><p>通过上面的方法，让<code>object</code>变的可观测，我们知道数据什么时候发生了变化，我们去通知视图更新，我们到底通知那个模块发生变化？ 不能一个数据发生变化，整个视图就发生更新，因此我们只更新视图中用到这个数据就发生更新。也就是 <code>谁依赖了这个数据</code>，我们为每个数据都建一个依赖数组，谁依赖这个数据，我们就将谁放入这个依赖数组中，那么当该数据发生变化时我们就去它对应的依赖数组中，把每个依赖都通知一遍，发生更新。</p>
<h3 id="什么时候收集依赖，什么时候通知以此来更新"><a href="#什么时候收集依赖，什么时候通知以此来更新" class="headerlink" title="什么时候收集依赖，什么时候通知以此来更新"></a>什么时候收集依赖，什么时候通知以此来更新</h3><p>在 getter 中收集依赖，在 setter 中通知依赖更新</p>
<h3 id="依赖收集到哪里"><a href="#依赖收集到哪里" class="headerlink" title="依赖收集到哪里"></a>依赖收集到哪里</h3><p>我们给每个数据都建一个依赖数组，蛋蛋用一个数组的来存放依赖的话，功能欠缺并且代码过于耦合。更好的做法是我们为每一个依赖数据都建立一个依赖管理器，将该数据的依赖都管理起来。 依赖管理器 <code>Dep</code>类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 源码位置：src&#x2F;core&#x2F;observer&#x2F;dep.js</span><br><span class="line">export default class Dep &#123;</span><br><span class="line">  constructor () &#123;</span><br><span class="line">    this.subs &#x3D; []</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  addSub (sub) &#123;</span><br><span class="line">    this.subs.push(sub)</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 删除一个依赖</span><br><span class="line">  removeSub (sub) &#123;</span><br><span class="line">    remove(this.subs, sub)</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 添加一个依赖</span><br><span class="line">  depend () &#123;</span><br><span class="line">    if (window.target) &#123;</span><br><span class="line">      this.addSub(window.target)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 通知所有依赖更新</span><br><span class="line">  notify () &#123;</span><br><span class="line">    const subs &#x3D; this.subs.slice()</span><br><span class="line">    for (let i &#x3D; 0, l &#x3D; subs.length; i &lt; l; i++) &#123;</span><br><span class="line">      subs[i].update()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Remove an item from an array</span><br><span class="line"> *&#x2F;</span><br><span class="line">export function remove (arr, item) &#123;</span><br><span class="line">  if (arr.length) &#123;</span><br><span class="line">    const index &#x3D; arr.indexOf(item)</span><br><span class="line">    if (index &gt; -1) &#123;</span><br><span class="line">      return arr.splice(index, 1)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有了依赖管理器后，在 getter 中收集依赖，在 setter 中通知依赖更新，代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">function defineReactive (obj,key,val)&#123;</span><br><span class="line">  if (arguments.length &#x3D;&#x3D;&#x3D; 2) &#123;</span><br><span class="line">    val &#x3D; obj[key]</span><br><span class="line">  &#125;</span><br><span class="line">  if (typeof val &#x3D;&#x3D;&#x3D; &#39;Object&#39;) &#123;</span><br><span class="line">    new Observer(val)</span><br><span class="line">  &#125;</span><br><span class="line">  cosnt dep &#x3D; new Dep() &#x2F;&#x2F; 实例化一个依赖管理器，生成一个依赖管理数组 dep</span><br><span class="line">  Object.defineProperty(obj,key,&#123;</span><br><span class="line">    enumberable:true,</span><br><span class="line">    configurable:true,</span><br><span class="line">    get () &#123;</span><br><span class="line">      dep.depend() &#x2F;&#x2F; 在getter中收集依赖</span><br><span class="line">      return val</span><br><span class="line">    &#125;,</span><br><span class="line">    set (newVal) &#123;</span><br><span class="line">      if(val &#x3D;&#x3D; newVal) &#123;</span><br><span class="line">        return</span><br><span class="line">      &#125;</span><br><span class="line">      val &#x3D; newVal</span><br><span class="line">      dep.notify()  &#x2F;&#x2F; 在setter中通知依赖更新</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="依赖到底是-Who"><a href="#依赖到底是-Who" class="headerlink" title="依赖到底是 Who"></a>依赖到底是 Who</h4><p>一直在说 <code>谁用到了这个数据谁就是依赖</code>，在代码层面上该如何来描述这个<code>谁</code>。<br>在 <code>Vue</code> 中有一个叫 <code>Watcher</code> 的类，该类的实例就是我们上面说的那个<code>谁</code>，也就是谁用到了数据，谁就是依赖，我们为谁创建一个<code>Watcher</code>实例，在之后数据发生变化时，我们不直接通知依赖更新，而是通知依赖对应的 <code>watch</code> 实例，由 <code>Watchr</code>实例去通知真正的视图。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">export default class Watcher &#123;</span><br><span class="line">  constructor (vm,expOrFn,cb) &#123;</span><br><span class="line">    this.vm &#x3D; vm;</span><br><span class="line">    this.cb &#x3D; cb;</span><br><span class="line">    this.getter &#x3D; parsePath(expOrFn)</span><br><span class="line">    this.value &#x3D; this.get()</span><br><span class="line">  &#125;</span><br><span class="line">  get () &#123;</span><br><span class="line">    window.target &#x3D; this;</span><br><span class="line">    const vm &#x3D; this.vm</span><br><span class="line">    let value &#x3D; this.getter.call(vm,vm)</span><br><span class="line">    window.target &#x3D; undefined;</span><br><span class="line">    return value</span><br><span class="line">  &#125;</span><br><span class="line">  update () &#123;</span><br><span class="line">    const oldVlaue &#x3D; this.value</span><br><span class="line">    this.value &#x3D; this.get()</span><br><span class="line">    this.cb.call(this.vm,this.value,oldValue)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">const bailRE &#x3D; &#x2F;[^\w.$]&#x2F;</span><br><span class="line">export function parsePath (path) &#123;</span><br><span class="line">  if (bailRE.test(path)) &#123;</span><br><span class="line">    return</span><br><span class="line">  &#125;</span><br><span class="line">  const segments &#x3D; path.split(&#39;.&#39;)</span><br><span class="line">  return function (obj) &#123;</span><br><span class="line">    for (let i &#x3D; 0; i &lt; segments.length; i++) &#123;</span><br><span class="line">      if (!obj) return</span><br><span class="line">      obj &#x3D; obj[segments[i]]</span><br><span class="line">    &#125;</span><br><span class="line">    return obj</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Watcher</code>类代码实现逻辑</p>
<ul>
<li><p>当实例化<code>Watcher</code>类时，会先执行其构造函数；</p>
</li>
<li><p>在构造函数中调用了<code>this.get()</code>实例方法</p>
</li>
<li><p>在<code>get()</code>方法中，首先通过 <code>window.target = this</code> 把实例自身赋值给了一个全局<br>的一个唯一对象<code>window.target</code> 上，然后通过 <code>let value = this.getter.call(vm,vm)</code> 获取一下被依赖的数据，获取被依赖数据的目的是触发该数据上面的<code>getter</code>,在<code>getter</code> 里会调用<code>dep.depend()</code> 收集依赖，而在<code>dep.depend()</code>中取到挂<code>window.target</code> 上的值并将其存入依赖数组中，在<code>get()</code>方法最后将<code>window.target</code>释放掉。</p>
</li>
<li><p>当数据变化时，会触发数据的<code>setter</code>，在<code>setter</code>中调用<code>dep.notify()</code>方法，在<code>dep.notify()</code> 方法中，遍历所有依赖(即 watcher 实例)，执行依赖的<code>update()</code>方法，也就时 <code>Watcher</code>类中的<code>update()</code>实例方法，在<code>update()</code> 方法中调用数据变化的更新回调函数，从而更新视图。</p>
<p><img src="https://vue-js.com/learn-vue/assets/img/3.0b99330d.jpg" alt="avatar"></p>
</li>
</ul>
<p>以上的流程是</p>
<ul>
<li><p><code>Data</code> 通过 <code>observer</code> 转换成了 <code>getter/setter</code>的形式来追踪变化</p>
</li>
<li><p>当外界通过<code>Watcher</code>读取数据时，会触发<code>getter</code>从而将 <code>Watcher</code> 添加到依赖中。</p>
</li>
<li><p>当数据发生了变化时，会触发<code>setter</code>, 从而向 <code>Dep</code> 中的依赖(即 Watcher) 发送通知。</p>
</li>
<li><p><code>Watcher</code> 接收到通知后，会向外界发送通知，变化通知到外界后可能会触发视图更新，也有可能触发用户的某个回调函数等。</p>
</li>
</ul>
<h2 id="Array-的变化侦测"><a href="#Array-的变化侦测" class="headerlink" title="Array 的变化侦测"></a>Array 的变化侦测</h2><h3 id="收集依赖的地方"><a href="#收集依赖的地方" class="headerlink" title="收集依赖的地方"></a>收集依赖的地方</h3><p><code>Array</code> 型数据的依赖收集方式和 <code>Object</code> 数据的依赖收集方式相同，都是在<code>getter</code>中收集。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data()&#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    arr:[1,2,3]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在组件<code>data</code>中，<code>arr</code>这个数据始终存在于一个<code>Object</code>数据对象中，谁用到了数据谁就是依赖，那么用到<code>arr</code>这个数据，得先从<code>Object</code>数据对象中获取一下，从<code>Object</code>数据对象中获取<code>arr</code>数据自然会触发 <code>arr</code>的 <code>getter</code><br><code>Array型数据还是在getter中收集依赖</code></p>
<h3 id="使-Array-型数据可观测"><a href="#使-Array-型数据可观测" class="headerlink" title="使 Array 型数据可观测"></a>使 Array 型数据可观测</h3><ul>
<li>实现思路<br>要想让<code>Array</code> 型数据发生变化，必然是操作了 <code>Array</code> , 而 <code>js</code> 中提供的操作数组的方法是固定的，可以将这些方法都重写一遍，在不改变原有功能的前提下，为其新增一些其他功能，</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let arr &#x3D; [1,2,3]</span><br><span class="line">arr.push(4)</span><br><span class="line">Array.prototype.newPush &#x3D; function(val)&#123;</span><br><span class="line">  console.log(&#39;arr 数组被改变了&#39;)</span><br><span class="line">  this.push(val)</span><br><span class="line">&#125;</span><br><span class="line">arr.newPush(4) &#x2F;&#x2F; [1,2,3,4]</span><br></pre></td></tr></table></figure>

<ul>
<li>数组方法拦截器</li>
</ul>
<p>在<code>Vue</code>中创建一个数组方法拦截器，拦截在数组实例与<code>Array.prototype</code>之间，在拦截器内部重写操作数组的一些方法，当数组实例使用操作数组方法时，其实使用的是拦截器中重写的方法，不再使用<code>Array.prototype</code> 上的原生方法</p>
<p><img src="https://vue-js.com/learn-vue/assets/img/2.b446ab83.png" alt="avatar"></p>
<p>源码中的拦截器代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">const arrayProto &#x3D; Array.prototype</span><br><span class="line">export const arrayMethods &#x3D; Object.create(arrayProto)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 改变数组自身内容的7个方法</span><br><span class="line">const methodsToPatch &#x3D; [</span><br><span class="line">  &#39;push&#39;,</span><br><span class="line">  &#39;pop&#39;,</span><br><span class="line">  &#39;shift&#39;,</span><br><span class="line">  &#39;unshift&#39;,</span><br><span class="line">  &#39;splice&#39;,</span><br><span class="line">  &#39;sort&#39;,</span><br><span class="line">  &#39;reverse&#39;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Intercept mutating methods and emit events</span><br><span class="line"> *&#x2F;</span><br><span class="line">methodsToPatch.forEach(function (method) &#123;</span><br><span class="line">  const original &#x3D; arrayProto[method]      &#x2F;&#x2F; 缓存原生方法</span><br><span class="line">  Object.defineProperty(arrayMethods, method, &#123;</span><br><span class="line">    enumerable: false,</span><br><span class="line">    configurable: true,</span><br><span class="line">    writable: true,</span><br><span class="line">    value:function mutator(...args)&#123;</span><br><span class="line">      const result &#x3D; original.apply(this, args)</span><br><span class="line">      return result</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>拦截器的使用</li>
</ul>
<p>源码实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">export default Observer &#123;</span><br><span class="line">  constructor (value) &#123;</span><br><span class="line">    this.value &#x3D; value</span><br><span class="line">    if (Array.isArray(value)) &#123;</span><br><span class="line">      const augment &#x3D; hasProto ? protoAugment : copyAugment</span><br><span class="line">      augment(value,arrayMethods,arrayKeys)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      this.walk(value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 能力检测： 判断 __proto__ 是否可用，有浏览器不支持该属性</span><br><span class="line">export const hasProto &#x3D; &#39;__proto__&#39; in &#123;&#125;</span><br><span class="line">const arrayKeys &#x3D; Object.getOwnPropertyNames(arrayMethods)</span><br><span class="line">&#x2F;**</span><br><span class="line"> * Augment an target Object or Array by intercepting</span><br><span class="line"> * the prototype chain using __proto__</span><br><span class="line"> *&#x2F;</span><br><span class="line">function protoAugment (target, src: Object, keys: any) &#123;</span><br><span class="line">  target.__proto__ &#x3D; src</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Augment an target Object or Array by defining</span><br><span class="line"> * hidden properties.</span><br><span class="line"> *&#x2F;</span><br><span class="line">&#x2F;* istanbul ignore next *&#x2F;</span><br><span class="line">function copyAugment (target: Object, src: Object, keys: Array&lt;string&gt;) &#123;</span><br><span class="line">  for (let i &#x3D; 0, l &#x3D; keys.length; i &lt; l; i++) &#123;</span><br><span class="line">    const key &#x3D; keys[i]</span><br><span class="line">    def(target, key, src[key])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="依赖收集-1"><a href="#依赖收集-1" class="headerlink" title="依赖收集"></a>依赖收集</h3><p>数组的依赖收集也在<code>getter</code> 中收集，而给数组数据添加<code>getter/setter</code> 都是在<code>Observer</code>类中完成的，在<code>Observer</code>类中收集依赖。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">export class Observer &#123;</span><br><span class="line">  constructor (value) &#123;</span><br><span class="line">    this.value &#x3D; value</span><br><span class="line">    this.dep &#x3D; new Dep()</span><br><span class="line">    if (Array.isArray(value)) &#123;</span><br><span class="line">      const augment &#x3D; hasProto</span><br><span class="line">        ? protoAugment</span><br><span class="line">        : copyAugment</span><br><span class="line">      augment(value, arrayMethods, arrayKeys)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      this.walk(value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>怎样收集依赖</li>
</ul>
<p>依赖管理器定义在<code>Observer</code> 类中，而我们需要在<code>getter</code>中收集依赖，也就是说我们必须在<code>getter</code>中能够访问到<code>Observer</code>类中的依赖管理器，才能把依赖存进去。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">function defineReactive (obj,key,val) &#123;</span><br><span class="line">  let childOb &#x3D; observe(val)</span><br><span class="line">  Object.defineProperty(obj, key, &#123;</span><br><span class="line">    enumerable: true,</span><br><span class="line">    configurable: true,</span><br><span class="line">    get()&#123;</span><br><span class="line">      if (childOb) &#123;</span><br><span class="line">        childOb.dep.depend()</span><br><span class="line">      &#125;</span><br><span class="line">      return val;</span><br><span class="line">    &#125;,</span><br><span class="line">    set(newVal)&#123;</span><br><span class="line">      if(val &#x3D;&#x3D;&#x3D; newVal)&#123;</span><br><span class="line">        return</span><br><span class="line">      &#125;</span><br><span class="line">      val &#x3D; newVal;</span><br><span class="line">      dep.notify()   &#x2F;&#x2F; 在setter中通知依赖更新</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Attempt to create an observer instance for a value,</span><br><span class="line"> * returns the new observer if successfully observed,</span><br><span class="line"> * or the existing observer if the value already has one.</span><br><span class="line"> * 尝试为value创建一个0bserver实例，如果创建成功，直接返回新创建的Observer实例。</span><br><span class="line"> * 如果 Value 已经存在一个Observer实例，则直接返回它</span><br><span class="line"> *&#x2F;</span><br><span class="line">export function observe (value, asRootData)&#123;</span><br><span class="line">  if (!isObject(value) || value instanceof VNode) &#123;</span><br><span class="line">    return</span><br><span class="line">  &#125;</span><br><span class="line">  let ob</span><br><span class="line">  if (hasOwn(value, &#39;__ob__&#39;) &amp;&amp; value.__ob__ instanceof Observer) &#123;</span><br><span class="line">    ob &#x3D; value.__ob__</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    ob &#x3D; new Observer(value)</span><br><span class="line">  &#125;</span><br><span class="line">  return ob</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>怎样通知依赖</li>
</ul>
<p>要想通知依赖，首先能访问到依赖，即只要能访问到被转化成响应式的数据 <code>value</code> 即可，因为<code>value</code> 上的 <code>__ob__</code>就是其对应的<code>Observer</code> 类实例，有了该实例我们就能访问到它上面的依赖管理器，然后只需要调用依赖管理的 <code>dep.notify()</code> 方法，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 源码</span><br><span class="line">methodsToPatch.forEach(function (method) &#123;</span><br><span class="line">  const original &#x3D; arrayProto[method]</span><br><span class="line">  def(arrayMethods, method, function mutator (...args) &#123;</span><br><span class="line">    const result &#x3D; original.apply(this, args)</span><br><span class="line">    const ob &#x3D; this.__ob__</span><br><span class="line">    &#x2F;&#x2F; notify change</span><br><span class="line">    ob.dep.notify()</span><br><span class="line">    return result</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="深度侦测"><a href="#深度侦测" class="headerlink" title="深度侦测"></a>深度侦测</h3><p>在前文所有讲的 Array 型数据的变化侦测都仅仅说的是数组自身变化的侦测，比如给数组新增一个元素或删除数组中一个元素，而在 Vue 中，不论是 Object 型数据还是 Array 型数据所实现的数据变化侦测都是深度侦测，所谓深度侦测就是不但要侦测数据自身的变化，还要侦测数据中所有子数据的变化。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let arr &#x3D; [</span><br><span class="line">  &#123;</span><br><span class="line">    name:&#39;NLRX&#39;，</span><br><span class="line">    age:&#39;18&#39;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>数组中包含一个对象，如果该对象的某个属性发生了变化也应该被侦测到，就是深度侦测。<br>实现逻辑</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">export class Observer &#123;</span><br><span class="line">  value: any;</span><br><span class="line">  dep: Dep;</span><br><span class="line"></span><br><span class="line">  constructor (value: any) &#123;</span><br><span class="line">    this.value &#x3D; value</span><br><span class="line">    this.dep &#x3D; new Dep()</span><br><span class="line">    def(value, &#39;__ob__&#39;, this)</span><br><span class="line">    if (Array.isArray(value)) &#123;</span><br><span class="line">      const augment &#x3D; hasProto</span><br><span class="line">        ? protoAugment</span><br><span class="line">        : copyAugment</span><br><span class="line">      augment(value, arrayMethods, arrayKeys)</span><br><span class="line">      this.observeArray(value)   &#x2F;&#x2F; 将数组中的所有元素都转化为可被侦测的响应式</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      this.walk(value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;**</span><br><span class="line">   * Observe a list of Array items.</span><br><span class="line">   *&#x2F;</span><br><span class="line">  observeArray (items: Array&lt;any&gt;) &#123;</span><br><span class="line">    for (let i &#x3D; 0, l &#x3D; items.length; i &lt; l; i++) &#123;</span><br><span class="line">      observe(items[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function observe (value, asRootData)&#123;</span><br><span class="line">  if (!isObject(value) || value instanceof VNode) &#123;</span><br><span class="line">    return</span><br><span class="line">  &#125;</span><br><span class="line">  let ob</span><br><span class="line">  if (hasOwn(value, &#39;__ob__&#39;) &amp;&amp; value.__ob__ instanceof Observer) &#123;</span><br><span class="line">    ob &#x3D; value.__ob__</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    ob &#x3D; new Observer(value)</span><br><span class="line">  &#125;</span><br><span class="line">  return ob</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数组新增元素的侦测"><a href="#数组新增元素的侦测" class="headerlink" title="数组新增元素的侦测"></a>数组新增元素的侦测</h3><p>向数组内新增的方法有 3 个，分别是：push、unshift、splice。我们只需对这 3 中方法分别处理，拿到新增的元素，再将其转化即可</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Intercept mutating methods and emit events</span><br><span class="line"> *&#x2F;</span><br><span class="line">methodsToPatch.forEach(function (method) &#123;</span><br><span class="line">  &#x2F;&#x2F; cache original method</span><br><span class="line">  const original &#x3D; arrayProto[method]</span><br><span class="line">  def(arrayMethods, method, function mutator (...args) &#123;</span><br><span class="line">    const result &#x3D; original.apply(this, args)</span><br><span class="line">    const ob &#x3D; this.__ob__</span><br><span class="line">    let inserted</span><br><span class="line">    switch (method) &#123;</span><br><span class="line">      case &#39;push&#39;:</span><br><span class="line">      case &#39;unshift&#39;:</span><br><span class="line">        inserted &#x3D; args   &#x2F;&#x2F; 如果是push或unshift方法，那么传入参数就是新增的元素</span><br><span class="line">        break</span><br><span class="line">      case &#39;splice&#39;:</span><br><span class="line">        inserted &#x3D; args.slice(2) &#x2F;&#x2F; 如果是splice方法，那么传入参数列表中下标为2的就是新增的元素</span><br><span class="line">        break</span><br><span class="line">    &#125;</span><br><span class="line">    if (inserted) ob.observeArray(inserted) &#x2F;&#x2F; 调用observe函数将新增的元素转化成响应式</span><br><span class="line">    &#x2F;&#x2F; notify change</span><br><span class="line">    ob.dep.notify()</span><br><span class="line">    return result</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2021/04/22/vue%E6%BA%90%E7%A0%81/" data-id="cl139u3gg0008swdx5f0v5573" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-props与Data的区别" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/04/22/props%E4%B8%8EData%E7%9A%84%E5%8C%BA%E5%88%AB/" class="article-date">
  <time datetime="2021-04-22T07:51:22.462Z" itemprop="datePublished">2021-04-22</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Vue-js/">Vue.js</a>►<a class="article-category-link" href="/categories/Vue-js/Props%E4%B8%8EData%E7%9A%84%E5%8C%BA%E5%88%AB/">Props与Data的区别</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/04/22/props%E4%B8%8EData%E7%9A%84%E5%8C%BA%E5%88%AB/">Vue.js 源码解读, 虚拟Dom</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Vue-中的Props-与-Data-细微差别。"><a href="#Vue-中的Props-与-Data-细微差别。" class="headerlink" title="Vue 中的Props 与 Data 细微差别。"></a>Vue 中的Props 与 Data 细微差别。</h1><p>Vue 提供了两种不同的存储变量: <code>props</code> 和 <code>data</code>。</p>
<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p><code>data</code> 是每个组件的私有内存，可以在其中存储需要的任何变量。<code>props</code>是将数据从父组件传递到子组件的方式。</p>
<h2 id="什么是-props"><a href="#什么是-props" class="headerlink" title="什么是 props"></a>什么是 props</h2><p>在 <code>Vue</code> 中 <code>props</code> 是我们将数据从父组件向下传递到其子组件的方式。<br>当我们从组件内部访问<code>props</code>时，我们并不拥有他们，我们不能更改他们。</p>
<h2 id="什么是-Data"><a href="#什么是-Data" class="headerlink" title="什么是 Data"></a>什么是 Data</h2><p><code>data</code> 是每个组件的内存，这就是存储数据和希望跟踪的任何其他变量的地方。</p>
<h2 id="props-和-data-都是响应式的"><a href="#props-和-data-都是响应式的" class="headerlink" title="props 和 data 都是响应式的"></a>props 和 data 都是响应式的</h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2021/04/22/props%E4%B8%8EData%E7%9A%84%E5%8C%BA%E5%88%AB/" data-id="cl139u3go000dswdxghya7odz" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-js知识体系/数据" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/04/22/js%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/%E6%95%B0%E6%8D%AE/" class="article-date">
  <time datetime="2021-04-22T07:51:22.462Z" itemprop="datePublished">2021-04-22</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/js%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/">js知识体系</a>►<a class="article-category-link" href="/categories/js%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/%E6%95%B0%E6%8D%AE/">数据</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/04/22/js%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/%E6%95%B0%E6%8D%AE/">JS 数据</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="原始数据"><a href="#原始数据" class="headerlink" title="原始数据"></a>原始数据</h1><p>原始数据类型共有六种：Number 、String 、Boolean 、 Undefined 、 Null 、Symbol</p>
<h2 id="Number-数据类型"><a href="#Number-数据类型" class="headerlink" title="Number 数据类型"></a>Number 数据类型</h2><p>Number 数据类型包含数字和 NaN</p>
<h3 id="NaN"><a href="#NaN" class="headerlink" title="NaN"></a>NaN</h3><p><code>NaN</code> 非数字，不是一个数但是隶属于数字类型 NaN 和任何值(包括自己)相比较，不大于、不小于、不等于任何值。</p>
<p>判断是不是数字类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">isNaN(&#39;1243&#39;)   &#x2F;&#x2F; false 虽然&#39;123&#39; 是字符串类型，但是由于是纯数字组成可以转换成一个数字</span><br><span class="line"></span><br><span class="line">isNaN(123)    &#x2F;&#x2F; false 说明是数字</span><br><span class="line"></span><br><span class="line">isNaN(&#39;123ffff&#39;) &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<h3 id="数字不同进制"><a href="#数字不同进制" class="headerlink" title="数字不同进制"></a>数字不同进制</h3><p>Number 可以使用四种数字进制：十进制，二进制，八进制和十六进制<br>二进制：以零为开头，后面接一个小写或大写的拉丁文字母 B(0b 或者 0B)<br>八进制：以零为开头，假如 0 后面的数字不在 0 到 7 的范围内，改数字会被转换成十进制数字<br>十六进制：以零为开头，后面接一个小写或大写的拉丁文字母(0x 或者 0X)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 十进制</span><br><span class="line">1234566</span><br><span class="line">12</span><br><span class="line">&#x2F;&#x2F; 二进制</span><br><span class="line">0b1100    &#x2F;&#x2F; 12</span><br><span class="line">0b0001    &#x2F;&#x2F; 1</span><br><span class="line">&#x2F;&#x2F; 八进制</span><br><span class="line">0755    &#x2F;&#x2F; 493</span><br><span class="line">0644    &#x2F;&#x2F; 420</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 十六进制</span><br><span class="line">0xA     &#x2F;&#x2F; 10</span><br></pre></td></tr></table></figure>

<h3 id="转换成数字方法"><a href="#转换成数字方法" class="headerlink" title="转换成数字方法"></a>转换成数字方法</h3><p>Number()、parseInt()、parseFloat()</p>
<h4 id="Number"><a href="#Number" class="headerlink" title="Number()"></a>Number()</h4><p>可以用于任何数据类型，</p>
<ul>
<li><p>转换规则</p>
<ul>
<li><p>Boolean 值，true 转换成 1，false 转换成 0</p>
</li>
<li><p>null 值，返回 0。</p>
</li>
<li><p>undefined，返回 NaN</p>
</li>
<li><p>如果是字符串，遵循的规则</p>
<ul>
<li><p>只包含数字(包括带正负号的情况)，则转换为十进制，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Number(&#39;1&#39;)   &#x2F;&#x2F; 1</span><br><span class="line">Number(&#39;+1&#39;)  &#x2F;&#x2F; 1</span><br><span class="line">Number(&#39;011&#39;) &#x2F;&#x2F; 11   前导的零被忽略</span><br></pre></td></tr></table></figure></li>
<li><p>字符是有效的浮点数格式，则将其转换成相对应的浮点数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Number(&#39;-1.1&#39;)   &#x2F;&#x2F; -1.1</span><br><span class="line">Number(&#39;01.1&#39;)   &#x2F;&#x2F; 1.1</span><br><span class="line">Number(&#39;-01.12&#39;) &#x2F;&#x2F; 1.12</span><br></pre></td></tr></table></figure></li>
<li><p>字符串包含有效的十六进制或者二进制格式，则将其转换为相同大小的十进制整数值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Number(&#39;0xF&#39;)   &#x2F;&#x2F; 15</span><br><span class="line">Number(&#39;0b1000&#39;) &#x2F;&#x2F; 8</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果是空字符串，则将其转换为 0 Number(‘’) // 0</p>
</li>
<li><p>如果不符合上面的，将其转换成 NaN Number(‘0www’) // NaN</p>
</li>
</ul>
</li>
<li><p>如果是对象，则调用 valueOf() 方法，然后依照前面的规则转换返回的值，如果转换的值是 NaN ,则调用对象的 toString() 方法，然后再按照前面的规则转换字符串。</p>
</li>
</ul>
</li>
</ul>
<h4 id="parseInt"><a href="#parseInt" class="headerlink" title="parseInt()"></a>parseInt()</h4><p>处理整数的时候，更常用 parseInt()函数<br>在转换字符串时是看其是否符合数值模式，会忽略字符串前面的空格，如果第一个字符不是数字或者符号就会返回 NaN</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">parseInt(&#39;123456blue&#39;)   &#x2F;&#x2F; 123456</span><br><span class="line">parseInt(&#39;&#39;)             &#x2F;&#x2F; NaN</span><br><span class="line">parseInt(&#39;22.34&#39;)        &#x2F;&#x2F; 22</span><br><span class="line">parseInt(&#39;0xa&#39;)          &#x2F;&#x2F; 10  符合十六进制，转换成十进制</span><br><span class="line">parseInt(&#39;070&#39;)          &#x2F;&#x2F; 56  符合八进制，</span><br><span class="line">parseInt(&#39;70&#39;)           &#x2F;&#x2F; 70</span><br><span class="line">parseInt(&#39;0b1100&#39;)       &#x2F;&#x2F; 0</span><br></pre></td></tr></table></figure>

<p>在包含进制的时候，parseInt(),可以有第二个参数，说明是几进制</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">parseInt(&#39;10&#39;,2) &#x2F;&#x2F;2 按二进制解析转换为十进制</span><br><span class="line">parseInt(&#39;10&#39;,8) &#x2F;&#x2F;8 按八进制解析转换为十进制</span><br><span class="line">parseInt(&#39;10&#39;,10) &#x2F;&#x2F;10 按八进制解析转换为十进制</span><br><span class="line">parseInt(&#39;10&#39;,16) &#x2F;&#x2F;16 按十六进制解析转换为十进制</span><br></pre></td></tr></table></figure>

<h4 id="parseFloat"><a href="#parseFloat" class="headerlink" title="parseFloat()"></a>parseFloat()</h4><p>parseFloat() 与 parseInt() 的解析方法基本一样，对浮点数和进制数不同<br>parseFloat 会忽略前置零</p>
<p>parseFloat() 对于二进制，十六进制的转换都是 0</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">parseFloat(&#39;123456blue&#39;)   &#x2F;&#x2F; 123456</span><br><span class="line">parseFloat(&#39;&#39;)             &#x2F;&#x2F; NaN</span><br><span class="line">parseFloat(&#39;22.34&#39;)        &#x2F;&#x2F; 22.34</span><br><span class="line">parseFloat(&#39;0xa&#39;)          &#x2F;&#x2F; 0  十六进制字符串始终为零</span><br><span class="line">parseFloat(&#39;070&#39;)          &#x2F;&#x2F; 70</span><br><span class="line">parseFloat(&#39;70&#39;)           &#x2F;&#x2F; 70</span><br><span class="line">parseFloat(&#39;0b1100&#39;)       &#x2F;&#x2F; 0</span><br></pre></td></tr></table></figure>

<h2 id="String-类型"><a href="#String-类型" class="headerlink" title="String 类型"></a>String 类型</h2><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let strObject &#x3D; new String(&#39;hello word&#39;)</span><br><span class="line">let strs &#x3D; &#39;hello word&#39;</span><br><span class="line"></span><br><span class="line">typeof (strObject)   &#x2F;&#x2F; object</span><br><span class="line">typeof(strs)  &#x2F;&#x2F; String</span><br></pre></td></tr></table></figure>

<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p>string 具有长度属性，字符串长度(空格也占位),可以通过 string[index]来访问对应的字符</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let str &#x3D; &#39;today is good day&#39;</span><br><span class="line">str.length &#x2F;&#x2F; 17</span><br><span class="line">str[2]     &#x2F;&#x2F; d</span><br></pre></td></tr></table></figure>

<h3 id="string-方法"><a href="#string-方法" class="headerlink" title="string 方法"></a>string 方法</h3><ul>
<li><p>charAt(n)<br>传入数值，返回该位置对应字符</p>
</li>
<li><p>charCodeAt(n)<br>传入数值，返回该位置对应字符编码</p>
</li>
<li><p>slice(n,m) 字符串截取，接受一个或者两个值<br>从 index 为 n 开始(包括 n),到 index 为 m 结束(不包括 m) 返回一个新的字符串，不改变原字符串。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var str &#x3D; &#39;DaShu.yang&#39;</span><br><span class="line">str.charAt(2) &#x2F;&#x2F; 3</span><br><span class="line">str.charCodeAt(2) &#x2F;&#x2F; 83</span><br><span class="line">str.slice(2)   &#x2F;&#x2F; Shu.yang</span><br><span class="line">str.slice(2,3) &#x2F;&#x2F; S</span><br></pre></td></tr></table></figure>

<ul>
<li><p>indexOf()<br>搜索给定字符串，然后返回字符串的位置(找到返回该字符串的 index 值，反之返回 -1)，可以接受第二个参数，表示从字符串中的哪个位置开始搜索。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let str &#x3D; &#39;qwertyuiop&#39;;</span><br><span class="line">str.indexOf(&#39;w&#39;) &#x2F;&#x2F; 1</span><br><span class="line">str.indexOf(&#39;m&#39;)  &#x2F;&#x2F; -1</span><br></pre></td></tr></table></figure>
</li>
<li><p>match()<br>字符串的模式匹配方法，接收一个正则表达式或者 RegExp 对象，返回一个数组，如果没匹配值返回 null<br>该方法可在字符串内检索指定的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var str &#x3D; &#39;asdfghajk&#39;</span><br><span class="line">str.match(&#39;a&#39;)    &#x2F;&#x2F; [a] 查找是惰性的只会返回一个a,即查找到了第一个就返回查找结果。</span><br><span class="line">str.amtch(&#x2F;a&#x2F;g)   &#x2F;&#x2F; [ a,a ]</span><br></pre></td></tr></table></figure></li>
<li><p>replace()<br>字符串替换，接收两个参数，第一个参数为字符串或者正则表达式，第二个参数是字符串或者是一个函数，返回一个字符串。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var text &#x3D; &#39;cat,bat,sat,fat&#39;</span><br><span class="line">var reg &#x3D; &#x2F;at&#x2F;g</span><br><span class="line">str.replace(reg,&#39;&#39;)</span><br><span class="line">var str &#x3D; &#39;abcdefg&#39;</span><br><span class="line">var reg &#x3D; &#x2F;(c)d&#x2F;g</span><br><span class="line">str.replace(reg,&#39;$$d&#39;) &#x2F;&#x2F; ab$defg</span><br><span class="line">var reg1 &#x3D; &#x2F;(c)d(e)&#x2F;g</span><br><span class="line">str.replace(reg,&#39;$2$1&#39;)  &#x2F;&#x2F; abedcfg</span><br><span class="line">&#x2F;&#x2F;这里把匹配的第一个内容和第二个内容替换位置($1匹配第一个位置，$2匹配第二个位置，然后再替换整个匹配到的cde)</span><br></pre></td></tr></table></figure>
</li>
<li><p>split<br>字符串分割，接收两个参数，第一个字符串或者正则表达式，第二个是返回数组的最大长度，返回一个数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var text &#x3D; &#39;cat,bat,sat,fat&#39;</span><br><span class="line">text.split(&#39;,&#39;)       &#x2F;&#x2F; [&#39;cat&#39;,&#39;bat&#39;,&#39;sat&#39;,&#39;fat&#39;]</span><br><span class="line">text.split(&#39;,&#39;,3)     &#x2F;&#x2F; [&#39;cat&#39;,&#39;bat&#39;,&#39;sat&#39;]</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h2><h3 id="创建-1"><a href="#创建-1" class="headerlink" title="创建"></a>创建</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var boo &#x3D; new Boolean()    &#x2F;&#x2F; false 未对boo进行赋值，默认值为 false</span><br><span class="line">var boo new Boolean(true)  &#x2F;&#x2F; true</span><br><span class="line">var boo &#x3D; true&#x2F;false</span><br></pre></td></tr></table></figure>

<p>如果逻辑对象无初始值或者其值为 0 -0 null ‘’ false undefined NaN,那么对象的值为 false,否则其值为 true</p>
<ul>
<li>! 一个叹号是取反，首先将值转化为布尔类型的，然后再取反</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">!3 &#x2F;&#x2F; false -&gt;先把3转化为 boolean 此时为 true,然后再取反为 false</span><br><span class="line">!0 &#x2F;&#x2F; true -&gt; 先把 0 转化为 boolean 此时为 false,然后再取反为 true</span><br></pre></td></tr></table></figure>

<p>!! 将其他的数据类型转化为 boolean 类型，相当于 Boolean()</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Boolean(&#39;dddd&#39;) &#x2F;&#x2F; true</span><br><span class="line">!!&#39;dddd&#39;        &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<h3 id="不同数据类型的比较"><a href="#不同数据类型的比较" class="headerlink" title="不同数据类型的比较"></a>不同数据类型的比较</h3><ul>
<li><p>两个不同类型数据比较时隐式转换规则</p>
<ul>
<li><p>数字和字符串、布尔类型、数组进行比较时，字符串(或者布尔、或数组)先转换为数字(Number),再进行比较。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">123 &#x3D;&#x3D; &#39;1234a&#39;  &#x2F;&#x2F; false</span><br><span class="line">123 &#x3D;&#x3D; &#39;123&#39;    &#x2F;&#x2F; true</span><br><span class="line">123 &#x3D;&#x3D; false    &#x2F;&#x2F; false</span><br><span class="line">123 &#x3D;&#x3D; true     &#x2F;&#x2F; false</span><br></pre></td></tr></table></figure></li>
<li><p>字符串和布尔类型比较，进行比较的两个数据同时经过 Number() 的转换后再进行比较，数组和布尔类型的比较也如此</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#39;qwe&#39; &#x3D;&#x3D;  false   &#x2F;&#x2F; false   Number(&#39;qwe&#39;) -&gt; NaN ; Number(false) -&gt; 0</span><br><span class="line">&#39;qwe&#39; &#x3D;&#x3D; true     &#x2F;&#x2F; false</span><br><span class="line">&#39;&#39;  &#x3D;&#x3D;  false     &#x2F;&#x2F; true    Number(&#39;&#39;) -&gt; 0 ; Number(false) -&gt; 0</span><br><span class="line">&#39;&#39;  &#x3D;&#x3D;  true      &#x2F;&#x2F; false</span><br><span class="line">[]  &#x3D;&#x3D;  false     &#x2F;&#x2F; true    Number([]) -&gt; 0</span><br><span class="line">[0]  &#x3D;&#x3D;  false    &#x2F;&#x2F; true    Number([0]) -&gt; 0</span><br><span class="line">[00]  &#x3D;&#x3D;  false   &#x2F;&#x2F; true    Number([00]) -&gt; 0</span><br><span class="line">[0,0] &#x3D;&#x3D;  false   &#x2F;&#x2F; false   Number([0,0]) -&gt; NaN</span><br></pre></td></tr></table></figure></li>
<li><p>undefined 除了和 Null 进行非全等比较返回 true，其它均返回 false。</p>
</li>
<li><p>null 除了和 undefined 进行非全等比较返回 true，其它均返回 false。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">undefined &#x3D;&#x3D; nll    &#x2F;&#x2F; true</span><br><span class="line">undefined &#x3D;&#x3D; 124    &#x2F;&#x2F; false</span><br><span class="line">undefined &#x3D;&#x3D; &#39;123&#39;  &#x2F;&#x2F; false</span><br><span class="line">undefined &#x3D;&#x3D; false  &#x2F;&#x2F; false</span><br><span class="line">undefined &#x3D;&#x3D; true   &#x2F;&#x2F; false</span><br><span class="line"></span><br><span class="line">null &#x3D;&#x3D; undefined   &#x2F;&#x2F; true</span><br><span class="line">null &#x3D;&#x3D; 124         &#x2F;&#x2F; false</span><br><span class="line">null &#x3D;&#x3D; &#39;124&#39;       &#x2F;&#x2F; false</span><br><span class="line">null &#x3D;&#x3D; false       &#x2F;&#x2F; false</span><br><span class="line">null &#x3D;&#x3D; true        &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>
</li>
<li><p>数组(或对象) 和字符串进行比较时，数组(或对象) 会转换成字符串再进行比较</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[] &#x3D;&#x3D; &#39;&#39;   &#x2F;&#x2F; true</span><br><span class="line">[0] &#x3D;&#x3D; &#39;&#39;  &#x2F;&#x2F; false</span><br><span class="line">[0] &#x3D;&#x3D; &#39;0&#39; &#x2F;&#x2F; true</span><br><span class="line"></span><br><span class="line">var obj &#x3D; &#123;a:0&#125;</span><br><span class="line">obj &#x3D;&#x3D; &#39;&#39;  &#x2F;&#x2F; false</span><br><span class="line">obj &#x3D;&#x3D; &#39;[object Object]&#39; &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h2 id="Undefined-和-Null"><a href="#Undefined-和-Null" class="headerlink" title="Undefined 和 Null"></a>Undefined 和 Null</h2><p>undefined 表示 “缺少值”，就是此处应该有一个值，但是还没有定义。<br>用法:</p>
<ul>
<li>变量被声明了，但没有赋值时，就等于 undefined。</li>
<li>调用函数时，应该提供的参数没有提供，该参数等于 undefined。</li>
<li>对象没有赋值的属性，该属性的值为 undefined。</li>
<li>函数没有返回值时，默认返回 undefined。<br>null 表示 “没有对象”，即该处不应该有值<br>用法</li>
<li>作为函数的参数，表示该函数的参数不是对象。</li>
<li>作为原型链的终点。</li>
</ul>
<h2 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h2><p>本质上是一种唯一标识符，可作为对象的唯一属性名，别就不会改写或覆盖你设置的属性值</p>
<ul>
<li>创建</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let id &#x3D; Symbol(&#39;id&#39;)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>特点</p>
<ul>
<li><p>唯一性，即使是用同一个变量生成的值也不相等。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let id1 &#x3D; Symbol(&#39;id&#39;)</span><br><span class="line">let id2 &#x3D; Symbol(&#39;id&#39;)</span><br><span class="line">id1 &#x3D;&#x3D; id2                &#x2F;&#x2F; false</span><br></pre></td></tr></table></figure>
</li>
<li><p>隐藏性 for in Object.keys() 不能访问</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let id &#x3D; Symbol(&#39;id&#39;)</span><br><span class="line">let obj &#x3D; &#123;</span><br><span class="line">  [id]:&#39;symbol&#39;</span><br><span class="line">&#125;;</span><br><span class="line">for(let option in obj)&#123;</span><br><span class="line">  console.log(obj[option])   &#x2F;&#x2F; 空</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>Symbol.for()，Symbol.keyFor()</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let name1 &#x3D; Symbol.for(&#39;name&#39;)  &#x2F;&#x2F; 检测到未创建后返回</span><br><span class="line">let name2 &#x3D; Symbol.for(&#39;name&#39;)  &#x2F;&#x2F; 检测到已创建后返回</span><br><span class="line">name1 &#x3D;&#x3D;&#x3D; name2</span><br><span class="line">&#x2F;&#x2F; 访问值</span><br><span class="line">Symbol.keyFor(&#39;name1&#39;)  &#x2F;&#x2F; name</span><br><span class="line">Symbol.keyFor(&#39;name2&#39;)  &#x2F;&#x2F; name</span><br></pre></td></tr></table></figure>

<h1 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h1><ul>
<li>引用数据类型也就是对象数据类型 object (Object，Array,Function, data )</li>
<li>JavaScript 的引用数据类型是保存在堆内存中的对象，不可以直接访问堆内存空间中的位置和操作堆内存空间，只能操作对象在栈内存中的对象。</li>
<li>引用数据类型在栈内存中实际上保存的是对象在堆内存中的引用地址，通过该地址可以快速的查找到保存在堆内存中的对象。</li>
</ul>
<h2 id="数组-Array"><a href="#数组-Array" class="headerlink" title="数组(Array)"></a>数组(Array)</h2><p>数组是一组数据的集合，在内存中是一段连续的内存空间。<br>数组定义时可以无需指定数组长度<br>存储数据时无需指定具体的数据类型，可以存储任意类型。</p>
<h2 id="创建-2"><a href="#创建-2" class="headerlink" title="创建"></a>创建</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let arr1 &#x3D; []</span><br><span class="line">let arr2 &#x3D; new Array()</span><br><span class="line">let arr3 &#x3D; new Array(3) &#x2F;&#x2F; [empty*3]   创建一个数组，长度为三，值都为空。</span><br></pre></td></tr></table></figure>

<h2 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h2><h3 id="length-属性"><a href="#length-属性" class="headerlink" title="length 属性"></a>length 属性</h3><ul>
<li>length 属性表示数组的长度，即其中元素的个数。</li>
<li>当 length 属性被设置得更大时，数组将增大，新的元素将被添加到数组的尾部，他们的值为空(empty)</li>
<li>当 length 设置的值小于数组的长度时，数组将被截断，其尾部的元素将丢失。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let arr &#x3D; [1,2,3,4]</span><br><span class="line">arr.length &#x2F;&#x2F; 4</span><br><span class="line">arr.length &#x3D; 6 &#x2F;&#x2F; [1,2,3,4,expty*2]</span><br><span class="line">arr.length &#x3D; 2 &#x2F;&#x2F; [1,2]</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="数组的方法"><a href="#数组的方法" class="headerlink" title="数组的方法"></a>数组的方法</h3><h4 id="改变数组自身内容的方法"><a href="#改变数组自身内容的方法" class="headerlink" title="改变数组自身内容的方法"></a>改变数组自身内容的方法</h4><p><code>push() 、 pop()、 unshift()、 shift()、 reserve()、 splice()、 sort()、 fill()</code></p>
<ul>
<li><p>push() 和 pop()<br>push() 将某些值加入到数组的最后一个位置，不限制添加的数量，添加多项内容使用逗号隔开。<br>pop() 会移除数组的最后一个元素。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let a &#x3D; [1,2,3,4,5]</span><br><span class="line">a.push(6)       &#x2F;&#x2F; [1,2,3,4,5,6]</span><br><span class="line">a.push(7,8,9)   &#x2F;&#x2F; [1,2,3,4,5,6,7,8,9]</span><br><span class="line">a.pop()         &#x2F;&#x2F; [1,2,3,4,5,6,7,8]</span><br></pre></td></tr></table></figure></li>
<li><p>unshift(),shift()<br>unshift() 会将指定的元素添加到数组的第一个位置。<br>shift() 会移除数组的第一个元素。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let arr &#x3D; [1,2,3,4,5]</span><br><span class="line">arr.unshift(6)      &#x2F;&#x2F; [6,1,2,3,4,5]</span><br><span class="line">arr.unshit(7,8,9)   &#x2F;&#x2F; [7,8,9,6,1,2,3,4,5]</span><br><span class="line">arr.shift()         &#x2F;&#x2F; [8,9,6,1,2,3,4,5]</span><br></pre></td></tr></table></figure>
</li>
<li><p>reverse()<br>将数组反转</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let a &#x3D; [1,2,3,4,5,6]</span><br><span class="line">a.reverse()   &#x2F;&#x2F; [6,5,4,3,2,1]</span><br></pre></td></tr></table></figure></li>
<li><p>splice()<br>该方法可以移除或新增数列的元素，包含三个参数，一个是要移除或要添加的序列号(必填)，第二个是要移除的长度(选填。若不填则从第一个参数位置开始，后面的元素都会被移除，设为 0 表示不会有元素删除，第三个是要替换的内容)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let arr &#x3D; [1,2,3,4,5,6,7]</span><br><span class="line">arr.splice(1,1) &#x2F;&#x2F; [1,3,4,5,6,7]</span><br><span class="line">arr.splice(3,1,100) &#x2F;&#x2F; [1,3,4,100.6,7]</span><br><span class="line">arr.splice(2,0,200) &#x2F;&#x2F; [1,3,200,4,100,6,7]</span><br></pre></td></tr></table></figure></li>
<li><p>sort()<br>该方法可以针对数组的元素进行排序，里头包含一个排序的判断函数，函数内必须包含的两个参数，两个参数分别代表数组里第 n 个和第 n+1 个元素，通过比较第 n 个和第 n+1 个元素的大小来进行排序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let a &#x3D; [3,2,4,5,1,6,7,8]</span><br><span class="line">a.sort((a,b)&#x3D;&gt;a-b)  &#x2F;&#x2F; [1,2,3,4,5,6,7,8]</span><br><span class="line">a.sort((a,b)&#x3D;&gt;b-a)  &#x2F;&#x2F; [8,7,6,5,4,3,2,1]</span><br></pre></td></tr></table></figure>
<p>若不使用判断函数，<code>默认会将元素换成字符串，并采用 unicode 来判断，这也会造成某些数字的排序错误</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let a &#x3D; [1,2,3,4,5,6,7,8,9,10,11,12]</span><br><span class="line">a.sort()  &#x2F;&#x2F; [1,10,11,12,2,3,4,5,6,7,8,9]</span><br></pre></td></tr></table></figure></li>
<li><p>fill()<br>该方法会把数组中所有元素，置换为指定的值，fill() 有三个参数，第一个是准备要置换的内容(必填)，第二个是从什么位置开始置换(选填，不设定就全部置换)，第三个是停止置换的元素的前一个位置(选填，默认等于数组长度)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let a &#x3D; [1,2,3,4,5,6,7,8,9]</span><br><span class="line">a.fill(&#39;a&#39;)  &#x2F;&#x2F; [&#39;a&#39;,&#39;a&#39;,&#39;a&#39;,&#39;a&#39;,&#39;a&#39;,&#39;a&#39;,&#39;a&#39;,&#39;a&#39;,&#39;a&#39;]</span><br><span class="line">let b &#x3D; [1,2,3,4,5]</span><br><span class="line">b.fill(&#39;b&#39;,2,3) &#x2F;&#x2F; [1,2,&#39;b&#39;,4,5]</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="获取数组属性或索引值"><a href="#获取数组属性或索引值" class="headerlink" title="获取数组属性或索引值"></a>获取数组属性或索引值</h3><p><code>length() 、indexOf() 、lastIndexOf() 、 find()、 findIndex() 、filter()</code></p>
<ul>
<li><p>length()<br>可以取得数组的长度。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let a &#x3D; [1,2,3,4,5,6]</span><br><span class="line">a.length() &#x2F;&#x2F; 6</span><br></pre></td></tr></table></figure></li>
<li><p>indexOf()、lastIndexOf()<br>indexOf()会判断数组中是否包含某个值(从左往右)，如果包含就返回这个值在数组中的索引值，若没有找到返回 -1 。有两个参数一个是要找的的值，另外一个是表示数组数组从哪个位置开始判断。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let a &#x3D; [1,2,3,4,5]</span><br><span class="line">a.indexOf(3)   &#x2F;&#x2F; 2</span><br><span class="line">a.indexOf(7)   &#x2F;&#x2F; -1</span><br><span class="line">a.indexOf(3,6) &#x2F;&#x2F; -1</span><br></pre></td></tr></table></figure>
<p>lastIndexOf()会判断数组中是否包含某个值(从右往左)，查找方式 indexOf()一样。</p>
</li>
<li><p>find()<br>find() 会将数组中的每一个元素带入指定的函数内做判断，并会返回一个符号判断条件的元素，若没有元素符合则会返回 undefined.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let a &#x3D; [1,2,3,4,5,6]</span><br><span class="line">a.find((e)&#x3D;&gt;e&gt;3)  &#x2F;&#x2F; 4</span><br><span class="line">a.find((e)&#x3D;&gt;e&lt;1)  &#x2F;&#x2F; undefined</span><br></pre></td></tr></table></figure></li>
<li><p>findIndex()<br>findIndex() 会将数组中的每一个元素带入指定的函数内做判断，并返回第一个符合条件元素的位置索引。</p>
</li>
<li><p>filter()<br>filter() 会将数组中的每一个元素带入指定的函数内部做判断，如果符合条件则会返回，组成一个新的数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let a &#x3D; [1,2,3,4,5,6,7]</span><br><span class="line">a.filter(e &#x3D;&gt; e&gt;3)  &#x2F;&#x2F; [4,5,6,7]</span><br><span class="line">a.filter(e &#x3D; &gt;e%2 &#x3D;&#x3D; 0)  &#x2F;&#x2F; [2,4,6]</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="针对每一项处理"><a href="#针对每一项处理" class="headerlink" title="针对每一项处理"></a>针对每一项处理</h3><ul>
<li>forEach()<br>该方法会将数组中每一个元素用指定的函数里进行运算，函数有三个参数，第一个参数表示每个元素的值(必填),第二个参数为该元素的索引值(选填)，第三个参数则表示原本的数组(选填)。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let a &#x3D; [1,2,3,4,5]</span><br><span class="line">a.forEach((item,index,arr)&#x3D;&gt;&#123;</span><br><span class="line">  arr[index] &#x3D; item*10</span><br><span class="line">&#125;)</span><br><span class="line">&#x2F;&#x2F; [10,20,30,40,50]</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="产生新的数组或新的值"><a href="#产生新的数组或新的值" class="headerlink" title="产生新的数组或新的值"></a>产生新的数组或新的值</h3><p><code>join() concat() slice() map() reduce() reduceRight() flat() flatMap() Array.from() Array.of() toString()</code></p>
<ul>
<li><p>join()<br>可以将数组中所有元素，变成由指定的字符串分割合并在一起组成字符串进行呈现，若没有指定字符默认会用逗号合并。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let a &#x3D; [1,2,3,4,5]</span><br><span class="line">a.join()  &#x2F;&#x2F; 1,2,3,4,5</span><br><span class="line">a.join(&#39;&#39;) &#x2F;&#x2F; 12345</span><br></pre></td></tr></table></figure>
</li>
<li><p>concat() 可以将两个数组合并在一起，可以使用扩展运算符 … 来代替。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let a &#x3D; [1,2,3,4,5]</span><br><span class="line">let b &#x3D; [6,7,8,9]</span><br><span class="line">let c &#x3D; a.concat(b)   &#x2F;&#x2F; [1,2,3,4,5,6,7,8,9]</span><br><span class="line">let d &#x3D; [...a,...b]   &#x2F;&#x2F; [1,2,3,4,5,6,7,8,9]</span><br></pre></td></tr></table></figure></li>
<li><p>slice()<br>可以截取出数组某部分的元素为一个新的数组，有两个必填的参数，一个是起始位置，一个是结束位置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let a &#x3D; [1,2,3,4,5,6]</span><br><span class="line">let b &#x3D; a.slice(2,4)  &#x2F;&#x2F; [3,4]</span><br></pre></td></tr></table></figure></li>
<li><p>map()<br>会处理数组中每一个元素，最后返回一个新的数组，里面是一个函数和一个返回函数里的 this 参数，函数包含三个参数，第一个是每一个元素的值(必填)，第二个是当前元素的索引值，第三个是当前的数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let a &#x3D; [1,2,3,4,5,6]</span><br><span class="line">let b &#x3D; a.map((e)&#x3D;&gt;&#123;</span><br><span class="line">  return e+2</span><br><span class="line">&#125;)</span><br><span class="line">&#x2F;&#x2F; [3,4,5,6,7,8]</span><br></pre></td></tr></table></figure></li>
<li><p>reduce()<br>可以将数组中每一个元素进行计算，每次计算的结果再与下一个元素计算，直到结束为止，里头包含一个函数(必填)和初始计算的数值(选填)，函数内有四个参数，第一个是计算的值(必填)，第二个是取得的元素(必填)，第三个是该元素的索引值(选填)，第四个是原本的数组(选填)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let a &#x3D; [1,2,3,4,5,6,7,8]</span><br><span class="line">let b &#x3D; a.reduce((total,e)&#x3D;&gt;&#123;</span><br><span class="line">  total + e</span><br><span class="line">&#125;)</span><br><span class="line">&#x2F;&#x2F; 36 (1+2+3+4+5+6+7+8)</span><br></pre></td></tr></table></figure>
</li>
<li><p>flat()<br>可以将一个多维数组的深度转换成一维(扁平化数组或成为降维)，有一个选填的参数代表要转换的深度数字，默认值为 1 ，如果是很多层可以使用 Infinity 来全部展开成一维数组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let a &#x3D; [1,[2],[3,4,[8,9]]]</span><br><span class="line">let b &#x3D; a.flat()   &#x2F;&#x2F; [1,2,3,4,[8,9]]</span><br><span class="line">let c &#x3D; a.flat(2)  &#x2F;&#x2F; [1,2,3,4,8,9]</span><br><span class="line">let d &#x3D; a.flat(Infinity) &#x2F;&#x2F; [1,2,3,4,8,9]</span><br></pre></td></tr></table></figure></li>
<li><p>Array.form()<br>会将类数组或是可迭代的对象转换成数组，有两个参数，第一个参数为类数组对象或可迭代的对象(必填)，第二个参数则是改变转换成数组元素的函数。<br>类数组对象具有 length 属性以及索引化 index 的元素，可迭代对象表示具有可以利用迭代的方式取得它自己本身的元素，如 Map 和 Set</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let a &#x3D; &#39;abcd&#39;</span><br><span class="line">Array.from(a) &#x2F;&#x2F; [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;]</span><br><span class="line">let obj &#x3D; &#123;</span><br><span class="line">  &#39;0&#39;:12,</span><br><span class="line">  &#39;2&#39;:11,</span><br><span class="line">  &#39;1&#39;:10,</span><br><span class="line">  length:3</span><br><span class="line">&#125;</span><br><span class="line">let objb &#x3D; Array.from(obj) &#x2F;&#x2F; [12,11.10]</span><br></pre></td></tr></table></figure></li>
<li><p>Array.of()<br>可以快速将数字、字符串等内容，转换成数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let a &#x3D; Array.of(1,&#39;q&#39;,3)</span><br><span class="line">a &#x2F;&#x2F; [1,&#39;q&#39;,3]</span><br></pre></td></tr></table></figure></li>
<li><p>toString()<br>会把整个数组转换成字符串</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let a &#x3D; [1,2,3,4]</span><br><span class="line">a.toString() &#x2F;&#x2F; &#39;1,2,3,4&#39;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="布尔判断"><a href="#布尔判断" class="headerlink" title="布尔判断"></a>布尔判断</h3><p><code>every() some() includes() Array.isArray()</code></p>
<ul>
<li><p>every()<br>会将数组中的每一个元素带入指定的函数内部进行判断，只要有一个元素不符合判断条件,会返回 false，如果全部符合，就会返回 true</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let a &#x3D; [1,2,3,4,5]</span><br><span class="line">a.every((e) &#x3D;&gt; e &gt; 3)   &#x2F;&#x2F; false</span><br><span class="line">a.every((e) &#x3D;&gt; e &gt; 0)   &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>
</li>
<li><p>some()<br>会将数组中的每一个函数放入指定的函数内部做判断，只要有任何一个符合判断条件，就会返回 true,如果全部不符合，才会返回 false。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let a &#x3D; [1,2,3,4]</span><br><span class="line">a.some((e) &#x3D;&gt; e &gt; 3)  &#x2F;&#x2F; true</span><br><span class="line">a.some((e) &#x3D;&gt; e &gt; 4)  &#x2F;&#x2F; false</span><br></pre></td></tr></table></figure>
</li>
<li><p>includes()<br>会判断数组中是否包含某个值，如果包含就返回 true 否则返回 false。有两个参数，第一个参数表示要判断的值，第二个参数是表示从数组的哪个位置开始判断。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let a &#x3D; [1,2,3,4,5,6]</span><br><span class="line">a.includes(2)     &#x2F;&#x2F; true</span><br><span class="line">a.includes(2,2)   &#x2F;&#x2F; false</span><br></pre></td></tr></table></figure>
</li>
<li><p>Array.isArray()<br>Array.isArray() 能判断一个元素是否为数组，如果是就返回 true,不然就返回 false。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let a &#x3D; [1,2,3]</span><br><span class="line">Array.isArray(a)  &#x2F;&#x2F; true</span><br><span class="line">Array.isArray(124) &#x2F;&#x2F; false</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p><code>valueOf() keys</code></p>
<ul>
<li><p>valueOf()<br>会返回数组的原始值，如果数组原本有修改，返回的原始值也会跟着改变(相当于浅复制)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let a &#x3D; [1,2,3,4,5]</span><br><span class="line">let b &#x3D; a.valueOf()   &#x2F;&#x2F; [1,2,3,4,5]</span><br><span class="line">let c &#x3D; a.valueOf()</span><br><span class="line">a.shift()</span><br><span class="line">b  &#x2F;&#x2F; [2,3,4,5]</span><br><span class="line">c  &#x2F;&#x2F; [2,3,4,5]</span><br></pre></td></tr></table></figure>
</li>
<li><p>keys<br>keys 会返回数组中的每一个索引值(key) 成一个新的 Array Iterator 对象，可以用 for of 进行迭代</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let a &#x3D; [1,2,3,4,5,6]</span><br><span class="line">let b &#x3D; a.keys()</span><br><span class="line">for(let key of b)&#123;</span><br><span class="line">  console.log(key)    &#x2F;&#x2F; 1,2,3,4,5,6</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="Oject"><a href="#Oject" class="headerlink" title="Oject"></a>Oject</h2><h3 id="创建-3"><a href="#创建-3" class="headerlink" title="创建"></a>创建</h3><ul>
<li><p>new 构造函数法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var person &#x3D; new Object()</span><br><span class="line">person.name &#x3D; &#39;张三&#39;;</span><br><span class="line">person.age &#x3D; 25</span><br></pre></td></tr></table></figure>
</li>
<li><p>对象字面量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var person &#x3D; &#123;</span><br><span class="line">  name:&#39;张三&#39;,</span><br><span class="line">  age: 25</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="属性和方法"><a href="#属性和方法" class="headerlink" title="属性和方法"></a>属性和方法</h3><ul>
<li><p>constructor<br>constructor 属性是保存当前对象的构造函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var obj1 &#x3D; new Object()</span><br><span class="line">obj1.id &#x3D; &#39;obj1&#39;</span><br><span class="line">var obj2 &#x3D; &#123;</span><br><span class="line">  id:&#39;obj2&#39;</span><br><span class="line">&#125;</span><br><span class="line">obj1.constructor &#x2F;&#x2F; function Object()&#123;&#125;</span><br><span class="line">obj2.constructor &#x2F;&#x2F; function Object()&#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>hasOwnProperty(‘属性名字’) 方法<br>该方法接收一个字符串参数(属性名)，用来判断该属性是否是当前对象实例中，而不是来自对象的原型链中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var obj &#x3D; &#123;</span><br><span class="line">  name:&#39;ddd&#39;</span><br><span class="line">&#125;</span><br><span class="line">obj.hasOwnProperty(&#39;name&#39;)      &#x2F;&#x2F; true</span><br><span class="line">obj.hasOwnProperty(&#39;toString&#39;)  &#x2F;&#x2F; false</span><br></pre></td></tr></table></figure>
</li>
<li><p>toLocaleString() 方法<br>该方法返回对象的字符串表示，和代码的执行环境有关。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var obj &#x3D; &#123;&#125;</span><br><span class="line">obj.toLocalString()    &#x2F;&#x2F; &#39;[object object]&#39;</span><br></pre></td></tr></table></figure></li>
<li><p>toString() 方法<br>返回对象的字符串表示</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var obj &#x3D; &#123;&#125;</span><br><span class="line">obj.toString()  &#x2F;&#x2F; &#39;[object object]&#39;</span><br></pre></td></tr></table></figure></li>
<li><p>valueOf() 方法<br>该方法返回对象的原始值。可能是字符串、数值或者布尔值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var obj &#x3D; &#123;</span><br><span class="line">  name:&#39;obj&#39;</span><br><span class="line">&#125;</span><br><span class="line">var arr &#x3D; [1]</span><br><span class="line">var bool &#x3D; new Boolean(1)</span><br><span class="line">var date &#x3D; new Date()</span><br><span class="line"></span><br><span class="line">obj.valueOf()     &#x2F;&#x2F; Object &#123;name:&#39;obj&#39;&#125;</span><br><span class="line">arr.valueOf()     &#x2F;&#x2F; [1]</span><br><span class="line">bool.valueOf()    &#x2F;&#x2F; true</span><br><span class="line">data.valueOf()    &#x2F;&#x2F; 145556666666</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="属性的类型"><a href="#属性的类型" class="headerlink" title="属性的类型"></a>属性的类型</h3><p>在 JavaScript 中，属性有两种类型，分别是数据属性和访问器属性</p>
<h4 id="数据属性"><a href="#数据属性" class="headerlink" title="数据属性"></a>数据属性</h4><p>数据属性可以理解为我们平时定义对象赋予的属性，可以进行读和写。但在 ES5 中定义了一些特性，这些特性用来描述属性的各种特征，特性是内部值，不能直接访问。需要通过 Object.defineProperty 方法来修改。</p>
<ul>
<li><p>[[Configurable]]<br>该特性表示是否可以通过 delete 操作符来删除属性，默认值为 true。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var obj &#x3D; &#123;</span><br><span class="line">  name:&#39;obj&#39;,</span><br><span class="line">  age:25</span><br><span class="line">&#125;</span><br><span class="line">obj.name         &#x2F;&#x2F; obj</span><br><span class="line">delete obj.name</span><br><span class="line">obj.name         &#x2F;&#x2F; undefined</span><br><span class="line">Object.defineProperty(obj,&#39;age&#39;,&#123;</span><br><span class="line">  configurable:false</span><br><span class="line">&#125;)</span><br><span class="line">obj.age          &#x2F;&#x2F; 25</span><br><span class="line">delete obj.age</span><br><span class="line">obj.age          &#x2F;&#x2F; 25</span><br></pre></td></tr></table></figure>

<p>通过 configurable 特性设置成 false 之后，delete 就无法删除 age 属性，如果是在严格模式下，使用 delete 去删除就会报错。</p>
</li>
<li><p>[[Enumerable]]<br>表示是否能够通过 for in 语句来枚举出属性。默认是 true</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var obj &#x3D; &#123;</span><br><span class="line">  name:&#39;objName&#39;</span><br><span class="line">&#125;</span><br><span class="line">for( var key in obj)&#123;</span><br><span class="line">  console.log(key)      &#x2F;&#x2F; name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Object.defineProperty(obj,&#39;constructor&#39;,&#123;</span><br><span class="line">  enumerable:true</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">for ( var key in obj)&#123;</span><br><span class="line">  console.log(key)       &#x2F;&#x2F; name constructor</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>[[Writable]] 和 [[Value]]<br>Writable：表示属性值是否可以修改，默认为 true，若设为 false，修改属性值的时候没有效果，在严格模式下会报错。<br>Value：表示属性的值，默认为 undefined</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var obj &#x3D; &#123;</span><br><span class="line">  name:&#39;name&#39;</span><br><span class="line">&#125;</span><br><span class="line">obj.name &#x2F;&#x2F; name</span><br><span class="line">Object.defineProperty(obj,&#39;name&#39;,&#123;</span><br><span class="line">  value:&#39;newVlaue&#39;,</span><br><span class="line">  writable:false</span><br><span class="line">&#125;)</span><br><span class="line">obj.name  &#x2F;&#x2F; newValue</span><br><span class="line">obj.name &#x3D; &#39;oldValue&#39;</span><br><span class="line">obj.name &#x2F;&#x2F; newValue</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="访问器属性"><a href="#访问器属性" class="headerlink" title="访问器属性"></a>访问器属性</h4><p>[[get]] 读取属性时调用的函数,[[set]] 给属性设置值的时候调用的函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var person &#x3D; &#123;</span><br><span class="line">  age:15</span><br><span class="line">&#125;</span><br><span class="line">Object.defineProperty(person,&#39;type&#39;,&#123;</span><br><span class="line">  get:function()&#123;</span><br><span class="line">    if(person.age&gt;17)&#123;</span><br><span class="line">      return &#39;成人&#39;</span><br><span class="line">    &#125;</span><br><span class="line">    return &#39;小孩&#39;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">person.type &#x2F;&#x2F; 小孩</span><br><span class="line">person.age &#x3D; 20</span><br><span class="line">person.type &#x2F;&#x2F; 成人</span><br></pre></td></tr></table></figure>

<h2 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h2><p>函数的本身就是对象。函数是第一类对象。<br>第一类对象又称第一类公民。具有的的特性</p>
<ul>
<li>能够作为参数被传递。</li>
<li>能够从一个函数结果中返回。</li>
<li>能够被修改和赋值给变量。<br><code>在js 里函数也是对象，可以拥有自己的属性和方法，而它和一般js对象的区别是：可以被调用，即可以执行。</code></li>
</ul>
<h3 id="创建-4"><a href="#创建-4" class="headerlink" title="创建"></a>创建</h3><p>函数创建方法:<code>函数定义表达式、函数声明语句和 new Function()</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 函数声明</span><br><span class="line">function fun() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 函数表达式</span><br><span class="line">var  fun &#x3D; function() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; new Function</span><br><span class="line">var  fun1 &#x3D; new Function()</span><br></pre></td></tr></table></figure>

<ul>
<li><p>变量提升<br>JavaScript 中由 var 关键字声明的变量存在变量提升：将变量声明提升到作用域的顶部，但赋值仍保留在原处。函数表达式和函数声明有本质的区别。</p>
<ul>
<li>函数声明语句<br>将函数声明和函数的赋值都提升到作用域的顶部，在同一个作用域中可以出现调用在函数之前。</li>
<li>函数表达式<br>与 var 声明的普通变量相同，只是将变量声明提升到作用域顶部，但赋值仍然留在原处，不能在定义前使用</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">fun()                       &#x2F;&#x2F; 函数声明</span><br><span class="line">fun1()                      &#x2F;&#x2F; undefined</span><br><span class="line">function fun() &#123;</span><br><span class="line">  var name &#x3D; &#39;函数声明&#39;</span><br><span class="line">  console.log(name)</span><br><span class="line">&#125;</span><br><span class="line">var fun1 &#x3D; function() &#123;</span><br><span class="line">  var name &#x3D; &#39;函数表达式&#39;</span><br><span class="line">  console.log(name)</span><br><span class="line">&#125;</span><br><span class="line">fun()                     &#x2F;&#x2F; 函数声明</span><br><span class="line">fun1()                    &#x2F;&#x2F; 函数表达式</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="函数的调用"><a href="#函数的调用" class="headerlink" title="函数的调用"></a>函数的调用</h3><p>在定义函数时，函数体中的代码不会执行，只有在调用函数时，才会执行函数体中的语句。函数的调用方式有四种</p>
<h4 id="作为普通函数"><a href="#作为普通函数" class="headerlink" title="作为普通函数"></a>作为普通函数</h4><p>使用调用表达式来调用普通函数，每个调用表达式由多个函数表达式组成。每个函数表达式包括函数对象、括号和传入的实参组成。</p>
<ul>
<li><p>每次调用会拥有本次调用的上下文 this；在 ES5 非严格模式下，普通函数的 this 值是全局对象；在严格模式下是 undefined</p>
</li>
<li><p>以函数形式调用的函数通常不使用 this 关键字</p>
</li>
<li><p>如果函数没有显式 return 语句返回一个值，默认返回 undefined</p>
</li>
<li><p>传入的实参是由逗号分隔的 0 个或多个函数表达式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function printPrps(o) &#123;</span><br><span class="line">  for(var prop in o) &#123;</span><br><span class="line">    console.log(prop + &quot;: &quot; + o[prop] + &quot;\n&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(this)   &#x2F;&#x2F; window</span><br><span class="line">&#125;</span><br><span class="line">printPrps(&#123;x:1&#125;)      &#x2F;&#x2F; x:1</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="作为对象的方法"><a href="#作为对象的方法" class="headerlink" title="作为对象的方法"></a>作为对象的方法</h4><p>方法是保存在 JavaScript 对象中的函数</p>
<ul>
<li>对方法调用的参数和返回值处理与函数调用相同</li>
<li>方法调用由两部分组成：<code>对象.属性名()</code>，其中属性名是值为函数的属性</li>
<li>方法调用中：调用上下文指调用方法的对象，使用 this 关键字引用<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var obj &#x3D;&#123;</span><br><span class="line">  num1: 12,</span><br><span class="line">  num2: 11,</span><br><span class="line">  add: function() &#123;</span><br><span class="line">    this.result &#x3D; this.num1 + this.num2</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.add()   &#x2F;&#x2F; 调用 add 方法</span><br><span class="line">obj.result  &#x2F;&#x2F; 23</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="作为构造器函数"><a href="#作为构造器函数" class="headerlink" title="作为构造器函数"></a>作为构造器函数</h4><p>函数或者方法调用前有关键字 new，函数或者方法便作为构造函数来调用。构造函数会创建一个新对象，新对象继承构造函数的 prototype 属性。<br>作为构造函数的调用，会将新创建的对象作为其调用上下文(this 指向新创建的对象)，在构造函数中使用 this 引用新创建的对象。</p>
<h4 id="使用函数的-call-和-apply-方法间接调用"><a href="#使用函数的-call-和-apply-方法间接调用" class="headerlink" title="使用函数的 call() 和 apply() 方法间接调用"></a>使用函数的 call() 和 apply() 方法间接调用</h4><p>函数是对象，每个函数都有 call() 和 apply() 两个方法，作用是改变函数运行时的上下文–改变函数体内部 this 的指向。<br>call()和 apply()作用都是动态改变函数体内 this 指向。只是接受参数形式不太一样。<br>call() 需要将参数按顺序传递进函数，并且知道参数的数量。<br>apply() 将参数放在数组中传进函数。(参数数量不确定时使用)</p>
<h3 id="函数的实参和形参"><a href="#函数的实参和形参" class="headerlink" title="函数的实参和形参"></a>函数的实参和形参</h3><p>实参和形参是相对的概念，在函数定义时指定的参数叫做形参；在函数调用时传入的参数叫做实参。对于需要省略的实参，可以使用 null 或 undefined 作为占位符。</p>
<h4 id="参数对象"><a href="#参数对象" class="headerlink" title="参数对象"></a>参数对象</h4><p>函数体内，标识符 argument 指向实参对象的引用，实参对象是一个类数组对象，可以通过下标访问每个传入的参数。</p>
<ul>
<li>callee 和 caller 属性。<br>callee 是 ECMAScript 规范中 arguments 对象的属性：代表当前正在执行的函数。<br>caller 是非标准的，只是浏览器基本实现了这个属性：代表调用当前函数的函数。<br>在严格模式中，对这个两个属性读写都会产生错误。</li>
</ul>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>闭包在 JavaScript 中，指内部函数总是可以访问其所在的外部函数中声明的变量和参数，即是外部函数被返回(调用结束)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var scope &#x3D; &#39;global scope&#39;</span><br><span class="line">function checkScope() &#123;</span><br><span class="line">  var scope &#x3D; &#39;local scope&#39;</span><br><span class="line">  function f() &#123; return scope&#125;</span><br><span class="line">  return f</span><br><span class="line">&#125;</span><br><span class="line">checkScope()()</span><br></pre></td></tr></table></figure>

<ul>
<li>在 Js 中，每个函数在定义时会创建一个与之相关的作用域链，并且在程序执行期间一直存在<br>外部函数有自身的作用域链，内部函数有自身单独的作用域链。</li>
<li>每次调用函数都会创建一个新对象来保存参数和局部变量，并将其添加到作用域链。<ul>
<li>当函数返回时，将绑定的新对象从作用域链上删除。如果没有其他变量引用该对象、或该对象没有保存在某个对象的属性中，它会被当做垃圾回收。</li>
<li>如果没有外部变量引用，调用函数时创建的临时对象，函数 return 后便被垃圾回收。</li>
</ul>
</li>
<li>如果 checkScope 定义有嵌套函数 f,并将 f 作为返回值保存在某个对象的属性中。相当于有一个外部引用指向嵌套函数。</li>
</ul>
<p>JavaScript 中的函数，通过作用域和词法作用域两者的特性，将该函数定义时所处的作用域中的相关函数进行补货和保存，从而可以在完全不同的上下文中进行引用。</p>
<h2 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h2><h3 id="时区"><a href="#时区" class="headerlink" title="时区"></a>时区</h3><pre><code>javaScript 中，我们只关心两个，本地时间和协调世界时(UTC)
  - 本地时间 是指自己计算机所在的时区
  - UTC 实际上是格林威治时间</code></pre><h3 id="创建-5"><a href="#创建-5" class="headerlink" title="创建"></a>创建</h3><pre><code>`new Date()` 来创建日期，传入的参数通常有四种
- 使用日期字符串参数
- 使用一系列的参数
  可以传入七个参数来创建日期和时间
  - Year: 四位数年份
  - Month: 一年中的某一个月(0-11)
  - Day: 每月的某一天(1-31)，如果省略，则默认为 1
  - Hour: 一天中的小时(0-23)，如果省略，则默认为 0
  - Minutes: 分钟(0-59)，如果省略，则默认为0
  - Seconds: 秒(0-59)，默认为0 
  - Milliseconds: 毫秒(0-999)，默认为零。
- 时间戳参数
  时间戳是自 1970年1月1日以来经过的毫秒数
- 不带参数
  会将日期设置为当前时间</code></pre>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 使用日期字符串参数</span><br><span class="line">  new Date(&#39;2021-10-21&#39;)</span><br><span class="line">  </span><br><span class="line">&#x2F;&#x2F; 使用一系列参数来创建</span><br><span class="line">  </span><br><span class="line">  new Date(2020,1,23,5,30,39)</span><br></pre></td></tr></table></figure>
<h3 id="日期提供的方法"><a href="#日期提供的方法" class="headerlink" title="日期提供的方法"></a>日期提供的方法</h3><ul>
<li><p>编写自定义日期格式化<br>Date 中获取 年月日时分秒的方法</p>
<ul>
<li>getFullYear: 获取当地时间四位数的年份</li>
<li>getMonth: 获取月份，月份从零开始</li>
<li>getDate: 获取月中的某一天(1-31)</li>
<li>getDay: 获取星期几(0-6)，星期日(0)开始，到星期六(6)结束。</li>
<li>getHours: 获取小时数(0-23)</li>
<li>getMinutes: 获取分钟数(0-59)</li>
<li>getSeconds: 获取秒数(0-59)</li>
<li>getMilliseconds: 获取毫秒数(0-999)</li>
</ul>
<p>Date 设置另一个日期特定的日期/时间值</p>
<ul>
<li>setFullYear: 设置年份</li>
<li>setMonth: 设置月份</li>
<li>setDate: 设置每月中的某一天</li>
<li>setHours: 设置时</li>
<li>setMinutes: 设置分</li>
<li>setSeconds: 设置秒</li>
<li>setMilliseconds: 设置毫秒<h4 id="日期添加-减去增量"><a href="#日期添加-减去增量" class="headerlink" title="日期添加/减去增量"></a>日期添加/减去增量</h4></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">当前日期 2019年3月28日，获取三天后的日期</span><br><span class="line"></span><br><span class="line">let today &#x3D; new Date(2019,2,28)</span><br><span class="line">let finalDate &#x3D; new Date(today)</span><br><span class="line">finalDate.setDate(today.getDate()+3)</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h1 id="引用类型与原始类型的区别"><a href="#引用类型与原始类型的区别" class="headerlink" title="引用类型与原始类型的区别"></a>引用类型与原始类型的区别</h1><h3 id="声明变量时不同的内存分配"><a href="#声明变量时不同的内存分配" class="headerlink" title="声明变量时不同的内存分配"></a>声明变量时不同的内存分配</h3><ul>
<li>原始值：存储在栈内存(stack) 中的简单数据段，即他们的值直接存储在变量访问的位置。</li>
<li>引用值：存储在堆内存中，栈内存中存储的是该对象的指针，指向存储对象的内存地址<br>为什么引用类型的值不能放在栈中，引用类型的值大小会发生改变，放在栈内存中会降低变量查询的速度。</li>
</ul>
<h3 id="访问机制"><a href="#访问机制" class="headerlink" title="访问机制"></a>访问机制</h3><ul>
<li>原始类型，值是可以直接访问</li>
<li>引用类型，访问一个对象时，首先得到的是这个对象在内存中的地址，然后再按照这个地址去获得这个对象中的值，即<code>按应用访问</code></li>
</ul>
<h3 id="复制变量"><a href="#复制变量" class="headerlink" title="复制变量"></a>复制变量</h3><ul>
<li>原始类型：将保存原始值的变量复制给另一个变量时，会将原始值的副本赋值给新变量，此后这两个变量是完全独立的。</li>
<li>引用类型：是将内存地址赋值给新变量，即这两个变量都指向同一个堆内存中的同一个对象，任何一个改变都会反映在另一个身上。</li>
</ul>
<h3 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h3><p>ECMAScript 中所有的函数的参数都是<code>按值传递</code>。<br>但是涉及到原始和引用类型的值时是有差异的，因为内存分配时的差异。</p>
<ul>
<li>原始值：把变量的值传递给参数，之后参数和这个变量互不影响。</li>
<li>引用值：传递的值是内存地址，所以在函数内部对参数修改会体现在外部，因为他们指向的是同一个对象。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2021/04/22/js%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/%E6%95%B0%E6%8D%AE/" data-id="cl139u3l90024swdxban98ai6" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-jsType" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/04/22/jsType/" class="article-date">
  <time datetime="2021-04-22T07:51:22.461Z" itemprop="datePublished">2021-04-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/04/22/jsType/">js 数据类型</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>ECMAScript 变量有两种不同的数据类型: 基本类型，引用类型。</p>
<h2 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h2><p>数据类型有 <code>undefined 、Boolean 、Number 、String 、null</code></p>
<h3 id="基本数据类型的特点"><a href="#基本数据类型的特点" class="headerlink" title="基本数据类型的特点"></a>基本数据类型的特点</h3><p>基本数据类型是按值传递，存储在栈区的数据，无法添加属性，删除属性，直接赋值给另一个变量，两个变量互不影响，修改其中任意一个变量的值，另外一个的值不发生变化。</p>
<ul>
<li>、值是不可变的</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let a &#x3D; &#39;abc&#39;</span><br><span class="line">let b &#x3D; a</span><br><span class="line">b &#x3D; &#39;456&#39;</span><br><span class="line">console.log(a) &#x2F;&#x2F; abc</span><br><span class="line">console.log(b) &#x2F;&#x2F; 456</span><br></pre></td></tr></table></figure>

<ul>
<li>、基本类型的比较是值的比较</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let num &#x3D; 1</span><br><span class="line">let boolean &#x3D; true</span><br><span class="line"></span><br><span class="line">num &#x3D;&#x3D; boolean  &#x2F;&#x2F; true</span><br><span class="line"> &#x2F;&#x2F; &#x3D;&#x3D;  比较会进行隐式类型转换   true 转换成 1  false 转换成 0</span><br></pre></td></tr></table></figure>

<ul>
<li>、 基本类型的变量是存放在栈内存</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let name &#x3D; &#39;张三&#39;</span><br><span class="line">let age &#x3D; &#39;12&#39;</span><br></pre></td></tr></table></figure>

<h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><p>引用类型有：<code>Object 、Array</code></p>
<h3 id="引用数据类型的特点"><a href="#引用数据类型的特点" class="headerlink" title="引用数据类型的特点"></a>引用数据类型的特点</h3><p>引用数据类型的赋值，是按引用传递，复制的是指针。是浅拷贝。</p>
<ul>
<li>引用类型的值是可变的</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">let obj &#x3D; &#123;&#125;</span><br><span class="line">obj.name &#x3D; &#39;张三&#39;</span><br><span class="line">obj.age &#x3D; &#39;12&#39;</span><br><span class="line">function fun(o)&#123;</span><br><span class="line">  let newObj &#x3D; o</span><br><span class="line">  newObj.name&#x3D;&#39;李四&#39;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">console.log(obj.name)   &#x2F;&#x2F; 张三</span><br><span class="line">fun(obj)</span><br><span class="line">console.log(obj.name)  &#x2F;&#x2F; 李四</span><br></pre></td></tr></table></figure>

<ul>
<li><p>引用类型的值是同时保存在栈内存和堆内存中的对象</p>
<p>javaScript 不允许直接访问内存中的位置，也就是不能直接操作对象的内存空间，实际上是操作对象的引用。引用类型的存储需要堆内存，和栈内存，栈内存保存变量标识符和指向堆内存中该对象的指针。</p>
</li>
<li><p>引用类型的比较是引用的比较</p>
</li>
</ul>
<p>两个对象的比较是比较两个对象的堆内存中的地址是否相同。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let person1 &#x3D; &#123;&#125;</span><br><span class="line">let person2 &#x3D; &#123;&#125;</span><br><span class="line">console.log(person1 &#x3D;&#x3D; person2 )  &#x2F;&#x2F; false</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2021/04/22/jsType/" data-id="cl139u3f40005swdx7egwh2ow" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-git命令" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/04/22/git%E5%91%BD%E4%BB%A4/" class="article-date">
  <time datetime="2021-04-22T07:51:22.460Z" itemprop="datePublished">2021-04-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/04/22/git%E5%91%BD%E4%BB%A4/">git 命令</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="专有名词"><a href="#专有名词" class="headerlink" title="专有名词"></a>专有名词</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Workspance: 工作区</span><br><span class="line">Index &#x2F; Stage: 暂存区</span><br><span class="line">Repository: 仓库区(本地仓库)</span><br><span class="line">Remote: 远程仓库</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/18087435-2b52aaf65be47442.jpg" alt="git专有名词"></p>
<h2 id="创建本地代码库"><a href="#创建本地代码库" class="headerlink" title="创建本地代码库"></a>创建本地代码库</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 初始化一个git 代码库</span><br><span class="line"></span><br><span class="line">git init</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 新建一个目录，将其初始化为Git代码库。</span><br><span class="line"></span><br><span class="line">git init [project-name]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 下载一个项目到本地</span><br><span class="line"></span><br><span class="line">git clone</span><br></pre></td></tr></table></figure>

<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>git 的设置文件为.gitconfig,它可以在用户主目录下(全局配置)，也可以在项目目录下(项目配置)。</p>
<p>可以配置忽略文件，</p>
<h2 id="增加-删除文件"><a href="#增加-删除文件" class="headerlink" title="增加/删除文件"></a>增加/删除文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 添加指定文件到暂存区</span><br><span class="line">git add [file1] ...</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 添加指定目录到暂存区</span><br><span class="line">git add 文件夹名</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 添加当前目录的所有文件到暂存区</span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 删除工作区文件夹，并且将这次删除放入暂存区</span><br><span class="line">git rm 文件名</span><br></pre></td></tr></table></figure>

<h2 id="代码提交"><a href="#代码提交" class="headerlink" title="代码提交"></a>代码提交</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 提交暂存区到仓库区</span><br><span class="line">git commit -m &#39;填写提交的信息&#39;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 提交指定的文件到仓库区</span><br><span class="line">git commit 文件名 -m &#39;填写提交的信息&#39;</span><br></pre></td></tr></table></figure>

<h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 列出所有的本地分支</span><br><span class="line">git branch</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 列出所有远程分支</span><br><span class="line">git branch -r</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 列出所有本地分支和远程分支</span><br><span class="line">git branch -a</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 新建一个分支，但依然停留在当前分支</span><br><span class="line">git branch  分支名</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 新建一个分支，并切换到该分支</span><br><span class="line">git checkout -b 分支名</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 切换到指定的分支，并更新工作区</span><br><span class="line">git checkout 要切换的分支名</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 合并分支到当前分支</span><br><span class="line">git merge 要合并的分支名</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 删除分支</span><br><span class="line">git branch -d 要删除的分支名</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 删除远程分支名</span><br><span class="line">git branch -dr 要删除的远程分支名</span><br></pre></td></tr></table></figure>

<h2 id="查看信息"><a href="#查看信息" class="headerlink" title="查看信息"></a>查看信息</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 显示所有变更的文件</span><br><span class="line">git status</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 显示当前分支的版本历史</span><br><span class="line">git log</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 显示 commit 历史，以及每次commit发生变更的文件</span><br><span class="line">git log --stat</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 显示暂存区和工作区的代码差异</span><br><span class="line">git diff</span><br></pre></td></tr></table></figure>

<h2 id="远程同步"><a href="#远程同步" class="headerlink" title="远程同步"></a>远程同步</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 更新远程仓库</span><br><span class="line">git remote update</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 下载远程仓库的所有变动</span><br><span class="line">git fetch</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 显示所有远程仓库</span><br><span class="line">git remote -v</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 取回远程仓库的变化，并于本地分支合并</span><br><span class="line">git pull 远程仓库名 远程仓库的分支名</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 上传本地指定分支到远程仓库</span><br><span class="line">git push 远程仓库名 远程仓库的分支名</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 强行推送当前分支到远程仓库，即使有冲突</span><br><span class="line">git push 远程仓库名 -- force</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 推送所有分支到远程仓库</span><br><span class="line">git push 远程仓库名 --all</span><br></pre></td></tr></table></figure>

<h2 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;  恢复暂存区的指定文件到工作区</span><br><span class="line">git checkout [file]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 恢复某个commit的指定文件到暂存区和工作区</span><br><span class="line">git checkout [commit] [file]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 恢复暂存区的所有文件到工作区</span><br><span class="line">git checkout .</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</span><br><span class="line">git reset [file]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 重置暂存区与工作区，与上一次commit保持一致</span><br><span class="line">git reset --hard</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</span><br><span class="line">git reset [commit]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致</span><br><span class="line">git reset --hard [commit]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 重置当前HEAD为指定commit，但保持暂存区和工作区不变</span><br><span class="line">git reset --keep [commit]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 新建一个commit，用来撤销指定commit</span><br><span class="line">&#x2F;&#x2F; 后者的所有变化都将被前者抵消，并且应用到当前分支</span><br><span class="line">git revert [commit]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 暂时将未提交的变化移除，稍后再移入</span><br><span class="line">git stash</span><br><span class="line">git stash pop</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2021/04/22/git%E5%91%BD%E4%BB%A4/" data-id="cl139u3er0003swdx3qcsdof4" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Promise" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/04/22/Promise/" class="article-date">
  <time datetime="2021-04-22T07:51:22.459Z" itemprop="datePublished">2021-04-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/04/22/Promise/">Promise</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Promise-是什么"><a href="#Promise-是什么" class="headerlink" title="Promise 是什么"></a>Promise 是什么</h2><ul>
<li>Promise 是进行异步编程的新的解决方案;</li>
<li>从语法上来讲: Promise 是一个构造函数;</li>
<li>从功能上来讲: Promise 对象用来封装一个异步操作并获取结果;</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2021/04/22/Promise/" data-id="cl139u3eg0001swdx5ifoe9d2" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/4/">&amp;laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/JavaScript-%E9%AB%98%E7%BA%A7/">JavaScript 高级</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/TypeScript/">TypeScript</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Vue-js/">Vue.js</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Vue-js/Props%E4%B8%8EData%E7%9A%84%E5%8C%BA%E5%88%AB/">Props与Data的区别</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Vue-js-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/">Vue.js 源码解读</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Vue-js-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E5%8F%98%E5%8C%96%E4%BE%A6%E6%B5%8B/">变化侦测</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Vue-js-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E5%8F%98%E5%8C%96%E4%BE%A6%E6%B5%8B/%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8F%98%E5%8C%96%E4%BE%A6%E5%90%AC/">数据的变化侦听</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Vue-js-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E5%90%8D%E8%AF%8D/">名词</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Vue-js-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E6%A8%A1%E6%9D%BF%E7%BC%96%E8%AF%91/">模板编译</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Vue-js-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/">生命周期</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Vue-js-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/%E5%88%9D%E5%A7%8B%E5%8C%96-initState-%E9%98%B6%E6%AE%B5/">初始化 initState 阶段</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Vue-js-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E8%99%9A%E6%8B%9FDOM/">虚拟DOM</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Vue-js-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E8%99%9A%E6%8B%9FDOM/Diff/">Diff</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Vue-js-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E8%99%9A%E6%8B%9FDOM/Vue%E4%B8%AD%E7%9A%84%E8%99%9A%E6%8B%9FDom/">Vue中的虚拟Dom</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Vue-js-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E8%99%9A%E6%8B%9FDOM/%E6%9B%B4%E6%96%B0%E5%AD%90%E8%8A%82%E7%82%B9/">更新子节点</a></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/async-await/">async await</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/elementUI%E5%A5%87%E6%80%AA%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/">elementUI奇怪问题解决办法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/element%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/">element使用不常用方法总结</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/es6/">es6</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/es6/Symbol/">Symbol</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/es6/%E8%BF%90%E7%AE%97%E7%AC%A6%E6%89%A9%E5%B1%95/">运算符扩展</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/import-%E5%92%8C-export/">import 和 export</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/js%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/">js知识体系</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/js%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/js-%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/">js 代码执行过程分析</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/js%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/js-%E8%AF%AD%E8%A8%80%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7/">js 语言的三大特性</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/js%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/%E4%BA%8B%E4%BB%B6/">事件</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/js%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/%E6%95%B0%E6%8D%AE/">数据</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/webpack/">webpack</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/">正则表达式</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/%E6%AD%A3%E5%88%99%E7%9F%A5%E8%AF%86%E7%82%B9/">正则知识点</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E6%B6%89%E5%8F%8A%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9/">浏览器渲染涉及的知识点</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%99%BB%E5%BD%95%E8%AE%A4%E8%AF%81%E7%9F%A5%E8%AF%86/">登录认证知识</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9D%A2%E8%AF%95/vue%E7%9F%A5%E8%AF%86%E7%82%B9/">vue知识点</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9D%A2%E8%AF%95/vue%E7%9F%A5%E8%AF%86%E7%82%B9/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9F%A5%E8%AF%86/">生命周期知识</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9D%A2%E8%AF%95/vue%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%8CSPA%E5%8D%95%E9%A1%B5%E9%9D%A2/">vue知识点，SPA单页面</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9D%A2%E8%AF%95/vue%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%8C%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86-MVVM/">vue知识点，双向数据绑定原理& MVVM</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9D%A2%E8%AF%95/vue%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%8C%E8%B7%AF%E7%94%B1%E6%A8%A1%E5%BC%8F%E5%8E%9F%E7%90%86/">vue知识点，路由模式原理</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9D%A2%E8%AF%95/%E4%BB%8EURL%E8%BE%93%E5%85%A5%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%8E%B0%E6%B6%89%E5%8F%8A%E7%9A%84%E7%9F%A5%E8%AF%86%E3%80%82/">从URL输入到页面展现涉及的知识。</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9D%A2%E8%AF%95/%E4%BD%9C%E7%94%A8%E5%9F%9F-%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/">作用域-作用域链</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9D%A2%E8%AF%95/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/">浏览器缓存</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84js%E6%93%8D%E4%BD%9C/">项目中常用的js操作</a></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">March 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">February 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/12/">December 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/11/">November 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/10/">October 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/09/">September 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">August 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">July 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">June 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">May 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/03/14/TypeScript/ts/">TypeScript</a>
          </li>
        
          <li>
            <a href="/2022/02/22/webpack/webpack/">webpack</a>
          </li>
        
          <li>
            <a href="/2021/12/25/%E6%AD%A3%E5%88%99/%E6%AD%A3%E5%88%99%E7%9F%A5%E8%AF%86%E7%82%B9/">正则知识点,</a>
          </li>
        
          <li>
            <a href="/2021/11/26/es6/Symbol/">Symbol,</a>
          </li>
        
          <li>
            <a href="/2021/11/25/es6/%E6%96%B0%E5%A2%9E%E8%BF%90%E7%AE%97%E7%AC%A6/">运算符的扩展,</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2022 sxhMxd<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>