<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>有理想的笛子</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="有理想的笛子">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="有理想的笛子">
<meta property="og:locale" content="zh">
<meta property="article:author" content="sxhMxd">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="有理想的笛子" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">有理想的笛子</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-项目遇到的奇怪问题/elementUI奇怪问题解决办法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/04/22/%E9%A1%B9%E7%9B%AE%E9%81%87%E5%88%B0%E7%9A%84%E5%A5%87%E6%80%AA%E9%97%AE%E9%A2%98/elementUI%E5%A5%87%E6%80%AA%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/" class="article-date">
  <time datetime="2021-04-22T07:52:09.127Z" itemprop="datePublished">2021-04-22</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/elementUI%E5%A5%87%E6%80%AA%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/">elementUI奇怪问题解决办法</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/04/22/%E9%A1%B9%E7%9B%AE%E9%81%87%E5%88%B0%E7%9A%84%E5%A5%87%E6%80%AA%E9%97%AE%E9%A2%98/elementUI%E5%A5%87%E6%80%AA%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/">elementUI奇怪问题解决办法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="el-tabs-切换窗口或者重新编译会有蓝色阴影"><a href="#el-tabs-切换窗口或者重新编译会有蓝色阴影" class="headerlink" title="el-tabs 切换窗口或者重新编译会有蓝色阴影"></a>el-tabs 切换窗口或者重新编译会有蓝色阴影</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 需要在全局添加以下样式</span><br><span class="line">.el-tabs__item:focus.is-active.is-focus:not(:active) &#123;</span><br><span class="line">    -webkit-box-shadow: none !important;</span><br><span class="line">    box-shadow: none !important;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2021/04/22/%E9%A1%B9%E7%9B%AE%E9%81%87%E5%88%B0%E7%9A%84%E5%A5%87%E6%80%AA%E9%97%AE%E9%A2%98/elementUI%E5%A5%87%E6%80%AA%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/" data-id="cl139u3m4002nswdxhcuz7j19" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-面试/浏览器缓存" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/04/22/%E9%9D%A2%E8%AF%95/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/" class="article-date">
  <time datetime="2021-04-22T07:51:22.477Z" itemprop="datePublished">2021-04-22</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a>►<a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/">浏览器缓存</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/04/22/%E9%9D%A2%E8%AF%95/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/">浏览器缓存</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="浏览器缓存机制"><a href="#浏览器缓存机制" class="headerlink" title="浏览器缓存机制"></a>浏览器缓存机制</h1><h2 id="为什么要使用缓存"><a href="#为什么要使用缓存" class="headerlink" title="为什么要使用缓存"></a>为什么要使用缓存</h2><p>缓存是性能优化中简单高效的一种优化方式。一个优秀的缓存策略可以缩短网页请求资源的距离，减少延迟，并且由于缓存文件可以重复利用，还可以减少带宽，降低网络负载。</p>
<p>对于一个数据请求来说，可以分为发起网络请求、后端处理、浏览器响应三个步骤。浏览器缓存可以帮我们在发起网络请求和浏览器响应优化性能。例如 直接使用缓存而不发起请求，或者发起请求但后端存储的数据和前端一致，那就没有必要将数据回传回来，这样就减少了响应数据。</p>
<h2 id="缓存位置"><a href="#缓存位置" class="headerlink" title="缓存位置"></a>缓存位置</h2><p>从缓存位置上来说分为四种，并且各自有优先级，当依次查找缓存且都没有命中的时候，才会去请求网络。<br>Service Worker<br>Memory Cache<br>Disk Cache<br>Push Cache</p>
<h3 id="Service-Worker"><a href="#Service-Worker" class="headerlink" title="Service Worker"></a>Service Worker</h3><p>是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。使用 Service Worker 的话，传输协议必须为 HTTPS。因为 Service Worker 中涉及到请求拦截，所以必须使用 HTTPS 协议来保障安全。它可以让我们自由控制缓存哪些文件，如何匹配缓存，如何读取缓存，并且缓存是持续性的。</p>
<ul>
<li>实现缓存功能的步骤<ul>
<li>首先注册 Service Worker</li>
<li>监听到 install 事件以后就可以缓存文件，在下次用户访问的时候就可以通过拦截请求的方式查询是否存在缓存，存在缓存的话就可以直接读取缓存文件，否则就去请求数据</li>
<li>当没有命中缓存的时候，我们需要去调用 fetch 函数获取数据。会根据缓存查找优先级去查找数据，但是不管是从 Memory Cache 中还是网络请求中获取的数据，浏览器都会显示我们是从 Service Worker 中获取的内容。</li>
</ul>
</li>
</ul>
<h3 id="Memory-Cache"><a href="#Memory-Cache" class="headerlink" title="Memory Cache"></a>Memory Cache</h3><p><code>Memory Cache</code> 是内存中的缓存，主要包含的是当前页面中已经抓取到的资源。eg:页面样式、脚本、图片等。</p>
<ul>
<li>内存缓存的特点<br>内存缓存读取高效，但是缓存持续性很短，会随着进程的释放而释放。<code>一旦关闭 Tab 页面，内存中的缓存也就被释放了。</code> 计算的内存容量小，所以缓存不能全部放在内存中。<br>注意点：<code>内存缓存在缓存资源时并不关心返回资源的 HTTP 缓存头 Cache-Control是什么值，同时资源的匹配也并非仅仅是对 URL 做匹配，还可能会对 Content-Type，CORS 等其他特征做校验。</code></li>
</ul>
<h3 id="Disk-Cache"><a href="#Disk-Cache" class="headerlink" title="Disk Cache"></a>Disk Cache</h3><p>Disk Cache 也就是存储在硬盘中的缓存，读取速度慢，但是什么都可以存储到硬盘中。<br>在所有浏览器缓存中，Disk Cache 覆盖面是最大的，它会根据 HTTP Herder 中的字段判断哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源已经过期需要重新请求，并且即使在跨站点的情况下，相同地址的资源一旦被硬盘缓存下来，就不会再次去请求数据。</p>
<h3 id="Push-Cache"><a href="#Push-Cache" class="headerlink" title="Push Cache"></a>Push Cache</h3><p>Push Cache (推送缓存) 是 HTTP/2 中的内容，Service Worker Memory Cache Disk Cache 三种缓存都没有命中的时，才会使用。Push Cache 只在会话中存在，一旦会话结束就被释放，并且缓存时间也很短暂。在 Chome 浏览器中只有五分钟左右，同时它也并非严格执行 HTTP 头中的缓存指令。</p>
<ul>
<li>所有的资源都能被推送并且能够被缓存，但是 Edge 和 Safari 浏览器支持相对比较差</li>
<li>可以推送 no-cache 和 no-store 的资源</li>
<li>一旦连接关闭，Push Cache 就释放</li>
<li>多个页面可以使用同一个 HTTP/2 连接，也就是可以使用同一个 Push Cache</li>
<li>Push Cache 中的缓存只能被使用一次</li>
<li>浏览器可以拒绝接受已经存在的资源推送</li>
<li>可以给其他域名推送资源</li>
</ul>
<p>如果以上四种缓存都没有命中的话，那么就只能发起请求来获取资源。为了性能上的考虑，大部分的接口都应该选择好缓存策略，<code>通常浏览器缓存策略分为两种：强缓存和协商缓存，并且缓存策略都是通过设置 HTTP Header 来实现</code></p>
<h2 id="缓存过程分析"><a href="#缓存过程分析" class="headerlink" title="缓存过程分析"></a>缓存过程分析</h2><p>浏览器和服务器的通讯方式为应答模式，即浏览器发起 HTTP 请求-服务器响应该请求，<code>那么浏览器怎么确定一个资源该不该缓存，如何去缓存呢？</code>浏览器第一次向服务器发起该请求后拿到请求结果后，将请求结果和缓存标识存入浏览器缓存，<code>浏览器对于缓存的处理是根据第一次请求资源时返回的响应头来确定的。</code></p>
<p><img src="https://upload-images.jianshu.io/upload_images/3174701-de3d6e025582103a?imageMogr2/auto-orient/strip%7CimageView2/2/w/670/format/webp" alt="发起请求"></p>
<ul>
<li>浏览器每次发起请求，都会在浏览器缓存中查找该请求的结果以及缓存标识</li>
<li>浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存中。</li>
</ul>
<h2 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h2><p>强缓存：不会向服务器发送请求，直接从缓存中读取资源，在 chorme 控制台中可以看到该请求返回 200 的状态码，并且 Size 显示 from disk cache 或 from memory cache 。强缓存可以通过设置两种 HTTP Header 实现： Expires 和 Cache-Control</p>
<h3 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h3><p><code>缓存过期时间，用来指定资源到期的时间，是服务器端的具体的时间点</code>。也就是说 Expires= max-age + 请求时间，需要和 Last-modified 结合使用。<code>Last-Modified</code>是服务器认为文件的最后修改时间，是第一次请求文件的时候，服务器返回的一个属性。<br>Expires 是 Web 服务器响应消息头字段，在响应 http 请求时告诉浏览器在过期时间前浏览器可以直接从缓存取数据，而无需再次请求</p>
<p>Expires 是 Http/1 的产物，受限于本地时间，如果修改了本地时间，可能会造成缓存失效。</p>
<h3 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h3><p>Cache-Control 是最重要的规则，主要用于控制网页缓存。可以在请求头或者响应头中设置。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3174701-8ff981603cdfded0?imageMogr2/auto-orient/strip%7CimageView2/2" alt="Cache-Control"></p>
<ul>
<li><p>public</p>
<ul>
<li>所有内容都将被缓存(客户端和代理服务器都可缓存)。响应可被任何中间节点缓存，</li>
<li>Browser &lt;– proxy1 &lt;– proxy2 &lt;– server 中间的 proxy 可以缓存。</li>
</ul>
</li>
<li><p>private</p>
<ul>
<li>所有内容只有客户端可以缓存，cache-control 的默认取值。具体来说，表示中间节点不允许缓存</li>
<li>对于 Browser &lt;– proxy1 &lt;– proxy2 &lt;– server，proxy 会把 server 返回的数据发送给 proxy1，自己不缓存任何数据，当下次浏览器再次请求时 proxy 会做好请求转发而不是自作主张给自己缓存的数据。</li>
</ul>
</li>
<li><p>no-cache</p>
<ul>
<li>客户端缓存内容，是否使用缓存则需要经过协商缓存来验证决定。表示不使用 Cache-Control 的缓存控制方式做前置验证，而是使用 Etag 或者 Last-Modified 字段来控制缓存。</li>
</ul>
</li>
<li><p>no-store</p>
<ul>
<li>所有的内容都不会被缓存，即不使用强制缓存，也不使用协商缓存。</li>
</ul>
</li>
<li><p>max-age</p>
<ul>
<li>max-age=xxx 表示缓存内容将在 xxx 秒后失效。</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/3174701-3fa81f5e9efac5af?imageMogr2/auto-orient/strip%7CimageView2/2" alt></p>
</li>
</ul>
<h3 id="Expires-和-Cache-Control-两者对比"><a href="#Expires-和-Cache-Control-两者对比" class="headerlink" title="Expires 和 Cache-Control 两者对比"></a>Expires 和 Cache-Control 两者对比</h3><p>Expires 是 http1.0 的产物，Cache-Control 是 Http1.1 的产物，<code>两者同时存在的话，Cache-Control优先级高于Expires</code>。<br>强缓存判断是否缓存的依据是来自于是否超出某个时间或者某个时间段，而不关心服务器端文件是否已经更新，这就可能会导致加载文件不是服务器端最新的内容。此时我们需要用协商缓存策略。</p>
<h2 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h2><p><code>协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程</code></p>
<ul>
<li>协商缓存生效，返回 304 和 Not Modified</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/3174701-660fd163329d080b?imageMogr2/auto-orient/strip%7CimageView2/2/w/709/format/webp" alt="协商缓存生效"></p>
<ul>
<li>协商缓存失效，返回 200 和请求结果<br><img src="https://upload-images.jianshu.io/upload_images/3174701-24953079cfebf2bf?imageMogr2/auto-orient/strip%7CimageView2/2/format/webp" alt="协商缓存失效"><br>协商缓存可以通过设置 HttP Header 实现：Last-Modified 和 ETag</li>
</ul>
<h3 id="Last-Modified-和-If-Modified-Since"><a href="#Last-Modified-和-If-Modified-Since" class="headerlink" title="Last-Modified 和 If-Modified-Since"></a>Last-Modified 和 If-Modified-Since</h3><p>浏览器在第一次访问资源时，服务器返回资源的同时，在 response header 中添加 Last-Modified 的 header,值是这个资源在服务器上的最后修改时间。<br>浏览器下次请求这个资源，浏览器检测到有 Last-Modified 这个 header，于是 添加 If-Modified-Since header 值就是 Last-Modified 中的值；服务器再次收到这个资源的请求，会根据 If-Modified-Since 中的值与服务器中这个资源的最后修改时间做对比，如果没有变化，返回 304 和空的响应体，直接从缓存中读取，如果 If-Modified-Since 的时间小于服务器中资源最后修改时间，说明文件有更新于是返回新的资源文件和 200</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3174701-bb7148a4431ccda1?imageMogr2/auto-orient/strip%7CimageView2/2/w/438/format/webp" alt></p>
<p>弊端：</p>
<ul>
<li>如果只是在本地打开文件，没有对文件进行修改，但是还是会造成 Last-Modified 被修改，服务器不能命中缓存</li>
<li>Last-Modified 只能以秒计时，如果在不可感知的时间内修改文件，服务器会认为会命中缓存</li>
</ul>
<p>根据文件修改时间来决定是否缓存存在问题，可以直接根据文件内容是否修改来决定缓存策略</p>
<h3 id="ETag-和-If-None-Match"><a href="#ETag-和-If-None-Match" class="headerlink" title="ETag 和 If-None-Match"></a>ETag 和 If-None-Match</h3><p>ETag 是服务器响应请求时，返回当前资源文件的一个唯一标识(Hash 值 由服务器生成)，只要资源有变化。ETag 就会重新生成。在下一次加载资源向服务器发送请求时，会将上次返回的 ETag 值放到 request header 里的 If-None-Match 里，服务器比较客户端传过来的 If-None-Match 跟自己服务器上该资源的 ETag 是否一致。就可以判断资源是不是最新的</p>
<p>Last-Modified 和 ETag 的对比</p>
<ul>
<li>精确度<br>Etag 要优于 Last-Modifed，Last-Modified 的时间单位是秒，如果资源在一秒内改变多次，Last-Modified 其实并不能体现出来，如果是负载均衡的服务器各个服务器生成的 Last-Modified 也有可能不一致。 ETag 每次都会改变确保了精确度。</li>
<li>性能上<br>ETag 要逊于 Last-Modified ，last-Modified 只需要记录时间，ETag 需要服务器通过算法来计算一个 hash 值。</li>
<li>优先级<br>服务器校验优先考虑 ETag</li>
</ul>
<h2 id="缓存机制"><a href="#缓存机制" class="headerlink" title="缓存机制"></a>缓存机制</h2><p>强缓存优先于协商缓存，若强缓存(Expires 和 Cache-Control) 生效则直接使用缓存，若不生效则进行协商缓存(Last-Modified/If-Modified-since 和 ETag/If-None-Match)，协商缓存由服务器决定是否使用缓存，若协商缓存失效，则缓存失效，返回 200 重新返回资源和缓存标识，再存入浏览器缓存中，生效则返回 304 继续使用缓存<br><img src="https://upload-images.jianshu.io/upload_images/3174701-9d9e8b52a18ed35a?imageMogr2/auto-orient/strip%7CimageView2/2/w/519/format/webp" alt></p>
<h2 id="实际场景应用缓存策略"><a href="#实际场景应用缓存策略" class="headerlink" title="实际场景应用缓存策略"></a>实际场景应用缓存策略</h2><h3 id="频繁变动的资源"><a href="#频繁变动的资源" class="headerlink" title="频繁变动的资源"></a>频繁变动的资源</h3><p>Cache-Control:no-cache<br>对于频繁变动的资源，首先需要使用 Cache-Control:no-cache 使浏览器每次都请求服务器，然后配合 ETag 或者 Last-Modified 来验证资源是否有效。这样的作法虽然不能节省请求数量，但是可以显著减少响应数据的大小</p>
<h3 id="不常变动的资源"><a href="#不常变动的资源" class="headerlink" title="不常变动的资源"></a>不常变动的资源</h3><p>Cache-Control:max-age = 31356000</p>
<p>通常处理这类资源时，给他们的 Cache-Control 配置一个很大的 max-age= 31536000(一年)，这样浏览器之后请求相同 Url 会命中强制缓存。而为了解决更新的问题，就需要在文件名中添加 hash 版本号等动态字符，之后更改为动态字符，从而达到更改引用 URL 的目的让之前的强制缓存失效(其实并未立即消失，只是暂时不再使用而已)</p>
<h2 id="用户行为对浏览器缓存的影响"><a href="#用户行为对浏览器缓存的影响" class="headerlink" title="用户行为对浏览器缓存的影响"></a>用户行为对浏览器缓存的影响</h2><p>指的就是用户再浏览器操作时，会触发怎样的缓存策略。主要有三种</p>
<ul>
<li>打开网页，地址输入 URL:查找 <code>disk cache</code> 中是否有匹配。如有则使用，没有则发送网络请求。</li>
<li>普通刷新(F5) 因为 tab 页没有关闭，因此 <code>memory cache</code>是可用的，会被优先使用(如果匹配的话)，其次才是 disk cache</li>
<li>强制刷新( Ctrl + F5): 浏览器不使用缓存，因此发送请求的头部均带有 <code>Cache-control:no-cache</code> ( 为了兼容，还带了 Pargam:no-cache),服务器直接返回 200 和最新内容。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2021/04/22/%E9%9D%A2%E8%AF%95/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/" data-id="cl139u3m3002lswdxdt3cdtr2" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-面试/作用域-作用域链" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/04/22/%E9%9D%A2%E8%AF%95/%E4%BD%9C%E7%94%A8%E5%9F%9F-%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/" class="article-date">
  <time datetime="2021-04-22T07:51:22.476Z" itemprop="datePublished">2021-04-22</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a>►<a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95/%E4%BD%9C%E7%94%A8%E5%9F%9F-%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/">作用域-作用域链</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/04/22/%E9%9D%A2%E8%AF%95/%E4%BD%9C%E7%94%A8%E5%9F%9F-%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/">作用域-作用域链</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h1><p>作用域是运行时代码的某些特定部分中变量，函数和对象的可访问性。即作用域决定了代码区块中变量和其他资源的可见性。<br>函数作用域在函数定义的时候就决定了。函数内部有个内部属性[[scope]],当函数创建的时候，就会保存所有父变量对象到其中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function outFun2()&#123;</span><br><span class="line">  var inVariable &#x3D; &#39;内层变量2&#39;</span><br><span class="line">&#125;</span><br><span class="line">outFun2()</span><br><span class="line">console.log(inVariable)  &#x2F;&#x2F; Uncaught ReferenceError: inVariable is not defined</span><br></pre></td></tr></table></figure>

<p>作用域最大的用处是隔离变量，不同作用域下同名变量不会有冲突。Es6 之前 JavaScript 没有块级作用域，只有全局作用域和函数作用域。</p>
<h2 id="全局作用域和函数作用域"><a href="#全局作用域和函数作用域" class="headerlink" title="全局作用域和函数作用域"></a>全局作用域和函数作用域</h2><ul>
<li><p>最外层的函数和在最外层函数外面定义的变量拥有全局作用域</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var outVariable &#x3D; &#39;我是最外层变量&#39;</span><br><span class="line">function outFun() &#123;</span><br><span class="line">  var inVariable &#x3D; &#39;内层变量&#39;;</span><br><span class="line">  function innerFun() &#123;</span><br><span class="line">    console.log(inVariable)</span><br><span class="line">  &#125;</span><br><span class="line">  innerFun()</span><br><span class="line">&#125;</span><br><span class="line">console.log(outVariable)   &#x2F;&#x2F; 我是外层变量</span><br><span class="line">outFun()                   &#x2F;&#x2F; 内层变量</span><br><span class="line">console.log(inVariable)    &#x2F;&#x2F; inVariable is not defined</span><br><span class="line">innerFun()                 &#x2F;&#x2F; innerFun is not defined</span><br></pre></td></tr></table></figure></li>
<li><p>所有未定义直接赋值的变量自动声明为拥有全局作用域</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function outFun2()&#123;</span><br><span class="line">  variable &#x3D; &#39;未定义直接赋值的变量&#39;;</span><br><span class="line">  var inVariable2 &#x3D; &#39;内层变量2&#39;</span><br><span class="line">&#125;</span><br><span class="line">outFun2()</span><br><span class="line">console.log(variable)      &#x2F;&#x2F; 未定义直接赋值的变量</span><br><span class="line">console.log(inVariable2)   &#x2F;&#x2F; inVariable2 is not defined</span><br></pre></td></tr></table></figure>
</li>
<li><p>所有 window 对象的属性拥有全局作用域<br>一般情况下，window 对象的内置属性都拥有全局作用域，eg:window.name、window.location 等。</p>
</li>
</ul>
<p>全局作用域有个弊端：如果我们写了很多行 JS 代码，变量定义都没有用函数包括，那么他们就全部都在全局作用域中。这样就会污染全局命名空间，容易起命名冲突。</p>
<p>注意：全局作用域在页面打开时被创建，页面关闭时被销毁。</p>
<h2 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a>函数作用域</h2><p>函数作用域，是指声明在函数内部的变量，和全局作用域相反，局部作用域一般只在固定的代码片段内可以访问到</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function doSomeThing()&#123;</span><br><span class="line">  var blogName &#x3D; &#39;blogName&#39;</span><br><span class="line">  function innerSay()&#123;</span><br><span class="line">    alert(blogName)</span><br><span class="line">  &#125;</span><br><span class="line">  innerSay()</span><br><span class="line">&#125;</span><br><span class="line">console.log(blogName) &#x2F;&#x2F; blogName is not defined</span><br><span class="line">innerSay()            &#x2F;&#x2F; innerSay is not defined</span><br></pre></td></tr></table></figure>

<ul>
<li>调用函数时，函数作用域被创建，函数执行完毕，函数作用域被销毁。</li>
<li>每调用一次函数就会创建一个新的函数作用域，他们之间是互相独立的。</li>
<li>函数作用域中可以访问到全局作用域的变量，在函数外部无法访问函数内部的变量。</li>
<li>在函数作用域中访问变量、函数会先在自身作用域中寻找，若是没有找到会到函数上一级作用域中寻找，一直到全局作用域，若是还没有找到返回 undefined。</li>
<li>函数作用域中也有声明提前的特性，对于变量和函数都起作用。</li>
<li>在函数中定义形参，等同于声明变量。</li>
</ul>
<p>作用域是分层的，内层作用域可以访问外层作用域的变量。</p>
<h2 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h2><p>块级作用域可通过新增命令 let 和 const 声明，所声明的变量在指定块的作用域外无法被访问。</p>
<ul>
<li>块级作用域的特点<ul>
<li>变量声明不会提前到代码顶部<br>let/const 声明并不会被提升到当前代码块的顶部，因此需要手动将 let/const 声明放置到顶部，以便让变量在整个代码块内部可用。</li>
<li>禁止重复声明，如果一个标识符已经在代码块内声明过，那么在此代码块内使用同一个标进行 let 声明就会抛出错误。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var count &#x3D; 30</span><br><span class="line">let count &#x3D; 40  &#x2F;&#x2F; Uncaught SyntaxError: Identifier &#39;count&#39; has already been declare</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h1 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h1><h2 id="Scopr-Chain-作用域链"><a href="#Scopr-Chain-作用域链" class="headerlink" title="[[Scopr Chain]] 作用域链"></a>[[Scopr Chain]] 作用域链</h2><p>当查找变量的时候，会先从当前上下文的变量对象中查找，如果没有找到就会从父级执行上下文的变量对象中查找，一直找到全局上下文的变量对象(全局对象)。这样由多个执行上下文的变量对象构成的链表就是作用域链。<br>根据在内部函数可以访问外部函数变量的这种机制，用链式查找决定哪些数据能被内部函数访问，这就时作用域链。</p>
<h1 id="JS-执行环境"><a href="#JS-执行环境" class="headerlink" title="JS 执行环境"></a>JS 执行环境</h1><p>执行环境(Execution context，EC) 或执行上下文。分为三种( 全局执行环境、函数执行环境、eval()执行环境)<br>js 为每一个执行环境关联了一个变量对象。环境中定义的所有变量和函数都保存在这个对象中。</p>
<h2 id="EC-的组成"><a href="#EC-的组成" class="headerlink" title="EC 的组成"></a>EC 的组成</h2><p>当 JavaScript 代码执行的时候，会进入不同的执行环境(执行上下文)，这些执行环境会构成了一个执行环境栈(执行上下文栈)(Execution context stack,ECS)<br><img src="https://segmentfault.com/img/bVbenRf?w=881&h=466" alt="执行环境"></p>
<h3 id="变量对象-VO-和-活动对象-AO"><a href="#变量对象-VO-和-活动对象-AO" class="headerlink" title="变量对象(VO) 和 活动对象(AO)"></a>变量对象(VO) 和 活动对象(AO)</h3><p><code>变量对象(VO)</code>: 变量对象即包含变量的对象，除了我们无法访问它外，和普通对象没有区别。变量对象存储了在<code>上下文中定义的变量</code>和<code>函数声明</code>。</p>
<p><code>活动对象(AO)</code>: 活动对象和变量对象是一个东西，变量对象是规范上的或者说是引擎上实现的，不可在 JavaScript 环境中访问，只有到当进入一个执行上下文中，这个执行上下文的变量对象才会被激活，activation object <code>只有被激活的变量对象，也就是活动对象上的各种属性才能被访问</code>。<br>活动对象是在进入函数执行环境时刻被创建的，它通过函数的 argument 属性初始化</p>
<h3 id="执行环境"><a href="#执行环境" class="headerlink" title="执行环境"></a>执行环境</h3><p>全局执行环境是最外围的执行环境，全局执行环境被认为是 window 对象，因此所有的全局变量和函数都作为 window 对象的属性和方法创建的。<br>js 的执行顺序是根据函数的调用来决定的，当一个函数被调用时，该函数环境变量对象就被压入一个环境栈中。在函数执行之后，栈将该函数的变量对象弹出，把控制权交给之前的执行环境变量对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var scope &#x3D; &#39;global&#39;</span><br><span class="line">  function fn1()&#123;</span><br><span class="line">    return scope</span><br><span class="line">  &#125;</span><br><span class="line">  function fn2()&#123;</span><br><span class="line">    return scope</span><br><span class="line">  &#125;</span><br><span class="line">  fn1()</span><br><span class="line">  fn2()</span><br></pre></td></tr></table></figure>

<p><img src="https://segmentfault.com/img/bVbenRt?w=1042&h=436" alt></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2021/04/22/%E9%9D%A2%E8%AF%95/%E4%BD%9C%E7%94%A8%E5%9F%9F-%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/" data-id="cl139u3ln002iswdxg5jobauk" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-面试/从URL输入到页面展示" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/04/22/%E9%9D%A2%E8%AF%95/%E4%BB%8EURL%E8%BE%93%E5%85%A5%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%A4%BA/" class="article-date">
  <time datetime="2021-04-22T07:51:22.476Z" itemprop="datePublished">2021-04-22</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a>►<a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95/%E4%BB%8EURL%E8%BE%93%E5%85%A5%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%8E%B0%E6%B6%89%E5%8F%8A%E7%9A%84%E7%9F%A5%E8%AF%86%E3%80%82/">从URL输入到页面展现涉及的知识。</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/04/22/%E9%9D%A2%E8%AF%95/%E4%BB%8EURL%E8%BE%93%E5%85%A5%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%A4%BA/">从URL输入到页面展现涉及的知识。</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>总体分为六个过程</p>
<ul>
<li>DNS 解析：将域名解析成 IP 地址</li>
<li>TCP 连接：TCP 三次握手</li>
<li>发送 HTTP 请求</li>
<li>服务器处理请求并返回 HTTP 报文</li>
<li>浏览器解析渲染页面</li>
<li>断开连接：TCP 四次挥手</li>
</ul>
<h1 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h1><p>URL (Unifrom Resource Locator)，统一资源定位符，用于定位互联网上资源，俗称网址。</p>
<ul>
<li><p>遵循的语法规则<br>scheme://host.domain:port/path/filename</p>
<ul>
<li>scheme - 定义因特网服务的类型。常见的协议有 http、https、ftp、file 其中最常见的类型是 http，而 https 则是进行加密的网络传输。</li>
<li>host - 定义域主机(http 的默认主机是 www)</li>
<li>domain - 定义因特网<code>域名</code>，eg: w3school.com.cn</li>
<li>port - 定义主机上的端口号 (http 的默认端口号是 80)</li>
<li>path - 定义服务器上的路径 (如果省略，则文档必须位于网站的根目录中)</li>
<li>filename - 定义文档/资源的名称</li>
</ul>
</li>
<li><p>URL 编码</p>
<p>URL 只能使用 ASCII 字符集，不属于 ASCII 中的字符，都必须进行编码才能使用 URL 来进行表示，若传输时使用了特殊字符会造成不必要的问题，导致服务器不能解析。</p>
<ul>
<li>编码方法<br>使用 JavaScript 中 3 对方法进行 URL 的 编码/解码 <code>escape/unescape，encodeURI/decodeURI 和encodeURIComponent/decodeURIComponent</code>,<br>三者适用场合不同，<code>encodeURI</code> 用于对整个 URI 进行编码 <code>encodeURIComponent</code> 被用于对 URI 的一部份进行编码，通常是指查询字符串或路径。</li>
</ul>
</li>
</ul>
<h1 id="域名解析-DNS"><a href="#域名解析-DNS" class="headerlink" title="域名解析 (DNS)"></a>域名解析 (DNS)</h1><p>在浏览器输入网址后，首先要经过域名解析，浏览器并不能直接通过域名找到对应的服务器，而是通过 IP 地址</p>
<h2 id="IP-地址"><a href="#IP-地址" class="headerlink" title="IP 地址"></a>IP 地址</h2><p>IP 地址是指互联网协议地址，是 IP Address 的缩写。 IP 地址是 IP 协议提供的一种统一的地址格式，它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。Ip 地址是一个 32 位的二进制数。</p>
<p><code>域名相当于 IP 地址乔装打扮的伪装者，带着一副面具。作用就是便于记忆和沟通的一组服务器的地址。</code>与 Ip 地址的一组纯数字相比，用字母配合数字的表示形式来指定计算机名更符合人类的记忆习惯，但要计算机去理解就相对变得的困难，为了解决这个问题,DNS 服务器应运而生。</p>
<h2 id="什么是域名解析"><a href="#什么是域名解析" class="headerlink" title="什么是域名解析"></a>什么是域名解析</h2><p>DNS 协议提供通过域名查找 IP 地址，或逆向从 IP 地址反查域名的服务，DNS 是一个网络服务器，我们的域名解析简单来说就是在 DNS 上记录一条信息。</p>
<h2 id="浏览器如何通过域名去查询-URL-对应的-IP"><a href="#浏览器如何通过域名去查询-URL-对应的-IP" class="headerlink" title="浏览器如何通过域名去查询 URL 对应的 IP"></a>浏览器如何通过域名去查询 URL 对应的 IP</h2><ul>
<li>浏览器缓存：浏览器会按照一定的频率缓存 DNS 记录。</li>
<li>操作系统缓存：如果浏览器缓存中找不到需要的 DNS 记录，那就从操作系统中找。</li>
<li>路由缓存： 路由器也有 DNS 缓存。</li>
<li>ISP 的 DNS 服务器：ISP 是互联网提供商 (Internet Service Provider)的简称，ISP 有专门的 DNS 服务器应对 DNS 查询请求。</li>
<li>根服务器：ISP 的 DNS 服务器还找不到的话，它就会向根服务器发出请求，进行递归查询 (DNS 服务先问根域名服务器.com 域名服务器的 IP 地址，然后再问 .baidu 域名服务器，依次类推)</li>
</ul>
<p><code>浏览器通过向 DNS 服务器发送域名，DNS 服务器查询到与域名相对应的 IP 地址，然后返回给浏览器，浏览器再将 IP 地址打在协议上，同时请求参数也会在协议搭载，然后一并发送给对应的服务器。</code></p>
<h1 id="TCP-三次握手"><a href="#TCP-三次握手" class="headerlink" title="TCP 三次握手"></a>TCP 三次握手</h1><p>三次握手其实就是指建立一个 TCP 连接时，需要客户端和服务器端总共发送三个包。进行三次握手的主要目的是为了确认双方的接收能力和发送能力是否正常，指定自己的初始化序列号为后面的可靠性传送做准备。<br>在客户端发送数据之前会发起 TCP 三次握手用以同步客户端和服务端的序列号和确认号，并交换 TCP 窗口大小信息。</p>
<h3 id="握手过程"><a href="#握手过程" class="headerlink" title="握手过程"></a>握手过程</h3><p>刚开始客户端处于 closed 的状态，服务器处于 Listen 状态。</p>
<ul>
<li>第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN。此时客户端处于 SYN_Send 状态</li>
<li>第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 作为应答，并且也是指定了自己的初始化序列号 ISN，同时会把客户端的 ISN+1 作为 ACK 的值，表示已经收到了客户端的 SYN，此时服务器处于 SYN_REVD 的状态</li>
<li>第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，把服务器 ISN+1 作为 ACK 的值。表示已经收到了服务端的 SYN 报文，此时客户端处于 establised 状态。</li>
<li>服务器收到 ACK 报文之后，也处于 establised 状态。<br><img src="https://user-gold-cdn.xitu.io/2019/4/10/16a074b331fb0d85?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt></li>
</ul>
<p>注意点：解释一下为啥只有三次握手才能确认双方的接受与发送能力是否正常，而两次却不可以：<br>第一次握手：客户端发送网络包，服务端收到了。这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。<br>第二次握手：服务端发包，客户端收到了。这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。<br>第三次握手：客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。</p>
<h1 id="发送-HTTP-请求"><a href="#发送-HTTP-请求" class="headerlink" title="发送 HTTP 请求"></a>发送 HTTP 请求</h1><p>http 请求报文由请求行(request line)、请求头(header)、请求体、空行(blank line)四部分组成。</p>
<ul>
<li>请求行包含请求方法、URL、协议版本<ul>
<li>请求方法包含 8 种:get、post、put、delete、patch、head、options、trace<ul>
<li>get 请求<br>数据是英文字母/数字，原样发送；如果是空格，转换为 + ；如果是中文/其他字符，则直接把字符串用 BASE64 加密,得出：%E4%BD，其中%XX 中的 XX 为该字符号以 16 进制表示的 ASCII。</li>
<li>post 请求</li>
</ul>
</li>
<li>URL 即请求地址，由&lt;协议&gt;://&lt;主机&gt;:&lt;端口&gt;/&lt;路径&gt;?&lt;参数&gt; 组成</li>
<li>协议版本即 http 版本号。</li>
</ul>
</li>
<li>请求头包含请求附加信息，由关键字/值对组成每行一对，关键字和值用英文冒号分隔。<br>请求头部通知服务器有关于客户端请求的信息。它包含许多有关的客户端环境和请求正文的有用信息。eg:host，表示主机名，使用 keepalive,即持久连接，一个连接可以发多个请求；</li>
<li>请求体，可以承载多个请求参数的数据，包含回车符、换行符、和请求数据。</li>
</ul>
<p><img src="https://segmentfault.com/img/bVQL82?w=594&h=232" alt="http请求报文格式"></p>
<h1 id="服务器处理请求并返回-HTTP-报文"><a href="#服务器处理请求并返回-HTTP-报文" class="headerlink" title="服务器处理请求并返回 HTTP 报文"></a>服务器处理请求并返回 HTTP 报文</h1><h2 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h2><p>服务器是网络环境中的高性能计算机，它侦听网络上的其他计算机(客户机)提交的服务请求，并提供响应的服务，eg:网页服务、文件下载、邮件服务、视频服务。客户端的主要功能是浏览网页、看视频、等等两者截然不同。每台服务器上都会安装处理请求的应用————web server .<br><code>web server 担任管控的角色</code>，对于不同用户发送的请求，会结合配置文件，把不同请求委托给服务器上处理相应请求的程序进行处理，然后返回后台程序处理产生的结果作为响应。</p>
<h1 id="浏览器解析渲染页面"><a href="#浏览器解析渲染页面" class="headerlink" title="浏览器解析渲染页面"></a>浏览器解析渲染页面</h1><p>浏览器解析渲染页面分为五个步骤</p>
<ul>
<li>根据 HTML 解析出 DOM 树</li>
<li>根据 CSS 解析生成 CSS 规则树</li>
<li>结合 DOM 树和 CSS 规则树，生成渲染树</li>
<li>根据渲染树计算每一个节点是信息</li>
<li>根据计算好的信息绘制页面</li>
</ul>
<h2 id="根据-HTML-解析出-DOM-树"><a href="#根据-HTML-解析出-DOM-树" class="headerlink" title="根据 HTML 解析出 DOM 树"></a>根据 HTML 解析出 DOM 树</h2><ul>
<li>根据 HTML 的内容，将标签按照结构解析成为 DOM 树，DOM 树解析的过程是一个深度优先遍历。即先构建当前节点的所有子节点，再构建下一个兄弟节点。</li>
<li>在读取 HTML 文档，构建 DOM 树的过程中，若遇到 script 标签，则 DOM 树的构建会暂停，直至脚本执行完毕。</li>
</ul>
<h2 id="根据-CSS-解析生成-CSS-规则树"><a href="#根据-CSS-解析生成-CSS-规则树" class="headerlink" title="根据 CSS 解析生成 CSS 规则树"></a>根据 CSS 解析生成 CSS 规则树</h2><ul>
<li>解析 CSS 规则树时 js 执行将暂停，直至 CSS 规则树就绪。</li>
<li>浏览器在 CSS 规则树生成之前不会进行渲染。</li>
</ul>
<h2 id="结合-DOM-树和-CSS-规则树，生成渲染树"><a href="#结合-DOM-树和-CSS-规则树，生成渲染树" class="headerlink" title="结合 DOM 树和 CSS 规则树，生成渲染树"></a>结合 DOM 树和 CSS 规则树，生成渲染树</h2><ul>
<li>DOM 树和 CSS 规则树全部准备好了以后，浏览器才开始构建渲染树。</li>
<li>精简 CSS 并可以加快 CSS 规则树的构建，从而加快页面相应速度。</li>
</ul>
<h2 id="根据渲染树计算每一个节点的信息-布局"><a href="#根据渲染树计算每一个节点的信息-布局" class="headerlink" title="根据渲染树计算每一个节点的信息(布局)"></a>根据渲染树计算每一个节点的信息(布局)</h2><ul>
<li>布局：通过渲染树中渲染对象的信息，计算出每一个渲染对象的位置和尺寸。</li>
<li>回流：在布局完成后，发现了某个部分发生了变化影响了布局，那就需要倒回去重新渲染。</li>
</ul>
<h2 id="根据计算好的信息绘制页面"><a href="#根据计算好的信息绘制页面" class="headerlink" title="根据计算好的信息绘制页面"></a>根据计算好的信息绘制页面</h2><ul>
<li>绘制阶段：系统会遍历呈现树，并调用呈现器的”paint”方法，将呈现器的内容显示在屏幕上。</li>
<li>重绘：某个元素的背景颜色，文字颜色等，不影响元素周围或内部布局的属性，将只会引起浏览器的重绘。</li>
<li>回流：某个元素的尺寸发生了变化，则需要重新计算渲染树，重新渲染。</li>
</ul>
<h1 id="断开连接"><a href="#断开连接" class="headerlink" title="断开连接"></a>断开连接</h1><p>当数据传送完毕，需要断开 tcp 连接，此时发起 tcp 四次挥手。</p>
<ul>
<li>发起方向被动方发送报文，Fin、Ack、Seq，表示已经没有数据传输了。并进入 FIN_WAIT_1 状态。(第一次挥手：由浏览器发起的，发送给服务器，我请求报文发送完了，你准备关闭吧)</li>
<li>被动方发送报文，Ack、Seq，表示同意关闭请求。此时主机发起方进入 FIN_WAIT_2 状态。(第二次挥手：由服务器发起的，告诉浏览器，我请求报文接受完了，我准备关闭了，你也准备吧)</li>
<li>被动方向发起方发送报文段，Fin、Ack、Seq，请求关闭连接。并进入 LAST_ACK 状态。(第三次挥手：由服务器发起，告诉浏览器，我响应报文发送完了，你准备关闭吧)</li>
<li>发起方向被动方发送报文段，Ack、Seq。然后进入等待 TIME_WAIT 状态。被动方收到发起方的报文段以后关闭连接。发起方等待一定时间未收到回复，则正常关闭。(第四次挥手：由浏览器发起，告诉服务器，我响应报文接受完了，我准备关闭了，你也准备吧)</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2021/04/22/%E9%9D%A2%E8%AF%95/%E4%BB%8EURL%E8%BE%93%E5%85%A5%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%A4%BA/" data-id="cl139u3lo002kswdx8l6b37fc" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-面试/vue路由模式" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/04/22/%E9%9D%A2%E8%AF%95/vue%E8%B7%AF%E7%94%B1%E6%A8%A1%E5%BC%8F/" class="article-date">
  <time datetime="2021-04-22T07:51:22.475Z" itemprop="datePublished">2021-04-22</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a>►<a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95/vue%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%8C%E8%B7%AF%E7%94%B1%E6%A8%A1%E5%BC%8F%E5%8E%9F%E7%90%86/">vue知识点，路由模式原理</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/04/22/%E9%9D%A2%E8%AF%95/vue%E8%B7%AF%E7%94%B1%E6%A8%A1%E5%BC%8F/">路由模式原理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="路由的实现"><a href="#路由的实现" class="headerlink" title="路由的实现"></a>路由的实现</h2><p>前端路由的实现：本质上是检测 url 的变化，截获 url 地址，然后解析来匹配路由规则。但是 url 每次变化都会刷新页面，页面刷新 JavaScript 怎么检测和截获 url?2014 年之前，大家是通过 hash 来实现路由 url hash 类似于 <code>https://ssss.com/a/#file</code> <code>#</code> 后面 hash 值的变化，并不会导致浏览器向服务器发出请求，也就不会刷新页面，而 hash 值的变化都会触发 <code>hashchange</code>事件，通过这个事件我们就可以知道 hash 值发生了那些改变。</p>
<p>14 年后，HTML5 标准发布，多了两个 API <code>pushState 和 replaceState</code>,通过两个 API 可以改变 url 地址且不会发送请求。还有 <code>onpopstate</code>事件。用了 HTMl5 的实现，单页路由的 url 就不会多出一个 <code>#</code> 变得更加美观。但没有 # 所以当用户刷新页面之类的操作时，浏览器还是会给服务器发送请求，需要后台配置支持因为是单页面应用，如果后台没有正确的配置，当用户在浏览器直接访问 <code>htpp://oursit.com/user/id</code>就会返回 404</p>
<p>所以要在服务端增加一个覆盖所有情况的候选资源：如果 url 匹配不到任何静态资源，则应该返回一个 <code>index.html</code> ,这个 页面就是你 app 依赖的页面。</p>
<h2 id="hash-模式"><a href="#hash-模式" class="headerlink" title="hash 模式"></a>hash 模式</h2><p>hash 模式的工作原理是 hashchange 事件，可以在 window 监听 hash 的变化。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">window.onhashchange &#x3D; function(event)&#123;</span><br><span class="line">  console.log(event)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有两个属性 newURL 和 oldURL。根据 hash 值的变化加载对应的动态页面数据。</p>
<h2 id="history-模式"><a href="#history-模式" class="headerlink" title="history 模式"></a>history 模式</h2><p>HTML5 新增的 API</p>
<ul>
<li>history.pushState():往历史记录堆栈顶部添加一条记录</li>
<li>history.replaceState():更改当前的历史记录。</li>
<li>history.state: 用于存储以上方法的 data 数据</li>
<li>window.onpopstate : 响应 pushState 或 replaceState 的调用</li>
</ul>
<p>当使用 history 模式时，还需要后台配置支持，因为我们的应用是单页面应用，如果后台没有正确的配置，当用户在浏览器直接访问 <code>http://www.xxxxxx/detail</code> 就会返回 404 。所以需要在服务器增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html。服务器就不在返回 404 错误页面，因为会对所有路径返回 index.html 文件。为了避免这种情况，应该在 Vue 应用里面覆盖所有的路由情况，然后给出一个 404 页面。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2021/04/22/%E9%9D%A2%E8%AF%95/vue%E8%B7%AF%E7%94%B1%E6%A8%A1%E5%BC%8F/" data-id="cl139u3lk002fswdx0w0c3uof" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-面试/vue生命周期知识" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/04/22/%E9%9D%A2%E8%AF%95/vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9F%A5%E8%AF%86/" class="article-date">
  <time datetime="2021-04-22T07:51:22.475Z" itemprop="datePublished">2021-04-22</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a>►<a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95/vue%E7%9F%A5%E8%AF%86%E7%82%B9/">vue知识点</a>►<a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95/vue%E7%9F%A5%E8%AF%86%E7%82%B9/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9F%A5%E8%AF%86/">生命周期知识</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/04/22/%E9%9D%A2%E8%AF%95/vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9F%A5%E8%AF%86/">生命周期知识</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>var app = new Vue({})</p>
<p>第一个钩子函数就是 beforeCreate，在这之前组件还没有真正的初始化。<br>在 beforeCreate 之后，Vue 对 data 对象作了 getter/setter 处理，并且将对象放在一个 Observe 里面以便监控对象。还使用 initEvents 绑定事件。</p>
<p><code>此时不能访问data的属性以及绑定的事件</code></p>
<p>组件初始化完成后，遇到 created。在这个阶段我们可以访问到了 data 的属性以及绑定的事件。</p>
<p>通过 created 阶段后组件的生命周期到了 beforemount,在这个阶段 DOM 结构还没有生成。但是已经创建了 el，组件挂载的根节点。在 beforemount 执行之后开始渲染 DOM。执行_render 方法，_mount 方法，然后会有 new 出一个 watcher 对象，形成 VNode 节点，然后更新 DOM。</p>
<p>渲染完毕后组件就会到下一个声明周期 mounted，一般的异步请求都会写在这里。这个阶段 DOM 已经渲染出来了。</p>
<p>Q: 什么是生命周期</p>
<p>A: Vue 实例从创建到销毁的过程，就是生命周期。也就是从开始创建、初始化数据、编译模板、挂载 DOM-&gt;渲染、更新-&gt;渲染、卸载等一系列过程。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2021/04/22/%E9%9D%A2%E8%AF%95/vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9F%A5%E8%AF%86/" data-id="cl139u3ll002hswdx4gkogdc8" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-面试/SPA" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/04/22/%E9%9D%A2%E8%AF%95/SPA/" class="article-date">
  <time datetime="2021-04-22T07:51:22.474Z" itemprop="datePublished">2021-04-22</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a>►<a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95/vue%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%8CSPA%E5%8D%95%E9%A1%B5%E9%9D%A2/">vue知识点，SPA单页面</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/04/22/%E9%9D%A2%E8%AF%95/SPA/">SPA单页面</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="SPA-单页面，优缺点是"><a href="#SPA-单页面，优缺点是" class="headerlink" title="SPA 单页面，优缺点是"></a>SPA 单页面，优缺点是</h3><p>SPA ( single-page-application ) 仅在页面初始化时加载相应的 HTML、JavaScript 和 CSS。页面加载完成，SPA 不会因为用户的操作而进行页面的重新加载或者跳转;取而代之的是利用路由机制实现 HTML 内容的变换，UI 与用户的交互，避免页面的重新加载。</p>
<p>单页面</p>
<p><code>单页面应用，就是只有一个页面的应用，页面的刷新和内部子页面的跳转完全由js来控制。</code></p>
<ul>
<li><p>单页面应用的特点</p>
<ul>
<li>本地路由，由 js 定义路由、根据路由渲染页面、控制页面的跳转。</li>
<li>所有的文件只会加载一次，最大限度重用文件，并且极大提升加载速度。</li>
<li>按需加载<br>根据业务逻辑拆分代码为独立的异步 js 文件(不存在于 html 的 Script 中)，在触发对应逻辑(如路由跳转，组件使用等)时通过 js 代码进行下载并使用。</li>
</ul>
</li>
<li><p>优点：</p>
<ul>
<li>有良好的交互体验<br>能提升页面切换体验，用户在访问应用页面是不会频繁的去切换浏览页面，从而避免了页面的重新加载。</li>
<li>前后端分离开发<br>前端进行交互逻辑，后端负责数据处理。</li>
<li>减轻服务器压力<br>服务器只用出数据就可以，不用管展示逻辑和页面合成。</li>
<li>共有一套后端代码<br>不用修改后端程序代码就可以同时用于多种客户端。</li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li>初次加载很耗时多<br>为实现单页面 Web 应用功能及显示效果，需要在加载页面的时候将 JavaScript、CSS 统一加载，部分页面可以在需要的时候加载</li>
<li>SEO 难度较高<br>由于所有的内容都会在一个页面中动态替换显示，</li>
<li>前进后退路由管理<br>由于单页面应用在一个页面显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理。</li>
</ul>
</li>
<li><p>性能优化</p>
<ul>
<li>加载优化<br>通常一开始就会加载所必需的的代码(JavaScript HTML CSS),首屏加载太慢会按需加载。<br><code>按需加载</code>就是按照当前呈现的不同页面加载不同的文件，<br>当首屏加载完毕后，设备&amp;网络处于空闲状态，可以对其他路由组件进行预加载。<br>根据路由拆分减少初始化加载体积，利用异步加载方式，在路由注册时提供拉取组件的方法，仅在需要进入对应路由时，组件才会被加载进来。</li>
<li>SEO 优化</li>
</ul>
</li>
<li><p>体验优化</p>
<ul>
<li>构建骨架图。</li>
<li>页面切换<br>页面切换前：在确保组件数据加载完毕前，可保证页面可交互，减少用户阻塞感。<br>切换时增加动画</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2021/04/22/%E9%9D%A2%E8%AF%95/SPA/" data-id="cl139u3li002cswdxapcr1s5g" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-面试/vue原理&amp;MVVM" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/04/22/%E9%9D%A2%E8%AF%95/vue%E5%8E%9F%E7%90%86&MVVM/" class="article-date">
  <time datetime="2021-04-22T07:51:22.474Z" itemprop="datePublished">2021-04-22</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a>►<a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95/vue%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%8C%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86-MVVM/">vue知识点，双向数据绑定原理& MVVM</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/04/22/%E9%9D%A2%E8%AF%95/vue%E5%8E%9F%E7%90%86&MVVM/">双向数据绑定原理&amp; MVVM</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="几种实现双向数据绑定的做法"><a href="#几种实现双向数据绑定的做法" class="headerlink" title="几种实现双向数据绑定的做法"></a>几种实现双向数据绑定的做法</h2><p>实现数据绑定的做法有大致有：</p>
<ul>
<li>发布者-订阅者模式<br>一般通过 sub、pub 的方式实现数据和视图的绑定监听，更新数据的方式通常做法是 vm.set(‘property’,value)</li>
<li>脏值检查 (angular.js)<br>是通过脏值检测的方式比对数据是否有变更，来决定是否更新视图，最简单的方式是通过 setInterval() 定时轮询检测数据变动，angular 只有在指定的事件触发时进入脏值检测，大致流程<ul>
<li>DOM 事件，例如用户输入文本点击按钮等</li>
<li>XHR 响应事件($http)</li>
<li>浏览器 Location 变更事件($location)</li>
<li>Timer 事件($timeout,$interval)</li>
<li>执行 $digest() 或 $apply()</li>
</ul>
</li>
<li>数据劫持 (vue.js)<br>vue.js 是数据劫持结合发布者-订阅者模式的方式，通过 Object.defineProperty() 来劫持各个属性的 setter，getter,在数据变动时发布消息给订阅者，触发相应的监听回调。</li>
</ul>
<h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p>要实现 mvvm 的双向绑定，就必须要实现以下几点：</p>
<ul>
<li>实现一个数据监听 Observer，能够对数据对象的所有属性进行监听，如有变动可拿到最新值并通知订阅者</li>
<li>实现一个指令解析器 Compile,对每一个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数。</li>
<li>实现一个 Watcher,作为连接 Observer 和 Compile 的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数，从而更新视图。</li>
</ul>
<p><img src="https://segmentfault.com/img/bVBQYu?w=730&h=390" alt></p>
<h3 id="实现-Observer"><a href="#实现-Observer" class="headerlink" title="实现 Observer"></a>实现 Observer</h3><p>利用 Object.defineProperty() 来监听属性变动，那么将需要监听的数据对象进行递归遍历，包括子属性对象的属性，都加上 setter 和 getter, 这样给这个对象的某个值赋值，就会触发 setter，那么就能监听到了数据变化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">function observe(data) &#123;</span><br><span class="line">    if (!data || typeof data !&#x3D;&#x3D; &#39;object&#39;) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 取出所有属性遍历</span><br><span class="line">    Object.keys(data).forEach(function(key) &#123;</span><br><span class="line">        defineReactive(data, key, data[key]);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function defineReactive(data, key, val) &#123;</span><br><span class="line">    observe(val); &#x2F;&#x2F; 监听子属性</span><br><span class="line">    Object.defineProperty(data, key, &#123;</span><br><span class="line">        enumerable: true, &#x2F;&#x2F; 可枚举</span><br><span class="line">        configurable: false, &#x2F;&#x2F; 不能再define</span><br><span class="line">        get: function() &#123;</span><br><span class="line">            return val;</span><br><span class="line">        &#125;,</span><br><span class="line">        set: function(newVal) &#123;</span><br><span class="line">            console.log(&#39;哈哈哈，监听到值变化了 &#39;, val, &#39; --&gt; &#39;, newVal);</span><br><span class="line">            val &#x3D; newVal;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样我们就可以监听每个数据的变化了，监听到变化之后就是怎么通知订阅者了，接下来我们需要实现一个消息订阅器，就是维护一个数组，用来收集订阅者，数据变动触发 notify,再调用订阅者的 update 方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">  function defineReactive(data, key, val) &#123;</span><br><span class="line">    var dep &#x3D; new Dep();</span><br><span class="line">    observe(val); &#x2F;&#x2F; 监听子属性</span><br><span class="line"></span><br><span class="line">    Object.defineProperty(data, key, &#123;</span><br><span class="line">        &#x2F;&#x2F; ... 省略</span><br><span class="line">        set: function(newVal) &#123;</span><br><span class="line">            if (val &#x3D;&#x3D;&#x3D; newVal) return;</span><br><span class="line">            console.log(&#39;哈哈哈，监听到值变化了 &#39;, val, &#39; --&gt; &#39;, newVal);</span><br><span class="line">            val &#x3D; newVal;</span><br><span class="line">            dep.notify(); &#x2F;&#x2F; 通知所有订阅者</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Dep() &#123;</span><br><span class="line">    this.subs &#x3D; [];</span><br><span class="line">&#125;</span><br><span class="line">Dep.prototype &#x3D; &#123;</span><br><span class="line">    addSub: function(sub) &#123;</span><br><span class="line">        this.subs.push(sub);</span><br><span class="line">    &#125;,</span><br><span class="line">    notify: function() &#123;</span><br><span class="line">        this.subs.forEach(function(sub) &#123;</span><br><span class="line">            sub.update();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>who 是订阅者？怎么往订阅器添加订阅者？<br>订阅者就是 Watcher 而且 var dep = new Dep() 是在 defineReactive 方法内部定义的，所以想通过 dep 添加订阅者，是在 getter 里面</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">  Object.defineProperty(data, key, &#123;</span><br><span class="line">    get: function() &#123;</span><br><span class="line">        &#x2F;&#x2F; 由于需要在闭包内添加watcher，所以通过Dep定义一个全局target属性，暂存watcher, 添加完移除</span><br><span class="line">        Dep.target &amp;&amp; dep.addSub(Dep.target);</span><br><span class="line">        return val;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; ... 省略</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Watcher.js</span><br><span class="line">Watcher.prototype &#x3D; &#123;</span><br><span class="line">    get: function(key) &#123;</span><br><span class="line">        Dep.target &#x3D; this;</span><br><span class="line">        this.value &#x3D; data[key];    &#x2F;&#x2F; 这里会触发属性的getter，从而添加订阅者</span><br><span class="line">        Dep.target &#x3D; null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实现-Compile"><a href="#实现-Compile" class="headerlink" title="实现 Compile"></a>实现 Compile</h3><p>compile 主要做的事情是解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图。<br><img src="https://segmentfault.com/img/bVBQY3?w=625&h=259" alt></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">  function Compile(el) &#123;</span><br><span class="line">    this.$el &#x3D; this.isElementNode(el) ? el : document.querySelector(el);</span><br><span class="line">    if (this.$el) &#123;</span><br><span class="line">        this.$fragment &#x3D; this.node2Fragment(this.$el);</span><br><span class="line">        this.init();</span><br><span class="line">        this.$el.appendChild(this.$fragment);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Compile.prototype &#x3D; &#123;</span><br><span class="line">    init: function() &#123; this.compileElement(this.$fragment); &#125;,</span><br><span class="line">    node2Fragment: function(el) &#123;</span><br><span class="line">        var fragment &#x3D; document.createDocumentFragment(), child;</span><br><span class="line">        &#x2F;&#x2F; 将原生节点拷贝到fragment</span><br><span class="line">        while (child &#x3D; el.firstChild) &#123;</span><br><span class="line">            fragment.appendChild(child);</span><br><span class="line">        &#125;</span><br><span class="line">        return fragment;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;a</span><br></pre></td></tr></table></figure>

<h3 id="实现-Watcher"><a href="#实现-Watcher" class="headerlink" title="实现 Watcher"></a>实现 Watcher</h3><p>Watcher 订阅者作为 Observer 和 Compile 之间的通信的桥梁，主要做的事情是：</p>
<ul>
<li>在自身实例化时往属性订阅器(dep)里添加自己</li>
<li>自身必须有一个 updata()方法</li>
<li>待属性变动 dep.notice() 时，能调用自身的 update() 方法并触发 Compile 中绑定的函数。</li>
</ul>
<h3 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h3><p>View: 视图层(UI 用户界面)<br>ViewModel: 业务逻辑层(一切 js 可视为业务逻辑层)<br>Model: 数据层(存储数据及对数据的处理如增删改查)</p>
<ul>
<li>MVVM 将数据双向绑定作为核心思想，View 和 Model 之间没有联系它们通过 ViewModel 这个桥梁进行交互。</li>
<li>Model 和 ViewModel 之间的交互是双向的，因此 View 的变化会自动同步到 Model，而 Model 的变化也会立即反映到 View 上显示。</li>
<li>用户操作 View， ViewModel 感知到变化，然后通知 Model 发生相应改变；反之当 Model 发生改变，ViewModel 也能感知到变化，使 View 做出相应更新。</li>
<li>ViewModel 通过双向数据绑定把 View 层和 Model 层连接起来，而 View 和 Model 之间的同步完全是自动的，无需人为干涉，开发者只需关注业务逻辑，不需要手动操作 DOM。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2021/04/22/%E9%9D%A2%E8%AF%95/vue%E5%8E%9F%E7%90%86&MVVM/" data-id="cl139u3lj002eswdxd7lsdi6l" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-浏览器缓存" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/04/22/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/" class="article-date">
  <time datetime="2021-04-22T07:51:22.473Z" itemprop="datePublished">2021-04-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/04/22/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/">浏览器缓存</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>浏览器对于请求资源，拥有一些成熟的缓存策略，按照发生的时间顺序分别为 <code>存储策略、过期策略、协商策略</code>。其中 <code>存储策略</code> 在收到响应后应用，<code>过期策略、协商策略</code> 在发送请求前应用</p>
<p><img src="https://lc-gold-cdn.xitu.io/54a021d766b64e993d39.png" alt="浏览器缓存机制剖析图"></p>
<h3 id="http-header-中与缓存有关的-key"><a href="#http-header-中与缓存有关的-key" class="headerlink" title="http header 中与缓存有关的 key"></a>http header 中与缓存有关的 key</h3><table>
<thead>
<tr>
<th>key</th>
<th>描述</th>
<th>策略类型</th>
</tr>
</thead>
<tbody><tr>
<td>Cache-Control</td>
<td>指定缓存机制，覆盖其它设置</td>
<td>存储策略</td>
</tr>
<tr>
<td>Pragma</td>
<td>http1.0 字段，指定缓存机制</td>
<td>存储策略</td>
</tr>
<tr>
<td>Expires</td>
<td>http1.0 字段，指定缓存的过期时间</td>
<td>过期策略</td>
</tr>
<tr>
<td>Last-Modified</td>
<td>资源最后一次的修改时间</td>
<td>协商策略</td>
</tr>
<tr>
<td>ETag</td>
<td>唯一标识请求资源的字符串</td>
<td>协商策略</td>
</tr>
</tbody></table>
<h3 id="缓存协商策略用于重新验证缓存资源是否有效"><a href="#缓存协商策略用于重新验证缓存资源是否有效" class="headerlink" title="缓存协商策略用于重新验证缓存资源是否有效"></a>缓存协商策略用于重新验证缓存资源是否有效</h3><table>
<thead>
<tr>
<th>key</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>if-Modified-Since</td>
<td>缓存校验字段，值为资源最后一次修改的时间，即上次收到的 Last-Modified 值</td>
</tr>
<tr>
<td>if-Unmodifed-Since</td>
<td>与上面相同，处理方式与上面相反</td>
</tr>
<tr>
<td>if-Match</td>
<td>缓存校验字段，值为唯一标识请求资源的字符串，即上次的 ETag 值</td>
</tr>
<tr>
<td>if-None-Match</td>
<td>同上，处理方式与之相反</td>
</tr>
</tbody></table>
<h3 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h3><p>浏览器缓存里，<code>Cache-Control</code> 是金字塔顶尖的规则，它藐视一切其他设置，只要其他设置与其抵触，一律覆盖，它还是一个复合规则，包含多种值，横跨 <code>存储策略、过期策略</code> 两种,同时在请求头和响应头都可设置。<br>语法 <code>Cache-Control:cache-directive</code></p>
<table>
<thead>
<tr>
<th>Cache-directive</th>
<th>描述</th>
<th>存储策略</th>
<th>过期策略</th>
<th>请求字段</th>
<th>响应字段</th>
</tr>
</thead>
<tbody><tr>
<td>public</td>
<td>资源将被客户端和代理服务器缓存</td>
<td>是</td>
<td>否</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>private</td>
<td>资源仅被客户端缓存，代理服务器不缓存</td>
<td>是</td>
<td>否</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>no-store</td>
<td>请求和响应都不缓存</td>
<td>是</td>
<td>否</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>no-cache</td>
<td>相当于 max-age:0,must-revalidate 即资源被缓存，但是缓存立刻过期，同时下次访问时强制验证资源有效性。</td>
<td>是</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>max-age</td>
<td>缓存资源，但是指定时间(单位为秒)后缓存过期</td>
<td>是</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
</tbody></table>
<h3 id="Pragma"><a href="#Pragma" class="headerlink" title="Pragma"></a>Pragma</h3><p>http1.0 字段，通常设置为 Pragma:no-cache,作用同 Cache-Control:no-cache,当一个 no-cache 请求发送给一个不遵循 HTTP/1.1 的服务器时，客户端应该包含 pragma 指令。</p>
<h3 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h3><p>即将到期时间，以服务器时间为参考系，其优先级比 Cache-Control:max-age 低，两者同时出现在响应头时， Expires 将被后者覆盖，如果 Expires, Cache-Control:max-age 或 Cache-Control:s-maxage 都没有在响应头中出现，并且也没有其它缓存的设置，那么浏览器默认会采用一个启发式算法，通常会取响应头的 Date_value -Last-Modified_value 值的 10%作为缓存时间。</p>
<h3 id="ETag"><a href="#ETag" class="headerlink" title="ETag"></a>ETag</h3><p>实体标签，服务器资源的唯一标识符，浏览器可以根据 ETag 值缓存数据，节省宽带，如果资源已经改变，etag 可以帮助防止同步更新资源的相互覆盖，ETag 优先级比 Last-Modified 高。</p>
<h3 id="If-Match"><a href="#If-Match" class="headerlink" title="If-Match"></a>If-Match</h3><p>语法：if-Match:ETag_value 或者 if-match:ETag_value,ETag_value<br>缓存校验字段，其值为上次收到的一个或多个 etag 值，常用于判断条件是否满足</p>
<h3 id="Last-Modified"><a href="#Last-Modified" class="headerlink" title="Last-Modified"></a>Last-Modified</h3><p>用于标记请求资源的最后一次修改时间，格式为 GMT(格林尼治标准时间)。优先级比 ETag 低，且只能精确到秒，因此不适合短时间内频繁的改动的资源，服务器端的静态资源，通常需要编译打包，可能出现资源内容没有改变，而 Last-Modified 却改变的情况。</p>
<h3 id="If-Modified-Since"><a href="#If-Modified-Since" class="headerlink" title="If-Modified-Since"></a>If-Modified-Since</h3><p>缓存校验字段，其值为上次响应头的 Last-Modified 值，若与请求资源当前的 Last-Modified 值相同，那么将返回 304 状态码的响应，反之将返回 200 状态码响应。</p>
<h3 id="If-Unmodified-Since"><a href="#If-Unmodified-Since" class="headerlink" title="If-Unmodified-Since"></a>If-Unmodified-Since</h3><p>缓存校验字段，表示资源未修改则正常执行更新，否则返回 412 状态码的响应。</p>
<h3 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h3><p>一旦资源命中强缓存，浏览器便不会向服务器发送请求，而是直接读取缓存。对于常规请求，只要存在该资源的缓存，且 Cache-Control:max-age 或者 expires 没有过期，那么就命中强缓存。</p>
<h3 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h3><p>协商缓存的响应结果，不仅验证了资源的有效性，同时还更新了浏览器缓存。<br>缓存过期后，继续请求该资源。有两种做法。</p>
<ul>
<li>根据上次响应中的 ETag_value,自动往 request header 中添加 If-None-Match 字段的值与资源的 ETag 值进行比较，若相同，则命中协商缓存，返回 304 响应。</li>
<li>根据上次响应中的 Last-Modified_vlaue,自动往 request header 中添加 If-Modified-Since 字段，服务器收到请求后，拿 If-Modified-Since 字段的值与资源的 Last-Modified 值进行比较，若相同，则命中协商缓存，返回 304 响应。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2021/04/22/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/" data-id="cl139u3jf000qswdx2drl7jua" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-再看JS高级" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/04/22/%E5%86%8D%E7%9C%8BJS%E9%AB%98%E7%BA%A7/" class="article-date">
  <time datetime="2021-04-22T07:51:22.472Z" itemprop="datePublished">2021-04-22</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/JavaScript-%E9%AB%98%E7%BA%A7/">JavaScript 高级</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/04/22/%E5%86%8D%E7%9C%8BJS%E9%AB%98%E7%BA%A7/">JavaScript 高级,</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="JavaScript-执行过程"><a href="#JavaScript-执行过程" class="headerlink" title="JavaScript 执行过程"></a>JavaScript 执行过程</h3><p>JavaScript 运行分为两个阶段</p>
<ul>
<li><p>预解析</p>
<ul>
<li><p>全局解析(所有的变量和函数声明都会提前；同名的函数和变量函数的优先级高)</p>
</li>
<li><p>先查找函数声明，再查找变量声明</p>
<ul>
<li>函数声明有冲突，会被后面的覆盖</li>
<li>变量声明有冲突，会忽略</li>
</ul>
</li>
<li><p>将找到的函数和变量保存到一个对象中(全局保存到 window 对象中)</p>
</li>
<li><p>变量的值是 undefined，函数的值则指向该函数(函数字符串)</p>
<ul>
<li>{a:undefined,f:’function (){}’}</li>
</ul>
</li>
<li><p>函数内部预解析(所有的变量、函数和形参都会参与预解析)</p>
<ul>
<li>读取整个函数源代码</li>
<li>将函数的参数添加到词法对象中</li>
<li>先查找函数声明，再查找变量声明<ul>
<li>函数声明有冲突，会被后面的覆盖</li>
<li>变量声明有冲突，会忽略</li>
</ul>
</li>
<li>将找到的函数和变量保存到一个词法对象中。</li>
<li>变量的值是 undefined，函数的值则指向该函数(函数字符串)<ul>
<li>{a:undefined,f:’function (){}’}</li>
</ul>
</li>
<li>函数</li>
</ul>
<ul>
<li>形参</li>
<li>普通变量</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>执行<br>先解析全局作用域，然后执行全局作用域中的代码，在执行全局代码的过程中遇到函数调用就会先进行函数预解析，然后再执行函数内部代码。</li>
</ul>
<h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><h4 id="什么是对象"><a href="#什么是对象" class="headerlink" title="什么是对象"></a>什么是对象</h4><p>Everything is object (万物皆对象)</p>
<ul>
<li>对象到底是什么，可以从两个层次来理解<ul>
<li>对象是单个事务的抽象<br>一本书、一辆车、一个人都可以是对象。当实物被抽象成对象，实物之间的关系就变成了对象之间的关系。</li>
<li>对象是一个容器，封装了属性(property) 和方法 (method)<br>属性是对象的状态，方法是对象的行为(完成某种任务)<br>实际开发中，对象是一个抽象的概念，可以理解为：数据集或功能集。<br>ECMAScript 把对象定义为：无序属性的集合，其属性可以包含基本值、对象或者函数。</li>
</ul>
</li>
</ul>
<h4 id="什么是面向对象"><a href="#什么是面向对象" class="headerlink" title="什么是面向对象"></a>什么是面向对象</h4><p>面向对象是过程式代码的一种高度封装，目的在于提高代码的开发效率和可维护性。</p>
<ul>
<li><p>面向对象编程<br>面向对象编程 — Object Oriented Programming，简称 OOP，是一种编程开发思想。它将真实世界各种复杂的关系，抽象为一个对象，然后由对象之间的分工与合作，完成对真实世界的模拟。<br>在面向对象程序开发思想中，每一个对象都是功能中心，具有明确分工。可以完成接收信息、处理数据、发出信息等任务。<br>面向对象编程具有灵活、代码复用、高度模块化等特点，容易开发和维护。</p>
</li>
<li><p>面向对象与面向过程</p>
<ul>
<li>面向过程就是亲历亲为，事无巨细，面面俱到，步步紧跟，有条不紊</li>
<li>面向对象就是找一个对象，指挥得到结果</li>
<li>面向对象将执行者转变成指挥者</li>
<li>面向对象不是面向过程的替代，而是面向过程的封装。</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2021/04/22/%E5%86%8D%E7%9C%8BJS%E9%AB%98%E7%BA%A7/" data-id="cl139u3j5000lswdx7uzg6y41" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/2/">&amp;laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/4/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/JavaScript-%E9%AB%98%E7%BA%A7/">JavaScript 高级</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/TypeScript/">TypeScript</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Vue-js/">Vue.js</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Vue-js/Props%E4%B8%8EData%E7%9A%84%E5%8C%BA%E5%88%AB/">Props与Data的区别</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Vue-js-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/">Vue.js 源码解读</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Vue-js-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E5%8F%98%E5%8C%96%E4%BE%A6%E6%B5%8B/">变化侦测</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Vue-js-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E5%8F%98%E5%8C%96%E4%BE%A6%E6%B5%8B/%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8F%98%E5%8C%96%E4%BE%A6%E5%90%AC/">数据的变化侦听</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Vue-js-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E5%90%8D%E8%AF%8D/">名词</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Vue-js-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E6%A8%A1%E6%9D%BF%E7%BC%96%E8%AF%91/">模板编译</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Vue-js-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/">生命周期</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Vue-js-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/%E5%88%9D%E5%A7%8B%E5%8C%96-initState-%E9%98%B6%E6%AE%B5/">初始化 initState 阶段</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Vue-js-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E8%99%9A%E6%8B%9FDOM/">虚拟DOM</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Vue-js-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E8%99%9A%E6%8B%9FDOM/Diff/">Diff</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Vue-js-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E8%99%9A%E6%8B%9FDOM/Vue%E4%B8%AD%E7%9A%84%E8%99%9A%E6%8B%9FDom/">Vue中的虚拟Dom</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Vue-js-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E8%99%9A%E6%8B%9FDOM/%E6%9B%B4%E6%96%B0%E5%AD%90%E8%8A%82%E7%82%B9/">更新子节点</a></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/async-await/">async await</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/elementUI%E5%A5%87%E6%80%AA%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/">elementUI奇怪问题解决办法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/element%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/">element使用不常用方法总结</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/es6/">es6</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/es6/Symbol/">Symbol</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/es6/%E8%BF%90%E7%AE%97%E7%AC%A6%E6%89%A9%E5%B1%95/">运算符扩展</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/import-%E5%92%8C-export/">import 和 export</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/js%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/">js知识体系</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/js%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/js-%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/">js 代码执行过程分析</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/js%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/js-%E8%AF%AD%E8%A8%80%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7/">js 语言的三大特性</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/js%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/%E4%BA%8B%E4%BB%B6/">事件</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/js%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/%E6%95%B0%E6%8D%AE/">数据</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/webpack/">webpack</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/">正则表达式</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/%E6%AD%A3%E5%88%99%E7%9F%A5%E8%AF%86%E7%82%B9/">正则知识点</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E6%B6%89%E5%8F%8A%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9/">浏览器渲染涉及的知识点</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%99%BB%E5%BD%95%E8%AE%A4%E8%AF%81%E7%9F%A5%E8%AF%86/">登录认证知识</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9D%A2%E8%AF%95/vue%E7%9F%A5%E8%AF%86%E7%82%B9/">vue知识点</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9D%A2%E8%AF%95/vue%E7%9F%A5%E8%AF%86%E7%82%B9/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9F%A5%E8%AF%86/">生命周期知识</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9D%A2%E8%AF%95/vue%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%8CSPA%E5%8D%95%E9%A1%B5%E9%9D%A2/">vue知识点，SPA单页面</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9D%A2%E8%AF%95/vue%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%8C%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86-MVVM/">vue知识点，双向数据绑定原理& MVVM</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9D%A2%E8%AF%95/vue%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%8C%E8%B7%AF%E7%94%B1%E6%A8%A1%E5%BC%8F%E5%8E%9F%E7%90%86/">vue知识点，路由模式原理</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9D%A2%E8%AF%95/%E4%BB%8EURL%E8%BE%93%E5%85%A5%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%8E%B0%E6%B6%89%E5%8F%8A%E7%9A%84%E7%9F%A5%E8%AF%86%E3%80%82/">从URL输入到页面展现涉及的知识。</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9D%A2%E8%AF%95/%E4%BD%9C%E7%94%A8%E5%9F%9F-%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/">作用域-作用域链</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9D%A2%E8%AF%95/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/">浏览器缓存</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84js%E6%93%8D%E4%BD%9C/">项目中常用的js操作</a></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">March 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">February 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/12/">December 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/11/">November 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/10/">October 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/09/">September 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">August 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">July 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">June 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">May 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/03/14/TypeScript/ts/">TypeScript</a>
          </li>
        
          <li>
            <a href="/2022/02/22/webpack/webpack/">webpack</a>
          </li>
        
          <li>
            <a href="/2021/12/25/%E6%AD%A3%E5%88%99/%E6%AD%A3%E5%88%99%E7%9F%A5%E8%AF%86%E7%82%B9/">正则知识点,</a>
          </li>
        
          <li>
            <a href="/2021/11/26/es6/Symbol/">Symbol,</a>
          </li>
        
          <li>
            <a href="/2021/11/25/es6/%E6%96%B0%E5%A2%9E%E8%BF%90%E7%AE%97%E7%AC%A6/">运算符的扩展,</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2022 sxhMxd<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>