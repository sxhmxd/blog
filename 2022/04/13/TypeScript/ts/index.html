<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>TypeScript | 有理想的笛子</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="TypeScript 是什么TS 简介 Ts是微软开发的一个开源编程语言，通过在JS的基础上添加静态类型定义构建而成。TS通过TS编译器或者Babel转译为JS代码，可运行在任何浏览器，任何操作系统。 TS 和 JS的区别 TS 是JS 的一个超集，之间没有所属关系，ts扩展了js 弱类型语言的限制，增加更多的模块解析方式和语法糖。ts 并不是一个可以独立运行的语言，大多数时候可以被转译成js 运">
<meta property="og:type" content="article">
<meta property="og:title" content="TypeScript">
<meta property="og:url" content="http://yoursite.com/2022/04/13/TypeScript/ts/index.html">
<meta property="og:site_name" content="有理想的笛子">
<meta property="og:description" content="TypeScript 是什么TS 简介 Ts是微软开发的一个开源编程语言，通过在JS的基础上添加静态类型定义构建而成。TS通过TS编译器或者Babel转译为JS代码，可运行在任何浏览器，任何操作系统。 TS 和 JS的区别 TS 是JS 的一个超集，之间没有所属关系，ts扩展了js 弱类型语言的限制，增加更多的模块解析方式和语法糖。ts 并不是一个可以独立运行的语言，大多数时候可以被转译成js 运">
<meta property="og:locale" content="zh">
<meta property="article:published_time" content="2022-04-13T07:41:56.416Z">
<meta property="article:modified_time" content="2022-04-13T07:41:56.417Z">
<meta property="article:author" content="sxhMxd">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="有理想的笛子" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">有理想的笛子</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-TypeScript/ts" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/04/13/TypeScript/ts/" class="article-date">
  <time datetime="2022-04-13T07:41:56.416Z" itemprop="datePublished">2022-04-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/TypeScript/">TypeScript</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      TypeScript
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="TypeScript-是什么"><a href="#TypeScript-是什么" class="headerlink" title="TypeScript 是什么"></a>TypeScript 是什么</h2><h3 id="TS-简介"><a href="#TS-简介" class="headerlink" title="TS 简介"></a>TS 简介</h3><p> Ts是微软开发的一个开源编程语言，通过在JS的基础上添加静态类型定义构建而成。TS通过TS编译器或者Babel转译为JS代码，可运行在任何浏览器，任何操作系统。</p>
<h3 id="TS-和-JS的区别"><a href="#TS-和-JS的区别" class="headerlink" title="TS 和 JS的区别"></a>TS 和 JS的区别</h3><p> TS 是JS 的一个超集，之间没有所属关系，ts扩展了js 弱类型语言的限制，增加更多的模块解析方式和语法糖。ts 并不是一个可以独立运行的语言，大多数时候可以被转译成js 运行。 可以认为 ts 相当于功能更丰富的编译型的js。</p>
<h3 id="为什么要有TS"><a href="#为什么要有TS" class="headerlink" title="为什么要有TS"></a>为什么要有TS</h3><p>传统的js本身已经完全满足应用打开，但是在大型项目或者插件的开发场景中，js 弱类型语言的不足便暴露出来，由于js是解释型语言，在代码编译的过程中无法轻松的实现良好的类型约束和类型推断。若开发者提供了一个解释依赖包给其他开发者来使用，使用依赖的开发者并不能显示观察依赖包的内部组成。这样导致在代码阅读上无法确定该属性的明确类型，会导致代码运行上存在风险。</p>
<p>  综上所述，js在代码的可维护性上存在一些弱项，所有强类型的ts正好适用于此类型开发场景。<br>   ts 强类型的约束性及其面向接口编程的约束性可以让ts 语言开发的应用有极强的维护性，代价是更大的代码篇幅。<br>   ts适用于插件提供者，依赖库提供者，基于js的服务端项目，已经大型项目的工程化开发使用。</p>
<h2 id="TypeScript-语法"><a href="#TypeScript-语法" class="headerlink" title="TypeScript 语法"></a>TypeScript 语法</h2><h3 id="基础数据类型"><a href="#基础数据类型" class="headerlink" title="基础数据类型"></a>基础数据类型</h3><h4 id="jS的八种内置类型"><a href="#jS的八种内置类型" class="headerlink" title="jS的八种内置类型"></a>jS的八种内置类型</h4>  <figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str: <span class="built_in">string</span> = <span class="string">"111"</span>;</span><br><span class="line"><span class="keyword">let</span> num: <span class="built_in">number</span> = <span class="number">123</span>;</span><br><span class="line"><span class="keyword">let</span> bool: <span class="built_in">boolean</span> = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">let</span> u: <span class="literal">undefined</span> = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">let</span> nu: <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> obj: object = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> big: bigint = <span class="number">100n</span>;</span><br><span class="line"><span class="keyword">let</span> sym: symbol = Symbol(<span class="string">"me"</span>);</span><br></pre></td></tr></table></figure>

<h3 id="其他类型"><a href="#其他类型" class="headerlink" title="其他类型"></a>其他类型</h3><h4 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h4><ul>
<li><p>对数组类型的定义有两种方式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arrStr: string[] = [<span class="string">"1"</span>, <span class="string">"2"</span>];</span><br><span class="line"><span class="keyword">let</span> arrNum: <span class="built_in">Array</span>&lt;string&gt; = [<span class="string">"1"</span>, <span class="string">"2"</span>];</span><br></pre></td></tr></table></figure>
</li>
<li><p>定义联合类型数组</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr2: (<span class="built_in">string</span> | <span class="built_in">number</span>)[] = [<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> arr1: <span class="built_in">Array</span>&lt;<span class="built_in">string</span> | <span class="built_in">number</span>&gt; = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br></pre></td></tr></table></figure>
</li>
<li><p>定义指定对象成员的数组</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> ArrayObj &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> arrObj: ArrayObj[] = [&#123; name: <span class="string">"xxx"</span>, age: <span class="number">12</span> &#125;];</span><br><span class="line"><span class="comment">// 任意类型的数组</span></span><br><span class="line"><span class="keyword">let</span> arrAny: <span class="built_in">any</span>[] = [<span class="number">1</span>,<span class="string">'string'</span>,<span class="built_in">boolean</span>,<span class="literal">null</span>,<span class="literal">undefined</span>]</span><br><span class="line"><span class="keyword">let</span> arrAny1:<span class="built_in">Array</span>&lt;<span class="built_in">any</span>&gt; = [<span class="number">1</span>,<span class="number">2</span>,<span class="literal">true</span>,<span class="string">'string'</span>]</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><ul>
<li><p>函数声明</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>函数表达式</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> mySum: <span class="function">(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span> = <span class="function"><span class="keyword">function</span> (<span class="params">x: <span class="built_in">number</span> y:<span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>可选参数且函数有返回值</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">joinName</span>(<span class="params">firstName: <span class="built_in">string</span>, lastName?: <span class="built_in">string</span></span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> firstName + lastName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数默认值</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">names</span>(<span class="params">firstName: <span class="built_in">string</span>, lastName: <span class="built_in">string</span> = "Cat"</span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> firstName + lastName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>剩余参数</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">push</span>(<span class="params">arr: <span class="built_in">any</span>[], ...items: <span class="built_in">any</span>[]</span>) </span>&#123;</span><br><span class="line">  items.forEach(<span class="function">(<span class="params">element</span>) =&gt;</span> &#123;</span><br><span class="line">    arr.push(element);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>带参数无返回值<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">name:<span class="built_in">string</span>,age:<span class="built_in">number</span></span>):<span class="title">void</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>函数重载<br>js是一个动态语言，我们通常会使用不同类型的参数来调用同一个函数，该函数会根据不同的参数返回不同类型的调用结果;</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line">add(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">add(<span class="string">"1"</span>,<span class="string">"2"</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li><p>定义联合类型 </p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义联合类型同时为该联合类型取一个别名</span></span><br><span class="line"><span class="keyword">type</span> Combinable = <span class="built_in">string</span> | <span class="built_in">number</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用联合类型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a:Combinable,b:Combinable</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> a === <span class="string">'string'</span> || <span class="keyword">typeof</span> b === <span class="string">'string'</span>) &#123;    </span><br><span class="line">  <span class="keyword">return</span> a.toString() + b.toString();   </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Tuple-元组"><a href="#Tuple-元组" class="headerlink" title="Tuple(元组)"></a>Tuple(元组)</h3></li>
</ul>
</li>
<li><p>元组定义<br>元组是TypeSctipt 中特有的类型，其工作方式类似于数组元组最重要的特性是可以限制<code>数组元素的个数和类型</code>,特别适合用来实现多值返回。<br>元组用于保存定长定数据类型的数据。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x: [<span class="built_in">string</span>,<span class="built_in">number</span>] years</span><br><span class="line"><span class="comment">// 类型必须匹配且个数必须为2</span></span><br><span class="line">x = [<span class="string">"12"</span>,<span class="number">10</span>] <span class="comment">// ok</span></span><br><span class="line">x = [<span class="number">10</span>,<span class="number">10</span>]   <span class="comment">// error</span></span><br></pre></td></tr></table></figure></li>
<li><p>元组类型的解构赋值</p>
</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> employee:[<span class="built_in">number</span>,<span class="built_in">string</span>] = [<span class="number">1</span>,<span class="string">'string'</span>]</span><br><span class="line"><span class="keyword">let</span> [id,username] = employee</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`id:<span class="subst">$&#123;id&#125;</span>`</span>)   <span class="comment">// id:1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`username:<span class="subst">$&#123;username&#125;</span>`</span>)  <span class="comment">// username:string</span></span><br></pre></td></tr></table></figure>
<p>注意点，在解构时，如果解构数组元素的个数不能超过元组中元素的个数，否则也会出现错误。</p>
<ul>
<li><p>元组类型的可选元素<br>在定义元组类型时，可以通过 ? 号来声明元组类型的可选元素。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> optionalTuple:[<span class="built_in">string</span>,<span class="built_in">boolean</span>?];</span><br><span class="line">optionalTuple = [<span class="string">'string'</span>,<span class="literal">true</span>]</span><br><span class="line">optionalTuple = [<span class="string">'string'</span>]</span><br></pre></td></tr></table></figure>
<h3 id="枚举-interFace"><a href="#枚举-interFace" class="headerlink" title="枚举 interFace"></a>枚举 interFace</h3><p>是一个完全抽象的对象，一个interface 可以对应多个class 对其内部的未实现方法进行实现，ts 中，interface 主要用于类型描述。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">interface</span> User&#123;</span><br><span class="line">      name:<span class="built_in">string</span></span><br><span class="line">      age:<span class="built_in">number</span></span><br><span class="line">      sex:<span class="built_in">string</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> obj:User =&#123;</span><br><span class="line">      name:<span class="built_in">string</span></span><br><span class="line">      age:<span class="built_in">number</span></span><br><span class="line">      sex:<span class="built_in">string</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//是强约束 约定该对象必须包含name,age,sex 这几个属性，不能有其他对象</span></span><br><span class="line">    <span class="keyword">interface</span> Us&#123;</span><br><span class="line">      readonly name:<span class="built_in">string</span>,  <span class="comment">// 表示该属性只读，不可以修改</span></span><br><span class="line">      age:<span class="built_in">number</span>,</span><br><span class="line">      [props:<span class="built_in">string</span>]:<span class="built_in">any</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 可以有约定以外的其他属性</span></span><br><span class="line">    <span class="keyword">interface</span> Func&#123;</span><br><span class="line">      (name):<span class="built_in">string</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 定义函数的接口</span></span><br><span class="line">    <span class="keyword">let</span> fun:Func = <span class="function"><span class="keyword">function</span>(<span class="params">name:<span class="built_in">string</span></span>):<span class="title">string</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> name</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">interface</span> User &#123;</span><br><span class="line">      name:<span class="built_in">string</span>,</span><br><span class="line">      age:<span class="built_in">number</span>,</span><br><span class="line">      sex:<span class="built_in">string</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">interface</span> Admin&#123;</span><br><span class="line">      name:<span class="built_in">string</span>,</span><br><span class="line">      age:<span class="built_in">number</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">type</span> Person = User | Admin</span><br><span class="line">    <span class="keyword">let</span> userobj =  <span class="built_in">Array</span>&lt;Person&gt; = [</span><br><span class="line">      &#123;name:<span class="string">''</span>,age:<span class="string">''</span>,sex:<span class="string">''</span>&#125;,</span><br><span class="line">      &#123;name:<span class="string">""</span>,age:<span class="string">""</span>&#125;</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">  <span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">### 泛型</span></span><br><span class="line"><span class="string"> 泛型是静态类型语言的另一灵魂工具，这里体现于静态类型的语言在定义类型时必须明确类型而造成的问题。</span></span><br><span class="line"><span class="string"> 当函数的参数和返回类型明确时，相同结构的函数需要根据不同的类型定义多个，这种情况很容易将代码的复杂度提高降低可维护性</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  `</span><span class="string">``</span> ts</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">test</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg:T</span>):<span class="title">T</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="类型推断"><a href="#类型推断" class="headerlink" title="类型推断"></a>类型推断</h3><p>在很多情况下，Typescript会根据上下文环境自动推断出变量的类型，无需我们再写明类型注解。<br>  <figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">'ss'</span></span><br><span class="line"><span class="keyword">let</span> num = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> bool = <span class="literal">true</span></span><br></pre></td></tr></table></figure><br>我们把TypeScript 这种基于赋值表达式推断类型的能力称之为 <code>类型推断</code></p>
<h3 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h3><p>  有时候会遇到这样的情况，你会比ts 更了解某个值的详细信息通常这会发生在你清楚的知道一个实体具有比它现有类型更确切的类型。<br>  通过类型断言这种方式告诉编辑器 ，”相信我，我知道自己在干什么”。类型断言好比其他语言里的类型转换，但是不进行特殊的数据检查和解构。它没有运行时的影响，只是在编译阶段起作用。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 尖括号语法</span></span><br><span class="line"><span class="keyword">let</span> someValue:<span class="built_in">any</span> = <span class="string">'this is a string'</span></span><br><span class="line"><span class="keyword">let</span> strLength:<span class="built_in">number</span> = (&lt;<span class="built_in">string</span>&gt;someValue).length</span><br><span class="line"><span class="comment">// as 语法</span></span><br><span class="line"><span class="keyword">let</span> someValue:<span class="built_in">any</span> = <span class="string">'this is a string'</span></span><br><span class="line"><span class="keyword">let</span> strLength:<span class="built_in">number</span> = (someValue <span class="keyword">as</span> <span class="built_in">string</span>).length</span><br></pre></td></tr></table></figure>
<h3 id="非空断言"><a href="#非空断言" class="headerlink" title="非空断言"></a>非空断言</h3><p>  在上下文中当类型检查器无法判定类型时，一个新的后缀表达式操作符! 可以用于断言操作对象是非 null 和undefined 类型，<code>x! 将从x值域中排除 null 和undefined</code><br>  <figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> value:<span class="literal">null</span> | <span class="literal">undefined</span> | <span class="built_in">string</span> </span><br><span class="line">value!.toString() </span><br><span class="line">value.toString()  <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure></p>
<h3 id="确定赋值断言"><a href="#确定赋值断言" class="headerlink" title="确定赋值断言"></a>确定赋值断言</h3><p>  允许实例属性和变量声明后面放置一个! 号，从而告诉 ts 该属性会被明确地赋值。<br>  <figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x: <span class="built_in">number</span>;</span><br><span class="line">initialize();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Variable 'x' is used before being assigned.(2454)</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span> * x); <span class="comment">// Error</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initialize</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">  x = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用确定赋值断言</span></span><br><span class="line"><span class="keyword">let</span> x!:<span class="built_in">number</span></span><br><span class="line">initialize()</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>*x)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initialize</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  x=<span class="number">10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>  通过 <code>let x!:number</code> 确定赋值类型断言，ts编辑器就会知道该属性会被明确地赋值。</p>
<h3 id="字面量类型"><a href="#字面量类型" class="headerlink" title="字面量类型"></a>字面量类型</h3><p>  在ts 中字面量不仅可以表示值，还可以表示类型，即所谓的字面量类型。目前ts支持三种字面量类型：<code>字符串字面量类型、数字字面量类型、布尔字面量类型</code>。<br>  <figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str: <span class="string">'1'</span> =<span class="string">'string'</span></span><br><span class="line"><span class="keyword">let</span> num: <span class="number">1</span> = <span class="number">124</span></span><br><span class="line"><span class="keyword">let</span> bool: <span class="literal">true</span> = <span class="literal">false</span></span><br></pre></td></tr></table></figure></p>
<h3 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h3><p>  联合类型表示取值可以为多种类型中的一种，使用 | 分割每个类型</p>
  <figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> strNum: <span class="built_in">string</span> | <span class="built_in">number</span> </span><br><span class="line">strNum = <span class="string">'ss'</span></span><br><span class="line">strNum = <span class="number">123</span></span><br></pre></td></tr></table></figure>
<h3 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h3><p>  类型别名用来给一个类型起一个新名字。类型别名常用于联合类型</p>
  <figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Message = <span class="built_in">string</span> | <span class="built_in">string</span>[]</span><br></pre></td></tr></table></figure>
<p>  注意：类型别名是给类型起一个新的名字，并不是创建一个新的类型。</p>
<h3 id="交叉类型"><a href="#交叉类型" class="headerlink" title="交叉类型"></a>交叉类型</h3><p>  交叉类型是将多个类型合并为一个类型。我们可以把现有的多种类型叠加到一起成为一种类型，它包含了所需的所有类型的特性，使用<code>&amp;</code> 定义交叉类型。<br>  如果我们仅仅是把原始类型，字面量类型，函数类型等原始类型合并成为交叉类型是没有任何用处的。它的用处是将多个接口类型合并成一个类型，从而实现等同接口继承的效果，也就是所谓的合并接口类型。<br>  <figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span>  IntersectionType = &#123;id:<span class="built_in">number</span>,name:<span class="built_in">string</span>&#125;&amp;&#123;age:<span class="built_in">number</span>&#125;</span><br><span class="line"><span class="keyword">const</span> user:IntersectonType = &#123;</span><br><span class="line">  id:<span class="number">1</span>,</span><br><span class="line">  name:<span class="string">'name'</span>,</span><br><span class="line">  age:<span class="number">18</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>  上面例子，我们通过交叉类型，使得IntersectionType 同时拥有了id name age 所有属性，这里我们可以试着将合并接口类型理解为求并集。</p>
<h2 id="object-Object-和"><a href="#object-Object-和" class="headerlink" title="object Object 和 {}"></a>object Object 和 {}</h2><p>小 <code>object</code> 代表的是所有非原始类型，也就是我们不能把 <code>number string boolean</code> 等原始类型赋值给<code>object</code> 。在严格模式下 <code>null</code> 和<code>undefined</code> 类型也不能赋给 <code>object</code></p>
<p>大 <code>Object</code> 代表所有拥有 <code>toString hasOwnProperty</code> 方法的类型，所以所有原始类型、非原始类型都可以赋给 <code>Object</code>。 在严格模式下 <code>null</code> 和<code>undefined</code> 类型也不能赋给 <code>object</code><br>  大 Object 保护你原始类型，小object 仅包含非原始类型，所以大Object 似乎是小 object的父类型。实际上， 大Object 不仅是 小object的父类型，同时也是小object的子类型。<br>  注意点：尽管官方文档说可以使用小object代替 大Object，但是我们仍要明白大Object 并不完全等于小object。</p>
<p><code>{}</code> 空对象类型和大Object一样，也是表示原始类型和非原始类型的集合，并且在严格模式下，<code>null</code> 和 <code>undefined</code> 也不能赋给 <code>{}</code><br><code>综上结论：{}、大 Object 是比小 object 更宽泛的类型（least specific），{} 和大 Object 可以互相代替，用来表示原始类型（null、undefined 除外）和非原始类型；而小 object 则表示非原始类型。</code></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2022/04/13/TypeScript/ts/" data-id="cl8473rcf004qw0dxa788c5xo" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2022/07/16/vue2vsvue3/beagin/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          vue2 VS vue3,
        
      </div>
    </a>
  
  
    <a href="/2022/04/13/%E9%A1%B9%E7%9B%AE%E9%81%87%E5%88%B0%E7%9A%84%E5%A5%87%E6%80%AA%E9%97%AE%E9%A2%98/elementUI%E5%A5%87%E6%80%AA%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">elementUI奇怪问题解决办法</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/CommonJS-AMD-CMD-ES6/">CommonJS AMD CMD ES6</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/JS%E6%A8%A1%E5%9D%97%E5%8C%96%E5%8F%91%E5%B1%95/">JS模块化发展</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/JavaScript-%E9%AB%98%E7%BA%A7/">JavaScript 高级</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/TypeScript/">TypeScript</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Vue-js/">Vue.js</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Vue-js/Props%E4%B8%8EData%E7%9A%84%E5%8C%BA%E5%88%AB/">Props与Data的区别</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Vue-js-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/">Vue.js 源码解读</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Vue-js-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E5%8F%98%E5%8C%96%E4%BE%A6%E6%B5%8B/">变化侦测</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Vue-js-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E5%8F%98%E5%8C%96%E4%BE%A6%E6%B5%8B/%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8F%98%E5%8C%96%E4%BE%A6%E5%90%AC/">数据的变化侦听</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Vue-js-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E5%90%8D%E8%AF%8D/">名词</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Vue-js-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E6%A8%A1%E6%9D%BF%E7%BC%96%E8%AF%91/">模板编译</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Vue-js-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/">生命周期</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Vue-js-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/%E5%88%9D%E5%A7%8B%E5%8C%96-initState-%E9%98%B6%E6%AE%B5/">初始化 initState 阶段</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Vue-js-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E8%99%9A%E6%8B%9FDOM/">虚拟DOM</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Vue-js-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E8%99%9A%E6%8B%9FDOM/Diff/">Diff</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Vue-js-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E8%99%9A%E6%8B%9FDOM/Vue%E4%B8%AD%E7%9A%84%E8%99%9A%E6%8B%9FDom/">Vue中的虚拟Dom</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Vue-js-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E8%99%9A%E6%8B%9FDOM/%E6%9B%B4%E6%96%B0%E5%AD%90%E8%8A%82%E7%82%B9/">更新子节点</a></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/async-await/">async await</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/elementUI%E5%A5%87%E6%80%AA%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/">elementUI奇怪问题解决办法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/element%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/">element使用不常用方法总结</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/es6/">es6</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/es6/Symbol/">Symbol</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/es6/%E8%BF%90%E7%AE%97%E7%AC%A6%E6%89%A9%E5%B1%95/">运算符扩展</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/import-%E5%92%8C-export/">import 和 export</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/js%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/">js知识体系</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/js%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/js-%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/">js 代码执行过程分析</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/js%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/js-%E8%AF%AD%E8%A8%80%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7/">js 语言的三大特性</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/js%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/%E4%BA%8B%E4%BB%B6/">事件</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/js%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/%E6%95%B0%E6%8D%AE/">数据</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/vue2-%E4%B8%8E-vue3/">vue2 与 vue3</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/webpack/">webpack</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/">正则表达式</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/%E6%AD%A3%E5%88%99%E7%9F%A5%E8%AF%86%E7%82%B9/">正则知识点</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E6%B6%89%E5%8F%8A%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9/">浏览器渲染涉及的知识点</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/">状态管理</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%99%BB%E5%BD%95%E8%AE%A4%E8%AF%81%E7%9F%A5%E8%AF%86/">登录认证知识</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9D%A2%E8%AF%95/vue%E7%9F%A5%E8%AF%86%E7%82%B9/">vue知识点</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9D%A2%E8%AF%95/vue%E7%9F%A5%E8%AF%86%E7%82%B9/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9F%A5%E8%AF%86/">生命周期知识</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9D%A2%E8%AF%95/vue%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%8CSPA%E5%8D%95%E9%A1%B5%E9%9D%A2/">vue知识点，SPA单页面</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9D%A2%E8%AF%95/vue%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%8C%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86-MVVM/">vue知识点，双向数据绑定原理& MVVM</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9D%A2%E8%AF%95/vue%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%8C%E8%B7%AF%E7%94%B1%E6%A8%A1%E5%BC%8F%E5%8E%9F%E7%90%86/">vue知识点，路由模式原理</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9D%A2%E8%AF%95/%E4%BB%8EURL%E8%BE%93%E5%85%A5%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%8E%B0%E6%B6%89%E5%8F%8A%E7%9A%84%E7%9F%A5%E8%AF%86%E3%80%82/">从URL输入到页面展现涉及的知识。</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9D%A2%E8%AF%95/%E4%BD%9C%E7%94%A8%E5%9F%9F-%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/">作用域-作用域链</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9D%A2%E8%AF%95/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/">浏览器缓存</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84js%E6%93%8D%E4%BD%9C/">项目中常用的js操作</a></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/09/">September 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/08/">August 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/07/">July 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/04/">April 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">July 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/09/16/js%E6%A8%A1%E5%9D%97%E5%8C%96%E5%8F%91%E5%B1%95/%E5%90%84%E7%A7%8D%E6%A8%A1%E5%9D%97%E5%8C%96%E6%96%B9%E6%A1%88%E8%A7%84%E8%8C%83/">JS 模块化</a>
          </li>
        
          <li>
            <a href="/2022/09/15/js%E6%A8%A1%E5%9D%97%E5%8C%96%E5%8F%91%E5%B1%95/%E5%89%8D%E8%A8%80/">JS 模块化</a>
          </li>
        
          <li>
            <a href="/2022/08/12/%E5%89%8D%E7%AB%AF%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/">前端状态管理</a>
          </li>
        
          <li>
            <a href="/2022/07/27/%E9%9D%A2%E8%AF%95/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/">面试/面试问题</a>
          </li>
        
          <li>
            <a href="/2022/07/16/vue2vsvue3/beagin/">vue2 VS vue3,</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2022 sxhMxd<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>